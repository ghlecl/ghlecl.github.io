<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="author" content="Ghyslain Leclerc">
    <meta name="description" content="Personnal notes on code.">
    <meta name="generator" content="Hugo 0.46" />

    
    <title>Python&#39;s range in C&#43;&#43; &middot; @ghlecl’s Code Attempts</title>

    <link rel="stylesheet" href="https://ghlecl.github.io/css/weblog.css" media="screen" charset="utf-8" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/lightgallery/1.2.14/css/lightgallery.min.css" type="text/css" />
    
<link rel="stylesheet" href="https://ghlecl.github.io/css/prism.css">


    
	<link href="https://ghlecl.github.io/index.xml" rel="alternate" type="application/rss+xml" title="Code Attempts" />
	
  </head>
  <body class="site">

<header>
  <nav>
    <h1><a href="https://ghlecl.github.io/">@ghlecl</a>’s Code Attempts.</h1>
    <div class="menu">
      
      <ul>
        
            <li>
              <a href="https://ghlecl.github.io/posts/">Posts</a>
              
                <a href="https://ghlecl.github.io/posts/index.xml"><img src="https://ghlecl.github.io/img/rss.svg" class="rss-icon" /></a>
              
            </li>
        
            <li>
              <a href="https://ghlecl.github.io/microposts/">Microposts</a>
              
                <a href="https://ghlecl.github.io/microposts/index.xml"><img src="https://ghlecl.github.io/img/rss.svg" class="rss-icon" /></a>
              
            </li>
        
        <li><a href="https://ghlecl.github.io/about">About</a></li>
      </ul>
    </div>
  </nav>
</header>


  <main class="content">

    <article class="post">
      
        <h2><a rel="full-article" href="https://ghlecl.github.io/posts/range_function/">Python&#39;s range in C&#43;&#43;</a></h2>
      

      <div class="postmeta">Posted on <time datetime="2018-08-05 00:00:00 &#43;0000 UTC" pubdate="">August 5, 2018</time> in
        <span class="categories">
          
        </span>
      </div>

      <p>
        

<h1 id="exploring-loops-python-s-range-in-c">Exploring loops: Python&rsquo;s range in C++</h1>

<p>In spite of what Sean Parent would like (i.e. <a href="https://channel9.msdn.com/Events/GoingNative/2013/Cpp-Seasoning" target="_blank">no raw loops</a> ;-) ), loops
are a common control flow in programming.  So common that most languages have
more than one <a href="https://en.wikipedia.org/wiki/Control_flow#Loops" target="_blank">loop</a> syntax:
<a href="https://en.wikipedia.org/wiki/For_loop" target="_blank">for loop</a>,
<a href="https://en.wikipedia.org/wiki/While_loop" target="_blank">while loop</a>,
<a href="https://en.wikipedia.org/wiki/Do_while_loop" target="_blank">do while loop</a>&hellip;  Given their
prevalence, loops might seem uninteresting, but when I decided to look into
creating a <code>range</code> function<sup>[1]</sup> for C++ which would behave like Python&rsquo;s
<code>range</code> object, I learned a thing or two and decided to write them down.</p>

<p>For the impatient, the code I came up with is available on
<a href="https://github.com/ghlecl/range_fn" target="_blank">Github</a>.  It was inspired by
<a href="https://www.justsoftwaresolutions.co.uk/cplusplus/
generating_sequences.html" target="_blank">Anthony William&rsquo;s post</a> on the subject.  I will put the same disclaimer here
that Anthony put in his post:</p>

<blockquote>
<p>&hellip;hopefully people will find this instructive, if not useful.</p>
</blockquote>

<p>As he points out, there are more complete alternatives (e.g. the
<a href="https://www.boost.org/doc/libs/1_67_0/libs/range/doc/html/index.html" target="_blank">Boost range library</a>)
with a probably higher quality of implementation (at the price of bringing the
whole of Boost into your project if you do not already depend on it).<sup>[2]</sup></p>

<p>This turned out to be quite a longer blog entry than I anticipated.  Consider
yourself warned!</p>

<h2 id="iterating-over-containers">Iterating over containers</h2>

<p>Out of the C++11 (and beyond) features, <a href="http://en.cppreference.com/w/cpp/language/range-for" target="_blank">range-based for loop</a> is a favorite of mine.
Prior to that being available, if you wanted to iterate over every element of a
container, the alternatives were rather verbose.  Amongst others, there is the
C style for loop using the <a href="http://en.cppreference.com/w/cpp/iterator" target="_blank">iterators</a>
that can be retrieved by the <code>begin()</code> and <code>end()</code> functions of the STL
containers:</p>

<pre><code class="language-c++">std::list&lt;double&gt; lst;  // ... fill list somehow ...

typedef std::list&lt;double&gt;::iterator lst_iter;
for( lst_iter beg = lst.begin(), end = lst.end(); beg != end; ++beg ) {
   double cur = *beg;
   // use cur (or use *beg directly everywhere)
}
</code></pre>

<p>or the <a href="http://en.cppreference.com/w/cpp/algorithm/for_each" target="_blank"><code>for_each</code></a>
algorithm to which one provides a function object to apply to every element of
the container:</p>

<pre><code class="language-c++">std::list&lt;double&gt; lst;  // ... fill list somehow ...

struct my_op {
   void operator()( double item ) {
      // use item
   }
};
std::for_each( lst.begin(), lst.end(), my_op() );
</code></pre>

<p>Those work, but they have a few drawbacks, amongst which you can find 1) being
verbose and 2) not working with built-in arrays.  Compare that to other languages
where the syntax for iterating over a container is more concise and more
universally applied, like Python for instance:</p>

<pre><code class="language-python">a = [ 0, 1, 2, 3, 4 ]
for x in a:
   #use x
</code></pre>

<p>and you can see a difference, at a minimum in verbosity.  With range-based for
loops, C++ closes the gap.  The syntax, introduced in C++11, is terser and works
with both containers and built-in arrays (which is what I show in the example
below).  Here is what it looks like, which is much closer to the Python for
loop:</p>

<pre><code class="language-c++">int ints[] = { 0, 1, 2, 3, 4 };
for( int x : ints ) {
   // use x
}
</code></pre>

<p>On top of the afore mentioned properties, and probably even more importantly,
this construct is much more expressive: it clearly says that you want to use
every element of the container.  C++ being what it is, of course, the syntax
gives you more control than in Python (at the expense of more complexity some
would argue): you can specify if you want a copy of each object in the container,
a reference to them, or a const reference to them.  Thus, all the following
declarations (iterating over the same range as the previous example) would be
valid:</p>

<pre><code class="language-c++">for( int x : lst ) { /* body */ }        // copy
for( int&amp; x : lst ) { /* body */ }       // reference
for( int const&amp; x : lst ) { /* body */ } // const reference
</code></pre>

<p>That is to say that in C++, you can express that you want to iterate over all
the items <em>and</em> whether you intend to modify them or not.</p>

<p>One condition to keep in mind is that in the constructs above, the loop variable
type (<code>int</code> in the example above) must be initializable from the type in the
container/array you want to iterate over.  This can lead to some errors:</p>

<pre><code class="language-c++">int ints[] = { 0, 1, 2, 3, 4 };
for( long x : ints ) {
   // OK, a long can be initialized from an int
}
for( long&amp; x : ints ) {
   // Won't compile: long&amp; can't be &quot;initialized from&quot;/&quot;bind to&quot; an int
}
</code></pre>

<p>That said, unless you really need to specify the type, it is usually recommended
that you use
<a href="http://en.cppreference.com/w/cpp/language/auto" target="_blank">C++11&rsquo;s auto specifier</a> to
get type deduction on the loop variable.  That would look like this:</p>

<pre><code class="language-c++">int ints[] = { 0, 1, 2, 3, 4 };
for( auto x : ints ) {
   // use x
}
</code></pre>

<p>which eschews the problems of type mismatch mentioned above.  Even with this
type deduction, the type decoration can be used so that all those syntaxes are
correct and should (usually) have the expected behavior:</p>

<pre><code class="language-c++">for( auto x : lst ) { /* body */ }        // copy
for( auto&amp; x : lst ) { /* body */ }       // reference
for( auto const&amp; x : lst ) { /* body */ } // const reference
</code></pre>

<p>which can have the advantage that if you change the type in the container, you do
not have to change the type in the loop.  There are some more caveats, especially
related to lifetime of temporary objects and accessibility, but the information
here is enough in most cases.  If you want more information on type deduction in
range-based for loops, see <a href="https://blog.petrzemek.net/2016/08/17/auto-type-deduction-in-range-based-for-loops/" target="_blank">this article</a>
by Petr Zemek.</p>

<p>One limitation of the C++ syntax compared to Python&rsquo;s is that there is no way to
limit the iteration to a sub-range of the container.  For this, you still need
to use the previous constructs.  C++11 made it easier to use these constructs
with <a href="http://en.cppreference.com/w/cpp/language/auto" target="_blank">auto type deduction</a>, but
allowing iteration over a portion of the container is still missed, if you ask
me, because if it were available, it would mean the same syntax could be used for
any iteration over a container.  In future versions of the standard, ranges
(which are a completely different concept from the function I am writing in what
follows&hellip; naming things is hard) or view/span types might provide a better
alternative, but for now nothing is provided in the standard to iterate over a
subrange.</p>

<h2 id="iterating-over-indices">Iterating over indices</h2>

<p>Containers (unfortunately or not, depending who you ask), are not the only thing
we need to loop over.  Iterating over indices can be necessary, and for that,
Python has an easy way of creating a temporary &ldquo;container&rdquo; that will represent a
range of integers.  Using this container, the same syntax that was used to iterate
over lists can easily be applied to index iteration:</p>

<pre><code class="language-python">a = [ 0, 1, 2, 3, 4 ]
for x in a:
   # use x

for x in range( 5 ):
   # use x
</code></pre>

<p>As mentioned, the <a href="https://docs.python.org/3/library/stdtypes.html?highlight=range#range" target="_blank"><code>range</code></a> object
created using this syntax will generate the sequence of integers for the loop.
This object can be initialized with a single <code>stop</code> value (as shown), but can
also be declared with a <code>start</code>/<code>stop</code> pair or a <code>start</code>/<code>stop</code>/<code>step</code> triplet.
It will go from <code>start</code> to <code>stop</code> (with <code>stop</code> being exclusive, i.e. the interval
is<code>[start, stop[</code>) in steps of <code>step</code>.  The default value of <code>start</code>
is zero and the default value of <code>step</code> is one, which is why you can use the
variations with a single parameter or a <code>start</code>/<code>stop</code> pair (which are not
strictly speaking overloads, since Python does not allow that).  The parameter
<code>step</code> can be negative.  The <code>start</code> value must be smaller than <code>stop</code> when
<code>step</code> is positive and greater than <code>stop</code> when <code>step</code> is negative.</p>

<pre><code class="language-python">range( 10 )          // iterates from 0 to 9
range( 8, 32 )       // iterates from 8 to 31
range( 10, 5, -2 )   // iterates from 10 to 5 in steps of 2
range( 10, 5, 2 )    // does nothing
</code></pre>

<p>In C++, neither the language nor its standard library provides such a facility.
Thus, to iterate over numbers, one falls back to the C style for loop:</p>

<pre><code class="language-c++">int ints[] = { 0, 1, 2, 3, 4 };
for( auto x : ints ) {
   // use x
}

for( int x{0}; x &lt; 5; ++x ) {
   // use x
}
</code></pre>

<p>This is not actually so bad, but I like the consistency and expressiveness of
Python&rsquo;s <code>range</code> object.  In the end, although those reasons might not be the
strongest arguments, they still drove me to think about (over-engineer maybe ;-) )
a construct similar to Python&rsquo;s range in C++.  Admittedly, I was also simply a
bit curious.  So, I set out to try and see if I could make a function or an
object which could work with the range-based for loop much like Python&rsquo;s <code>range</code>
object.</p>

<h2 id="the-initial-design-goals">The initial &ldquo;design goals&rdquo;</h2>

<p>Initially, I really wanted the behavior of Python&rsquo;s <code>range</code> object.  I did not
want to have to specify the type to iterate over (i.e. <code>short</code>, <code>int</code>, <code>long</code>,
<code>unsigned</code>&hellip;).  I wanted to be able to go in both directions, i.e. increment
or decrement the counter.  I wanted to be able to specify the step size.
Basically, I wanted to be able to write loops over indices like this:</p>

<pre><code class="language-c++">for( auto idx : range( 6 ) ) { /* body */ }
for( auto idx : range( 2, 7 ) ) { /* body */ }
for( auto idx : range( 38, 13, -3 ) ) { /* body */ }
</code></pre>

<p>I also wanted it to be as close to the raw C style loop efficiency as possible,
or the same even.  If there were a large performance penalty, this would probably
be a show stopper: C++&rsquo;s &ldquo;<em>zero-cost abstractions</em>&rdquo; mantra.  Actually, I would
argue that usually, in C++, even in non performance critical code, a cost in
performance has to be greatly outweighed by a gain in expressiveness for a
feature/proposal to even be considered, for better or worse.</p>

<p>So, with the following short list of goals:</p>

<ul>
<li>Python <code>range</code> behavior,

<ul>
<li><code>start</code> / <code>stop</code> / <code>step</code>,</li>
<li>increment/decrement,</li>
</ul></li>
<li>no explicit type specification,</li>
<li>no runtime overhead,</li>
</ul>

<p>I set out to build a function (or object) in C++.  In order to do that, I first
had to understand the range-based for loop<sup>[3]</sup>.</p>

<h2 id="writing-the-code">Writing the code</h2>

<h3 id="understanding-range-based-for">Understanding range-based for</h3>

<p>As defined by the C++17 standard in section&nbsp;<strong>9.5.4&nbsp;The range-based
for statement ([<em>stmt.ranged</em>])</strong>, there are three main components to the
range-based for construct:</p>

<ul>
<li>a range declaration,</li>
<li>a range initializer,</li>
<li>a loop statement.</li>
</ul>

<p>At its simplest, this is expressed like this:</p>

<pre><code class="language-c++">for( for_range_declaration : for_range_initializer ) {
   loop_statement
}
</code></pre>

<p>The <code>for_range_declaration</code> serves to create the variable that will be used in
the loop.  The <code>for_range_initializer</code> is what is executed to get the range (can
be as simple as what I would call &ldquo;identity&rdquo;, i.e. a range can directly be passed
in).  The <code>loop_statement</code> is essentially the body of the for loop as with any C
style for loop.  The code above will be used by the compiler to generate
something similar to the regular iterator loop shown in the
<a href="#iterating-over-containers" target="_blank">first section</a>.  The code looks like
this<sup>[4]</sup>:</p>

<pre><code class="language-c++">auto&amp;&amp; rng = for_range_initializer;
auto beg = begin( rng );
auto end = end( rng );
for( ; beg != end; beg++ ) {
   for_range_declaration = *beg;
   loop_statement
}
</code></pre>

<p>where the <code>begin</code> and <code>end</code> functions are not necessarily free functions, and
can be the equivalent member functions of most STL containers.  Actually, if
either a <code>begin</code> or an <code>end</code> member function are found in the range object, the
pair of member functions is preferred as specified in the standard.  This
unfortunately means that if an unrelated function exists in the class, but has
one of those names, the class cannot be used in the range-based for statement
even if an appropriate free functions pair is provided. This is true regardless
of the access specifier of the function (i.e. a private function with such a
name will still prevent the range-based for, even if a valid, non member pair of
<code>begin</code>/<code>end</code> functions exists).  I believe this might be changed in the future,
but for the C++11 to C++17 versions of the standard, range based for is defined
this way.</p>

<p>With the definition above in mind, the requirements to use a range-based for loop
can then be summarized as having two related types: first, a range like type that
has both a <code>begin</code> and an <code>end</code> function (either member, or discoverable through
ADL, i.e. in a related namespace) and second, an iterator like type which can be
compared for inequality, incremented and dereferenced, i.e. implements the
<code>operator!=</code>, <code>operator++</code>, and <code>operator*</code> functions.  The <code>begin</code> and <code>end</code>
functions of the range like type must return objects of the iterator type.  If
those criteria are met, then the range-based for loop construct is usable with
the range like type.  The requirements can be summed up in code like this:</p>

<pre><code class="language-c++">struct range_iterator {
   range_iterator operator++();
   bool operator!=( range_iterator const&amp; other );
   range_value_type operator*();
}

struct range {
   range_iterator begin();
   range_iterator end();
}
</code></pre>

<p>where <code>range_value_type</code> is the type of the data pointed to by the iterator and
contained in the range to iterate over.  Implementing those two types should be
enough and so that is what I set out to do.</p>

<h3 id="thinking-of-a-design">Thinking of a design</h3>

<p>I first looked at Anthony William&rsquo;s code to see how it could be done.  I suggest
you take a look at the code (<a href="https://www.justsoftwaresolutions.co.uk/files/numeric_range.cpp" target="_blank">download link</a>) to see the
approach he has taken.  I wanted to try and make my own implementation, taking a
different path. In my first attempt, I ended up having to write multiple versions
of some of the classes in order to customize the behavior for various types.
For instance, comparing floats with <code>operator==</code> is hardly ever what you want
(because of floating point errors), but doing so works perfectly with integral
types. Even with templates, I did not arrive at a customizable design that
satisfied me.  Having to repeat myself was not so bad, but I wanted to see if I
could avoid breaking the DRY principle.  As I said, a good dose of curiosity. :-)</p>

<p>So I needed to change the behavior depending on what type I iterate over.  There
are a few alternatives to achieve such behavior in C++.  I wanted an alternative
that would be compile time based with no runtime overhead.  I felt it was
necessary to get the efficiency I was aiming for.  This meant and abstract base
class with virtual functions was not in my solution set.  I decided to explore
solutions which allowed me to specify the behavior of the class: some kind of
&ldquo;functionality injection&rdquo;.  At first, I though of using <a href="http://en.cppreference.com/w/cpp/utility/functional/function" target="_blank">std::function</a> to
hold the &ldquo;pointers&rdquo; to the functions to call.  That way, I could specify what to
use for the three iterator operators when constructing them.  The downside of
this, from my perspective, is that this will introduce type erasure (and
possibly/usually accompanying heap allocations) and indirection, which, if I
understand properly, is harder or impossible to optimize for the compiler.  I
was worried this would not give me the performance I wanted.  In thinking and
searching for alternatives, I remembered <a href="https://www.fluentcpp.com/2017/05/23/strong-types-inheriting-functionalities-from
-underlying/" target="_blank">this</a> blog post on inheriting functionalities.  This made me think the
same technique applied in the blog post <a href="https://en.wikipedia.org/wiki/Curiously_recurring_template_pattern" target="_blank">CRTP</a> might be the
solution I was looking for (did I mention over-engineering?).</p>

<h3 id="writing-some-code">Writing some code</h3>

<p>Essentially, there are three functionalities that the iterator has to have and so
I created three new types that the iterator would inherit from to &ldquo;consume&rdquo; the
functionality.  Applying the CRTP pattern, I parametrized those new types so that
they would take the iterator class as a template parameter, and I made the
iterator class derive from those types.  The implementation ended up as follows:</p>

<pre><code class="language-c++">enum class Direction : uint_fast8_t {
   ascending,
   descending
};
constexpr auto Ascending = Direction::ascending;
constexpr auto Descending = Direction::descending;

template&lt; typename Iterator, typename Reference &gt;
struct Dereference
{
   auto operator*() -&gt; Reference {
      return static_cast&lt;Iterator&amp;&gt;(*this).cur_val_;
   }
};

template&lt; typename Iterator &gt;
struct Increment
{
   auto operator++() -&gt; Iterator&amp; {
      auto&amp; self = static_cast&lt;Iterator&amp;&gt;(*this);
      ( self.direction_ == Ascending ) ? ++(self.cur_val_): --(self.cur_val_);
      return static_cast&lt;Iterator&amp;&gt;(*this);
   }
};

template&lt; typename Iterator &gt;
struct EqualityComparisons
{
   bool operator==( Iterator const&amp; rhs ) const {
      return static_cast&lt;Iterator const&amp;&gt;(*this).cur_val_ == rhs.cur_val_;
   }
   bool operator!=( Iterator const&amp; rhs ) const {
      return !(*this == rhs);
   }
};


template&lt; typename T &gt;
struct range_iterator :
      Dereference&lt; range_iterator&lt;T&gt;, T&amp; &gt;,
      Increment&lt; range_iterator&lt;T&gt; &gt;,
      EqualityComparisons&lt; range_iterator&lt;T&gt; &gt;
{
   using value_type = T;
   using reference = T&amp;;
   using iterator_category = std::input_iterator_tag;
   using pointer = T*;
   using difference_type = void;

   range_iterator( T val, Direction dir ) :
                  direction_{ dir }, cur_val_{ val } {
   }
private:
   Direction direction_;
   T cur_val_;

   friend Dereference&lt; range_iterator&lt;T&gt;, T&amp; &gt;;
   friend Increment&lt; range_iterator&lt;T&gt; &gt;;
   friend EqualityComparisons&lt; range_iterator&lt;T&gt; &gt;;
};


template&lt; typename Iterator &gt;
struct Range
{
   private:
      using value_type = typename Iterator::value_type;
   public:
      Range( value_type start, value_type stop ) :
         direction_{ (start &lt; stop) ? Ascending : Descending },
                                          cur_val_{ start }, end_{ stop } {
      }
      auto begin() -&gt; Iterator {
         return Iterator{ cur_val_, direction_ };
      }
      auto end() -&gt; Iterator {
         return Iterator{ end_, direction_ };
      }

   private:
      Direction direction_;
      value_type cur_val_;
      value_type end_;
};
</code></pre>

<p>A few things worth mentioning.  I have had to make the &ldquo;operation&rdquo; classes friends
of the iterator class to give them access to the iterator private data.  If I
were designing something for the purpose of having client code specialize and
extend the behavior, this break in encapsulation might be more of a concern and
I might have to go for a different design, since the friend route seems to be the
<a href="https://stackoverflow.com/questions/8523762/crtp-with-protected-derived-member?rq=1" target="_blank">only viable alternative</a>
to give the base class access to the derived class data.  But for my current use,
it is not something I am worried with.  I also had to explicitly specify the
reference type in the <code>Dereference</code> operation.  This is because at the
instantiation time of the <code>Dereference</code> template in the inheritance list of the
<code>range_iterator</code>, the latter is still an incomplete type and so its <code>typedef</code>s
cannot be used.  Also, for brevity in this blog post, everything is in the global
namespace, which is not at all good practice, but in the actual code, I put
everything in a <code>estd</code> namespace (for <strong>e</strong>xtended <strong>std</strong>).  The indentation is
also slightly modified for the purpose of the blog post.</p>

<p>In any case, with this code (and the appropriate <code>#include</code>s, again omitted for
space), one can iterate over numbers using a range-based for loop like this:</p>

<pre><code class="language-c++">for( auto idx : Range&lt; range_iterator&lt;int&gt; &gt;( 0, 8 ) ) {
   // use idx
}

for( auto idx : Range&lt; range_iterator&lt;int&gt; &gt;( 7, -1 ) ) {
   // use idx
}
</code></pre>

<p>Verbose, shows implementation details, but a start.  This is the beginning of
the interface I set out to have.  It allows specifying <code>start</code> and <code>stop</code> (but
not the <code>step</code> yet).  It still requires an explicit type specification, which I
would like to get rid of.  It will detect whether you want to go in the
increasing of decreasing direction, so increment and decrement are covered.
Some might argue the detection is undesired behavior (Python&rsquo;s <code>range</code> will not
do this and a <code>step</code> of&nbsp;-1 must be explicitly specified to decrement).  It
is debatable I guess, but this is the interface I went with.</p>

<p>As it stands, in the code above, the implementation will accept floating point
types and character types.  This is not allowed by Python&rsquo;s <code>range</code> object
(although using the <a href="http://www.numpy.org/" target="_blank">Numpy</a> <a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.linspace.html" target="_blank"><code>linspace</code></a>
function, one can get a floating point range).  Unfortunately, the current
implementation of the comparison operator is defined in terms of the underlying
type&rsquo;s <code>operator==</code>.  As previously mentioned, comparing floats using this
operator is not ideal (and might actually never be true in some cases, which
would create an infinite loop).  This has been one of the first reasons I have
had for specializing in my earlier designs (which are not presented here), and
so I will explore it soon, but before I get to that, I will look at performance
to see if my design is good enough for me to pursue further.</p>

<h3 id="evaluating-the-performance-i">Evaluating the performance I</h3>

<p>Instead of benchmarking the code in the traditional sense of measuring execution
time (<a href="https://www.youtube.com/watch?v=zWxSZcpeS8Q" target="_blank">which is complicated</a>), I
decided to look at the assembly generated in Code Explorer (i.e. I godbolted my
code !) and see if there was any difference between this looping construct and a
traditional C style for loop.  My hypothesis is that if the same assembly is
generated, then the performance will be the same. I know that
<a href="https://channel9.msdn.com/events/Build/2013/4-329?term=The%20Elephant%20in%20the%20CPU" target="_blank">fewer instructions is not a guarantee of better performance</a>,
but I think it is safe to assume that if the assembly is the same, then the
performance will be the same.</p>


<figure>
    <a href="https://tinyurl.com/ycc42hkx" target="_blank">
        <img src="compiler_explorer.png" alt="https://tinyurl.com/ycc42hkx" />
    </a>
    
</figure>


<p>In the above figure, the leftmost editor/compiler pane pair illustrates the C
style for loop assembly.  The central pane shows the assembly for the version of
the range code as it is in the previous section, and, because compiler explorer
provides a version of the Boost libraries, the same loop using <code>boost::irange</code>
is displayed in the rightmost pane.  The assembly generated is exactly the same
even at a low optimization level (<code>O1</code>).  This means GCC is able to completely
see through the abstractions and produce the same output whether this range
construct or a hand coded C style for loop is used.  When I saw that, I though
it was excellent news, and decided to test with two other commonly used
compliers: Clang and MSVC<sup>[5]</sup>.</p>

<p>Using Clang, I first got disappointing results: a higher optimization level (<code>O2</code>)
was necessary to obtain the same result.  Thinking about why that was, I decided
to test if it was related to inlining.  Rewriting the code to use
<code>__attribute__((always_inline))</code> to suggest more aggressive inlining to the
compiler, I was able to get Clang to emit the same assembly as a hand written
loop at the lower level (<code>O1</code>).  Great.</p>

<p>I then tried with MSVC.  No matter the optimization level or the inlining hints
used, for this compiler, there seems to remain a small difference in the assembly
generated when using the <code>Range</code> code presented here compared to that generated
when using the C style for loop.  This is shown in the following figure:

<figure>
    
        <img src="msvc.png" />
    
    
</figure>
</p>

<p>The loops are structured differently. In the assembly of the hand written loop,
there is a single conditional jump instruction back to the beginning of the loop
if the loop exit condition is not met, but no other jump instruction.  When the
exit condition is met, the program simply continues with the next instruction,
thereby exiting the loop.  On the other hand, the assembly generated by the
<code>Range</code> construct contains two jumps: one back to the beginning of the loop when
the loop exit condition is not met, and one out of the loop when the condition is
met. The number of comparison instructions (<code>cmp</code>) is the same though and that
should be the most significant performance factor.  I imagine for a very short
loop (i.e. low number of iterations), the extra jump <em>could</em> be a significant
overhead, but for a long loop, I doubt it.  I guess actual profiling would be
needed.</p>

<p>Anyhow, at least in that first attempt, performance did not seem to be a big
issue (although compile times will go up if that is your metric).  This was
encouraging to me and motivated me to keep exploring this design.</p>

<h3 id="dealing-with-the-type-specification">Dealing with the type specification</h3>

<p>The next <a href="#the-initial-design-goals" target="_blank">design goal</a> I will be
talking about is the explicit type specification, or rather removing the need
for it. The <code>Range</code> object is a class template, and prior to C++17, there is no
<a href="http://en.cppreference.com/w/cpp/language/class_template_argument_deduction" target="_blank">template parameter argument deduction for class templates</a>.
This means using it directly as in the example above will not allow me to achieve
the &ldquo;no type specification&rdquo; goal that I set out for.  However, function templates
in C++ always did have <a href="http://en.cppreference.com/w/cpp/language/template_argument_deduction" target="_blank">template argument deduction</a> and so
they could provide a nicer interface.  Given that the range expression in the
range-based for loop does not need to be an object, but can be a function
returning an object, it is possible to use a set of function template overloads
instead of a <code>Range</code> directly.  With those, the types could be deduced.  Such
an overload set can be written as follows:</p>

<pre><code class="language-c++">template&lt; typename T &gt;
auto range( T start, T stop ) -&gt; Range&lt; range_iterator&lt;T&gt; &gt; {
   return Range&lt; range_iterator&lt;T&gt; &gt;{ start, stop };
}

template&lt; typename T &gt;
auto range( T stop ) -&gt; Range&lt; range_iterator&lt;T&gt; &gt; {
   return range( T{0}, stop );
}
</code></pre>

<p>which can be used without a type specification like this:</p>

<pre><code class="language-c++">for( auto i : range( 8 ) ) {
   // use i
}
</code></pre>

<p>which is now very close to the Python version:</p>

<pre><code class="language-python">for x in range( 8 ):
   # use i
</code></pre>

<p>I have tested this on compiler explorer and it produces the same executable as
the previous version.  So far so good.</p>

<h3 id="correctly-handling-floating-point-ranges">Correctly handling floating point ranges</h3>

<p>This was not part of the initial
<a href="#the-initial-design-goals" target="_blank">design goals</a>, but dealing with this
issue actually helps with the last remaining design goal, so I dealt with it.  In
the current version, the main problem with floating point ranges is the
comparison operator.  As it stands, the rest of the code would function properly,
but the comparison of <code>begin</code> and <code>end</code> is broken, since it might never yield
false and result in an infinite loop (which has happened in testing I should say!).
Said another way, <code>begin</code> might never compare equal to <code>end</code> with the current
definition of comparison.</p>

<p>Changing the definition of the <code>operator==</code> to the following unorthodox one would
give the proper behavior for floating points:</p>

<pre><code class="language-c++">bool operator==( Iterator const&amp; rhs ) const {
   return ( static_cast&lt;Iterator&amp;&gt;(*this).direction_ == Ascending ) ?
            ( static_cast&lt;Iterator&amp;&gt;(*this).cur_val_ &gt;= rhs.cur_val_ ) :
               ( static_cast&lt;Iterator&amp;&gt;(*this).cur_val_ &lt;= rhs.cur_val_ );
}
</code></pre>

<p>With this definition, for an ascending direction, two iterators are considered
equal if the value of the left hand side one is equal <em>or larger</em> than that of
the right hand side one.  In the range-based for loop, the right hand side
iterator in the comparison is always <code>end()</code>, so for those loops, the comparison
as defined above means any iterator with a value of end or more (ascending) are
considered equal.  Thus, as soon as the loop iterator&rsquo;s value reaches, or gets
past, that of the end iterator, both iterators are considered equal and the loop
stops.  This is the desired behavior for the loop, but it is an unusual
definition for the iterator <em>if</em> you think of the iterator as the value it holds.</p>

<p>Having an operator with an unusual meaning is generally considered bad practice,
and for good reasons.  With the previous definition, the result of comparing two
iterators can depend on the order of the parameters:</p>

<pre><code class="language-c++">range_iterator&lt;double&gt; a( 42.0, Ascending );
range_iterator&lt;double&gt; b( 48.5, Ascending );
assert( a == b );                    // will fire,     42.0 &gt;= 48.5 -&gt; false
assert( b == a );                    // will not fire, 48.5 &gt;= 42.0 -&gt; true
assert( ( a == b ) != ( b == a )  ); // will not fire, false != true
</code></pre>

<p>which is surprising.  Operators having unusual or inconsistent behavior can be
confusing (the <a href="https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md" target="_blank">C++ Core Guidelines</a>
discuss this in their overload section (C.over), more specifically subsections
C.160 and C.167).  The problem I am faced with here is that the range-based for
loop cannot be customized to use something other than <code>operator!=</code> to compare the
two iterators.  So whatever behavior I want my iterator to have, it must be in
the comparison operator.</p>

<p>That said, for the case at hand, these iterators are part of the implementation
of the <code>range</code> function, which is the only part of the library that is considered
public.  The only use of the comparison operator should therefore be the one in
the range-based for, where the only comparison is between the <code>begin</code> and <code>end</code>
iterator pair, which will have the correct behavior.  The iterators are not meant
to be used directly and I think the implementation is thus reasonable.  That is
debatable for sure, but in any case, in the actual implementation, the function
above is defined in the <code>EqualityComparisons</code> class and some template
metaprogramming ensures that it applies only to floating point types.</p>

<p>I should warn though that using floating points as a loop counter, either
manually or using the <code>range</code> functions here, is not as simple as it seems at
first: floating point maths and comparisons are hard and floating point error
will be present with the naive loop.  Since the construct proposed here aims
only at replacing the naive loop, nothing fancy is done to compensate floating
point errors in loops involving floating points, and so I thought a reminder was
in order.</p>

<h3 id="allowing-non-unit-steps">Allowing non unit steps</h3>

<p>The last goal in my initial list is the non unit step.  For now, I can select
<code>start</code> and <code>stop</code>, I allow increment and decrement, I do not need to specify the
type, and the performance penalty (with some optimizations enabled) is almost
null on the compilers I tested.  The final goal is to allow non unit steps.
In order to do that, I have to:</p>

<ol>
<li>store the <code>step</code> in the iterator;</li>
<li>adjust the <code>operator++</code> to advance of <code>step</code> units instead of 1;</li>
<li>adjust the <code>operator==</code> for integral types;</li>
<li>add an overload to the <code>range</code> function which takes 3 arguments.</li>
</ol>

<p>The third item was the easiest to deal with.  The change became necessary, since
if the step size is not an <em>exact</em> divisor of the distance between <code>start</code> and
<code>stop</code>, the original definition of <code>operator==</code> will never stop the loop, because
the loop iterator value will never be exactly the end iterator value, even
for integral types.  It turns out that using the same definition of the equality
operator as was used to deal with floating point iterators, the problem is solved.
Now, when the value of the loop iterator is above the end iterator value, the
loop stops, as desired.</p>

<p>Going back to the first item, the decision I made was to add a template parameter
to the <code>range_iterator</code> class which will be of a new enum type <code>Length</code> which
tells me whether the <code>range_iterator</code> will have unit length steps or any other
length.  Then, I create a specialization for the case where the length is unit
and one for when the length is other.</p>

<pre><code class="language-c++">enum class Length : uint_fast8_t {
   unit,
   other
};

constexpr auto Unit = Length::unit;
constexpr auto Other = Length::other;

template&lt; typename T, Length length &gt;
struct range_iterator;

template&lt; typename T &gt;
struct range_iterator&lt; T, Unit &gt; :
         Dereference&lt; range_iterator&lt;T&gt;, T&amp; &gt;,
         Increment&lt; range_iterator&lt;T&gt; &gt;,
         EqualityComparisons&lt; range_iterator&lt;T&gt; &gt;
{
   /* implementation here for Unit length */
private:
   Direction direction_;
   T cur_val_;
}


template&lt; typename T &gt;
struct range_iterator&lt; T, Other &gt; :
         Dereference&lt; range_iterator&lt;T&gt;, T&amp; &gt;,
         Increment&lt; range_iterator&lt;T&gt; &gt;,
         EqualityComparisons&lt; range_iterator&lt;T&gt; &gt;
{
   /* implementation here for Other length */
private:
   Direction direction_;
   T cur_val_;
   T step_;
}

</code></pre>

<p>In the case where the length is not one, the <code>step</code> is kept as a data member and
available to the operators.</p>

<p>Changing the <code>operator++</code> was not much more complicated than the change to the
comparison operator.  The <code>Increment</code> type is now templated on the length, and,
using SFINAE, a different implementation of the <code>operator++</code> is used depending on
whether the <code>length</code> argument is <code>Unit</code> or <code>Other</code>.</p>

<pre><code class="language-c++">auto operator++() -&gt; Iterator&lt; T, length &gt; {
   static_cast&lt;Iterator&lt; T, length &gt;&amp;&gt;(*this).cur_val_ +=
                           static_cast&lt;Iterator&lt; T, length &gt;&amp;&gt;(*this).step_;
}
</code></pre>

<p>The only remaining task is to add an overload of the <code>range</code> function.  This
overload will take one more parameter (the <code>step</code>) and return a range parametrized
with a different iterator type.</p>

<pre><code class="language-c++">template&lt; typename T, typename U &gt;
auto range( T start, T stop, U step ) -&gt; detail::range&lt; T &gt; {
   return detail::range&lt; T &gt;{ start, stop, step };
}
</code></pre>

<p>It should be noted that the <code>start</code>/<code>stop</code> and the <code>step</code> parameters can have
different types.  This is necessary for someone to be able to call the function
like this:</p>

<pre><code class="language-c++">for( auto i : range( 13u, 0u, -3 ) ) {}
</code></pre>

<p>If all three parameters were of the same type, then the user would have to
manually convert one way or the other, which is not a nice interface.  What is
done in the implementation is a cast inside the constructor of the <code>Range</code> object
to the iterator type.  Unfortunately, this opens the door to quite a few
conversion problems.  If you go from signed to unsigned, the behavior is correct
and portable.  If you go from unsigned to signed, the behavior is implementation
defined, but should mostly work.</p>

<p>Anyhow, with all of this in place, all my goals are achieved!</p>

<h2 id="mixed-types-logic-checking">Mixed types, logic checking&hellip;</h2>

<p>As I said, the code above is close to the one I ended up with, but not exactly
the same.  You can go on <a href="https://github.com/ghlecl/range_fn" target="_blank">Github</a> to find my
range function implementation.  There are more things one could do with it (or
do differently).</p>

<p>One thing that could be done is allow for mixed types to be used for specifying
the bounds and not only the step (see previous section).  That is actually what
prompted my two previous posts about
<a href="https://ghlecl.github.io/posts/integer_representations/" target="_blank">integer representations</a> and
<a href="https://ghlecl.github.io/posts/usual_conversions/" target="_blank">usual conversions in arithmetic</a>.  I am not
illustrating the code here, since it would make this already long post even
longer, but it can be done.  It does bring up some interesting questions though
such as which type to return when two types are used.  I am still uncertain what
a good answer is.  As far as I can tell, Boost range has decided to simply not
allow that.  This is not unreasonable.  That said, the use case I see for
allowing mixed types bounds specification is the following:</p>

<pre><code class="language-c++">std::vector&lt; int &gt; v{ 0, 2, 4, 6, 8, 10, 12 };
for( auto idx : range( 3, v.size() ) ) {
   // do something with the items 3 to size of vector v
}
</code></pre>

<p>Since the standard library has made the choice of having <code>size</code> of containers be
unsigned, without mixed bound types, this would not work without asking the user
to write <code>3u</code> as the first index or cast the <code>.size()</code> call result.</p>

<p>Another thing, you will see in the code is some consistency checks.  For instance,
if <code>start</code> &gt; <code>stop</code> while <code>step</code> &gt; 0, there is likely a problem (unless you
allow overflowing loops, which could be done).</p>

<p>There are some parts of the code which, with hindsight, seem superfluous.  For
instance, there is no difference in the dereferencing behavior in any of the code
here, so it would be simpler to leave it in the <code>range_iterator</code> implementation.
It would not be DRY (repeated in two classes), but the complexity introduced
might not be worth it.  As with any code, I think it can be <del>bikeshedded</del>
debated forever.&nbsp;&nbsp;:-)</p>

<p>Anyhow, I hope you have enjoyed reading this post.  Writing it certainly made me
clarify the concepts involved in range-based for loops in C++ and yielded a
construct I can use to loop over indices with a nice pythonish syntax.  It is
what I initially wanted, so for me at least, mission accomplished!</p>

<hr />

<h2 id="acknowledments">Acknowledments</h2>

<p>I would like to thank <a href="https://www.twitter.com/Gab_AL_" target="_blank">Gabriel Aubut-Lussier</a>
for taking the time to read this post before I published it and making
constructive comments on the content.  The writing is better for it.</p>

<h2 id="notes">Notes</h2>

<p><sup>[1]</sup> The work here will probably be made completely useless by the
<a href="http://open-std.org/JTC1/SC22/WG21/docs/papers/2017/n4685.pdf" target="_blank">range proposal</a>
when it gets in the standard.  On top of that, such a function already exists in
<a href="https://www.boost.org/doc/libs/1_67_0/libs/range/doc/html/range/reference/ranges/irange.html" target="_blank">Boost</a>.
The links were valid at the time of writing.  The link to the range proposal is
actually to a draft version of the proposal, which might differ from what actually
ends up in the standard.</p>

<p><sup>[2]</sup> Link pointed to most recent release on the date of writing.
Might not work on future dates.</p>

<p><sup>[3]</sup> At first, like most I would think, I actually first asked a search
engine and that is how I found <a href="https://www.justsoftwaresolutions.co.uk/cplusplus/generating_sequences.html" target="_blank">Anthony&rsquo;s post</a>
on the subject.  This was a great starting point.</p>

<p><sup>[4]</sup> Adapted from the C++17 standard draft.</p>

<p><sup>[5]</sup> In the course of writing this article, I realized that a version
of the Intel compiler was also available on Compiler Explorer and thus decided
to look at the assembly generated with this compiler.  It turns out it takes
optimization level 3 for the code to give the same result as the hand-coded loop
with this compiler.  Depending on whether or not you can use this optimization
level, the performance of the <code>Range</code> presented here might not be very good with
this compiler.</p>

      </p>
    </article>


  </main>

<footer>
  <div class="footer_text">
      <div>
        <h3>Hi, <a href="https://ghlecl.github.io/about">I'm Ghyslain</a></h3>
        <p>
          I am a medical physicist by day and a hobby programmer by night.


You can follow me on <a href="http://twitter.com/ghlecl" target="_blank">Twitter</a> and on <a href="http://github.com/ghlecl" target="_blank">GitHub</a>.  You can reach me via codeattempts [at] gmail [dot] com.

        </p>
      </div>
      
  </div>

  
    <div class="footer_copyright">
      &copy; 2018 <a href="https://ghlecl.github.io/about">Ghyslain Leclerc</a>
       - Made in Québec, Canada
    </div>
  
</footer>

    <script type="text/javascript" src="https://cdn.jsdelivr.net/jquery/2.2.0/jquery.min.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/lightgallery/1.2.14/js/lightgallery-all.min.js" charset="utf-8"></script>
    <script src="https://ghlecl.github.io/js/weblog.js" charset="utf-8"></script>
    
<script src="https://ghlecl.github.io/js/prism.js"></script>

    <script type="text/javascript">

  
  $(function() {
    
    $.getJSON("https://api.flickr.com/services/feeds/photos_public.gne?id=&format=json&jsoncallback=?", function(data) {
      iweblog.application.displayImages(data, 8);
    });
  });

</script>

    
  </body>
</html>

