<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="author" content="Ghyslain Leclerc">
  <meta name="description" content="Personnal notes on code">
  <link rel="alternate" type="application/atom+xml" title="RSS" href="https://ghlecl.github.io/atom.xml">
  <link rel="stylesheet" href="https://ghlecl.github.io/css/weblog.css" media="screen" charset="utf-8" />
  <title>Python&#x27;s range in C++ &middot; ghlecl's code attempts</title>
</head>

<body class="site">
  <header>
    <nav>
      <h1><a href="/">@ghlecl</a>'s Code Attempts.</h1>
      <div class="menu">
        <ul>
          <li>
            <a href="https://ghlecl.github.io/posts/">Posts<img src="/img/atom.svg" class="rss-icon" /></a>
          </li>
          <li><a href="https://ghlecl.github.io/about/">About</a></li>
        </ul>
      </div>
    </nav>
  </header>
  
  <main class="content">
    <article class="post">
      <h1 class="title">Python&#x27;s range in C++</h1>
      <div class="postmeta">
        Posted on <time datetime="2018-08-05 00:00" pubdate="">2018-08-05</time>
      </div>
      <h1 id="Exploring_loops:_Python's_range_in_C++">Exploring loops: Python's range in C++</h1>
<p>In spite of what Sean Parent would like (i.e. <a href="https://channel9.msdn.com/Events/GoingNative/2013/Cpp-Seasoning">no raw loops</a> ;-) ), loops are a common control flow in programming.
So common that most languages have more than one <a href="https://en.wikipedia.org/wiki/Control_flow#Loops">loop</a> syntax:
<a href="https://en.wikipedia.org/wiki/For_loop">for loop</a>,
<a href="https://en.wikipedia.org/wiki/While_loop">while loop</a>,
<a href="https://en.wikipedia.org/wiki/Do_while_loop">do while loop</a>...
Given their prevalence, loops might seem uninteresting, but when I decided to look into
creating a <code>range</code> function<sup id="ftntref:1"><a href="#ftnt:1">1</a></sup> for C++ which would behave like Python's
<code>range</code> object, I learned a thing or two and decided to write them down.</p>
<p>For the impatient, the code I came up with is available on <a href="https://github.com/ghlecl/range_fn">Github</a>.  It was inspired by [Anthony William's post](https://www.justsoftwaresolutions.co.uk/cplusplus/
generating_sequences.html) on the subject.
I will put the same disclaimer here that Anthony put in his post:</p>
<blockquote>
<p>...hopefully people will find this instructive, if not useful.</p>
</blockquote>
<p>As he points out, there are more complete alternatives (e.g. the <a href="https://www.boost.org/doc/libs/1_67_0/libs/range/doc/html/index.html">Boost range library</a>) with a probably higher quality of implementation (at the price of bringing the whole of Boost into your project if you do not already depend on it).<sup id="ftntref:2"><a href="#ftnt:2">2</a></sup></p>
<p>This turned out to be quite a longer blog entry than I anticipated.  Consider yourself warned!</p>
<h2 id="Iterating_over_containers">Iterating over containers</h2>
<p>Out of the C++11 (and beyond) features, <a href="http://en.cppreference.com/w/cpp/language/range-for">range-based for loop</a> is a favorite of mine.
Prior to that being available, if you wanted to iterate over every element of a container, the alternatives were rather verbose.
Amongst others, there is the C style for loop using the <a href="http://en.cppreference.com/w/cpp/iterator">iterators</a> that can be retrieved by the <code>begin()</code> and <code>end()</code> functions of the STL
containers:</p>
<pre data-lang="c++" style="background-color:#1d1f21;color:#c5c8c6;" class="language-c++ "><code class="language-c++" data-lang="c++"><span>std::list&lt;</span><span style="color:#b294bb;">double</span><span>&gt; lst;  </span><span style="color:#969896;">// ... fill list somehow ...
</span><span>
</span><span style="color:#b294bb;">typedef</span><span> std::list&lt;</span><span style="color:#b294bb;">double</span><span>&gt;::iterator lst_iter;
</span><span style="color:#b294bb;">for</span><span>( lst_iter beg </span><span style="color:#8abeb7;">=</span><span> lst.</span><span style="color:#cc6666;">begin</span><span>(), end </span><span style="color:#8abeb7;">=</span><span> lst.</span><span style="color:#cc6666;">end</span><span>(); beg </span><span style="color:#8abeb7;">!=</span><span> end; </span><span style="color:#8abeb7;">++</span><span>beg ) {
</span><span>   </span><span style="color:#b294bb;">double</span><span> cur </span><span style="color:#8abeb7;">= *</span><span>beg;
</span><span>   </span><span style="color:#969896;">// use cur (or use *beg directly everywhere)
</span><span>}
</span></code></pre>
<p>or the <a href="http://en.cppreference.com/w/cpp/algorithm/for_each"><code>for_each</code></a> algorithm to which one provides a function object to apply to every element of the container:</p>
<pre data-lang="c++" style="background-color:#1d1f21;color:#c5c8c6;" class="language-c++ "><code class="language-c++" data-lang="c++"><span>std::list&lt;</span><span style="color:#b294bb;">double</span><span>&gt; lst;  </span><span style="color:#969896;">// ... fill list somehow ...
</span><span>
</span><span style="color:#b294bb;">struct </span><span>my_op {
</span><span>   </span><span style="color:#b294bb;">void </span><span style="color:#81a2be;">operator()</span><span>( </span><span style="color:#b294bb;">double </span><span style="color:#de935f;">item </span><span>) {
</span><span>      </span><span style="color:#969896;">// use item
</span><span>   }
</span><span>};
</span><span>std::</span><span style="color:#81a2be;">for_each</span><span>( lst.</span><span style="color:#cc6666;">begin</span><span>(), lst.</span><span style="color:#cc6666;">end</span><span>(), </span><span style="color:#cc6666;">my_op</span><span style="color:#81a2be;">() </span><span>);
</span></code></pre>
<p>Those work, but they have a few drawbacks, amongst which you can find 1) being verbose <del>and 2) not working with built-in arrays</del><sup id="ftntref:3"><a href="#ftnt:3">3</a></sup>.
Compare that to other languages where the syntax for iterating over a container is more concise and more universally applied, like Python for instance:</p>
<pre data-lang="python" style="background-color:#1d1f21;color:#c5c8c6;" class="language-python "><code class="language-python" data-lang="python"><span>a </span><span style="color:#8abeb7;">= </span><span>[ </span><span style="color:#de935f;">0</span><span>, </span><span style="color:#de935f;">1</span><span>, </span><span style="color:#de935f;">2</span><span>, </span><span style="color:#de935f;">3</span><span>, </span><span style="color:#de935f;">4 </span><span>]
</span><span style="color:#b294bb;">for </span><span>x </span><span style="color:#b294bb;">in </span><span>a:
</span><span>   </span><span style="color:#969896;">#use x
</span></code></pre>
<p>and you can see a difference, at a minimum in verbosity.
With range-based for loops, C++ closes the gap.
The syntax, introduced in C++11, is terser and works with both containers and built-in arrays (which is what I show in the example below).
Here is what it looks like, which is much closer to the Python for loop:</p>
<pre data-lang="c++" style="background-color:#1d1f21;color:#c5c8c6;" class="language-c++ "><code class="language-c++" data-lang="c++"><span style="color:#b294bb;">int</span><span> ints[] </span><span style="color:#8abeb7;">= </span><span>{ </span><span style="color:#de935f;">0</span><span>, </span><span style="color:#de935f;">1</span><span>, </span><span style="color:#de935f;">2</span><span>, </span><span style="color:#de935f;">3</span><span>, </span><span style="color:#de935f;">4 </span><span>};
</span><span style="color:#b294bb;">for</span><span>( </span><span style="color:#b294bb;">int</span><span> x </span><span style="color:#8abeb7;">:</span><span> ints ) {
</span><span>   </span><span style="color:#969896;">// use x
</span><span>}
</span></code></pre>
<p>On top of the afore mentioned properties, and probably even more importantly, this construct is much more expressive: it clearly says that you want to use every element of the container.
C++ being what it is, of course, the syntax gives you more control than in Python (at the expense of more complexity some would argue): you can specify if you want a copy of each object in the container, a reference to them, or a const reference to them.
Thus, all the following declarations (iterating over the same range as the previous example) would be valid:</p>
<pre data-lang="c++" style="background-color:#1d1f21;color:#c5c8c6;" class="language-c++ "><code class="language-c++" data-lang="c++"><span style="color:#b294bb;">for</span><span>( </span><span style="color:#b294bb;">int</span><span> x </span><span style="color:#8abeb7;">:</span><span> lst ) { </span><span style="color:#969896;">/* body */ </span><span>}        </span><span style="color:#969896;">// copy
</span><span style="color:#b294bb;">for</span><span>( </span><span style="color:#b294bb;">int</span><span style="color:#8abeb7;">&amp;</span><span> x </span><span style="color:#8abeb7;">:</span><span> lst ) { </span><span style="color:#969896;">/* body */ </span><span>}       </span><span style="color:#969896;">// reference
</span><span style="color:#b294bb;">for</span><span>( </span><span style="color:#b294bb;">int const</span><span style="color:#8abeb7;">&amp;</span><span> x </span><span style="color:#8abeb7;">:</span><span> lst ) { </span><span style="color:#969896;">/* body */ </span><span>} </span><span style="color:#969896;">// const reference
</span></code></pre>
<p>That is to say that in C++, you can express that you want to iterate over all the items <em>and</em> whether you intend to modify them or not.</p>
<p>One condition to keep in mind is that in the constructs above, the loop variable type (<code>int</code> in the example above) must be initializable from the type in the container/array you want to iterate over.
This can lead to some errors:</p>
<pre data-lang="c++" style="background-color:#1d1f21;color:#c5c8c6;" class="language-c++ "><code class="language-c++" data-lang="c++"><span style="color:#b294bb;">int</span><span> ints[] </span><span style="color:#8abeb7;">= </span><span>{ </span><span style="color:#de935f;">0</span><span>, </span><span style="color:#de935f;">1</span><span>, </span><span style="color:#de935f;">2</span><span>, </span><span style="color:#de935f;">3</span><span>, </span><span style="color:#de935f;">4 </span><span>};
</span><span style="color:#b294bb;">for</span><span>( </span><span style="color:#b294bb;">long</span><span> x </span><span style="color:#8abeb7;">:</span><span> ints ) {
</span><span>   </span><span style="color:#969896;">// OK, a long can be initialized from an int
</span><span>}
</span><span style="color:#b294bb;">for</span><span>( </span><span style="color:#b294bb;">long</span><span style="color:#8abeb7;">&amp;</span><span> x </span><span style="color:#8abeb7;">:</span><span> ints ) {
</span><span>   </span><span style="color:#969896;">// Won&#39;t compile: long&amp; can&#39;t be &quot;initialized from&quot;/&quot;bind to&quot; an int
</span><span>}
</span></code></pre>
<p>That said, unless you really need to specify the type, it is usually recommended
that you use <a href="http://en.cppreference.com/w/cpp/language/auto">C++11's auto specifier</a> to
get type deduction on the loop variable.
That would look like this:</p>
<pre data-lang="c++" style="background-color:#1d1f21;color:#c5c8c6;" class="language-c++ "><code class="language-c++" data-lang="c++"><span style="color:#b294bb;">int</span><span> ints[] </span><span style="color:#8abeb7;">= </span><span>{ </span><span style="color:#de935f;">0</span><span>, </span><span style="color:#de935f;">1</span><span>, </span><span style="color:#de935f;">2</span><span>, </span><span style="color:#de935f;">3</span><span>, </span><span style="color:#de935f;">4 </span><span>};
</span><span style="color:#b294bb;">for</span><span>( </span><span style="color:#b294bb;">auto</span><span> x </span><span style="color:#8abeb7;">:</span><span> ints ) {
</span><span>   </span><span style="color:#969896;">// use x
</span><span>}
</span></code></pre>
<p>which eschews the problems of type mismatch mentioned above.
Even with this type deduction, the type decoration can be used so that all those syntaxes are
correct and should (usually) have the expected behavior:</p>
<pre data-lang="c++" style="background-color:#1d1f21;color:#c5c8c6;" class="language-c++ "><code class="language-c++" data-lang="c++"><span style="color:#b294bb;">for</span><span>( </span><span style="color:#b294bb;">auto</span><span> x </span><span style="color:#8abeb7;">:</span><span> lst ) { </span><span style="color:#969896;">/* body */ </span><span>}        </span><span style="color:#969896;">// copy
</span><span style="color:#b294bb;">for</span><span>( </span><span style="color:#b294bb;">auto</span><span style="color:#8abeb7;">&amp;</span><span> x </span><span style="color:#8abeb7;">:</span><span> lst ) { </span><span style="color:#969896;">/* body */ </span><span>}       </span><span style="color:#969896;">// reference
</span><span style="color:#b294bb;">for</span><span>( </span><span style="color:#b294bb;">auto const</span><span style="color:#8abeb7;">&amp;</span><span> x </span><span style="color:#8abeb7;">:</span><span> lst ) { </span><span style="color:#969896;">/* body */ </span><span>} </span><span style="color:#969896;">// const reference
</span></code></pre>
<p>which can have the advantage that if you change the type in the container, you do
not have to change the type in the loop.
There are some more caveats, especially related to lifetime of temporary objects and accessibility, but the information here is enough in most cases.
If you want more information on type deduction in range-based for loops, see <a href="https://blog.petrzemek.net/2016/08/17/auto-type-deduction-in-range-based-for-loops/">this article</a>
by Petr Zemek.</p>
<p>One limitation of the C++ syntax compared to Python's is that there is no way to limit the iteration to a sub-range of the container.
For this, you still need to use the previous constructs.
C++11 made it easier to use these constructs with <a href="http://en.cppreference.com/w/cpp/language/auto">auto type deduction</a>, but allowing iteration over a portion of the container is still missed, if you ask me, because if it were available, it would mean the same syntax could be used for any iteration over a container.
In future versions of the standard, ranges (which are a completely different concept from the function I am writing in what follows... naming things is hard) or view/span types might provide a better alternative, but for now nothing is provided in the standard to iterate over a subrange.</p>
<h2 id="Iterating_over_indices">Iterating over indices</h2>
<p>Containers (unfortunately or not, depending who you ask), are not the only thing we need to loop over.
Iterating over indices can be necessary, and for that, Python has an easy way of creating a temporary &quot;container&quot; that will represent a range of integers.
Using this container, the same syntax that was used to iterate over lists can easily be applied to index iteration:</p>
<pre data-lang="python" style="background-color:#1d1f21;color:#c5c8c6;" class="language-python "><code class="language-python" data-lang="python"><span>a </span><span style="color:#8abeb7;">= </span><span>[ </span><span style="color:#de935f;">0</span><span>, </span><span style="color:#de935f;">1</span><span>, </span><span style="color:#de935f;">2</span><span>, </span><span style="color:#de935f;">3</span><span>, </span><span style="color:#de935f;">4 </span><span>]
</span><span style="color:#b294bb;">for </span><span>x </span><span style="color:#b294bb;">in </span><span>a:
</span><span>   </span><span style="color:#969896;"># use x
</span><span>
</span><span style="color:#b294bb;">for </span><span>x </span><span style="color:#b294bb;">in </span><span style="color:#81a2be;">range( </span><span style="color:#de935f;">5 </span><span style="color:#81a2be;">)</span><span>:
</span><span>   </span><span style="color:#969896;"># use x
</span></code></pre>
<p>As mentioned, the <a href="https://docs.python.org/3/library/stdtypes.html?highlight=range#range"><code>range</code></a> object created using this syntax will generate the sequence of integers for the loop.
This object can be initialized with a single <code>stop</code> value (as shown), but can also be declared with a <code>start</code>/<code>stop</code> pair or a <code>start</code>/<code>stop</code>/<code>step</code> triplet.
It will go from <code>start</code> to <code>stop</code> (with <code>stop</code> being exclusive, i.e. the interval is<code>[start, stop[</code>) in steps of <code>step</code>.  The default value of <code>start</code> is zero and the default value of <code>step</code> is one, which is why you can use the  variations with a single parameter or a <code>start</code>/<code>stop</code> pair (which are not strictly speaking overloads, since Python does not allow that).
The parameter <code>step</code> can be negative.
The <code>start</code> value must be smaller than <code>stop</code> when <code>step</code> is positive and greater than <code>stop</code> when <code>step</code> is negative.</p>
<pre data-lang="python" style="background-color:#1d1f21;color:#c5c8c6;" class="language-python "><code class="language-python" data-lang="python"><span style="color:#81a2be;">range( </span><span style="color:#de935f;">10 </span><span style="color:#81a2be;">)          </span><span style="color:#8abeb7;">// </span><span>iterates </span><span style="color:#b294bb;">from </span><span style="color:#de935f;">0 </span><span>to </span><span style="color:#de935f;">9
</span><span style="color:#81a2be;">range( </span><span style="color:#de935f;">8</span><span style="color:#81a2be;">, </span><span style="color:#de935f;">32 </span><span style="color:#81a2be;">)       </span><span style="color:#8abeb7;">// </span><span>iterates </span><span style="color:#b294bb;">from </span><span style="color:#de935f;">8 </span><span>to </span><span style="color:#de935f;">31
</span><span style="color:#81a2be;">range( </span><span style="color:#de935f;">10</span><span style="color:#81a2be;">, </span><span style="color:#de935f;">5</span><span style="color:#81a2be;">, </span><span style="color:#8abeb7;">-</span><span style="color:#de935f;">2 </span><span style="color:#81a2be;">)   </span><span style="color:#8abeb7;">// </span><span>iterates </span><span style="color:#b294bb;">from </span><span style="color:#de935f;">10 </span><span>to </span><span style="color:#de935f;">5 </span><span style="color:#8abeb7;">in </span><span>steps of </span><span style="color:#de935f;">2
</span><span style="color:#81a2be;">range( </span><span style="color:#de935f;">10</span><span style="color:#81a2be;">, </span><span style="color:#de935f;">5</span><span style="color:#81a2be;">, </span><span style="color:#de935f;">2 </span><span style="color:#81a2be;">)    </span><span style="color:#8abeb7;">// </span><span>does nothing
</span></code></pre>
<p>In C++, neither the language nor its standard library provides such a facility.
Thus, to iterate over numbers, one falls back to the C style for loop:</p>
<pre data-lang="c++" style="background-color:#1d1f21;color:#c5c8c6;" class="language-c++ "><code class="language-c++" data-lang="c++"><span style="color:#b294bb;">int</span><span> ints[] </span><span style="color:#8abeb7;">= </span><span>{ </span><span style="color:#de935f;">0</span><span>, </span><span style="color:#de935f;">1</span><span>, </span><span style="color:#de935f;">2</span><span>, </span><span style="color:#de935f;">3</span><span>, </span><span style="color:#de935f;">4 </span><span>};
</span><span style="color:#b294bb;">for</span><span>( </span><span style="color:#b294bb;">auto</span><span> x </span><span style="color:#8abeb7;">:</span><span> ints ) {
</span><span>   </span><span style="color:#969896;">// use x
</span><span>}
</span><span>
</span><span style="color:#b294bb;">for</span><span>( </span><span style="color:#b294bb;">int </span><span style="color:#cc6666;">x</span><span style="color:#81a2be;">{</span><span style="color:#de935f;">0</span><span style="color:#81a2be;">}</span><span>; x </span><span style="color:#8abeb7;">&lt; </span><span style="color:#de935f;">5</span><span>; </span><span style="color:#8abeb7;">++</span><span>x ) {
</span><span>   </span><span style="color:#969896;">// use x
</span><span>}
</span></code></pre>
<p>This is not actually so bad, but I like the consistency and expressiveness of Python's <code>range</code> object.
In the end, although those reasons might not be the strongest arguments, they still drove me to think about (over-engineer maybe ;-) ) a construct similar to Python's range in C++.
Admittedly, I was also simply a bit curious.
So, I set out to try and see if I could make a function or an object which could work with the range-based for loop much like Python's <code>range</code> object.</p>
<h2 id="The_initial_"design_goals"">The initial &quot;design goals&quot;</h2>
<p>Initially, I really wanted the behavior of Python's <code>range</code> object.
I did not want to have to specify the type to iterate over (i.e. <code>short</code>, <code>int</code>, <code>long</code>,
<code>unsigned</code>...).
I wanted to be able to go in both directions, i.e. increment or decrement the counter.
I wanted to be able to specify the step size.
Basically, I wanted to be able to write loops over indices like this:</p>
<pre data-lang="c++" style="background-color:#1d1f21;color:#c5c8c6;" class="language-c++ "><code class="language-c++" data-lang="c++"><span style="color:#b294bb;">for</span><span>( </span><span style="color:#b294bb;">auto</span><span> idx </span><span style="color:#8abeb7;">: </span><span style="color:#cc6666;">range</span><span style="color:#81a2be;">( </span><span style="color:#de935f;">6 </span><span style="color:#81a2be;">) </span><span>) { </span><span style="color:#969896;">/* body */ </span><span>}
</span><span style="color:#b294bb;">for</span><span>( </span><span style="color:#b294bb;">auto</span><span> idx </span><span style="color:#8abeb7;">: </span><span style="color:#cc6666;">range</span><span style="color:#81a2be;">( </span><span style="color:#de935f;">2</span><span style="color:#81a2be;">, </span><span style="color:#de935f;">7 </span><span style="color:#81a2be;">) </span><span>) { </span><span style="color:#969896;">/* body */ </span><span>}
</span><span style="color:#b294bb;">for</span><span>( </span><span style="color:#b294bb;">auto</span><span> idx </span><span style="color:#8abeb7;">: </span><span style="color:#cc6666;">range</span><span style="color:#81a2be;">( </span><span style="color:#de935f;">38</span><span style="color:#81a2be;">, </span><span style="color:#de935f;">13</span><span style="color:#81a2be;">, </span><span style="color:#8abeb7;">-</span><span style="color:#de935f;">3 </span><span style="color:#81a2be;">) </span><span>) { </span><span style="color:#969896;">/* body */ </span><span>}
</span></code></pre>
<p>I also wanted it to be as close to the raw C style loop efficiency as possible, or the same even.
If there were a large performance penalty, this would probably be a show stopper: C++'s &quot;<em>zero-cost abstractions</em>&quot; mantra.
Actually, I would argue that usually, in C++, even in non performance critical code, a cost in performance has to be greatly outweighed by a gain in expressiveness for a feature/proposal to even be considered, for better or worse.</p>
<p>So, with the following short list of goals:</p>
<ul>
<li>Python <code>range</code> behavior,
<ul>
<li><code>start</code> / <code>stop</code> / <code>step</code>,</li>
<li>increment/decrement,</li>
</ul>
</li>
<li>no explicit type specification,</li>
<li>no runtime overhead,</li>
</ul>
<p>I set out to build a function (or object) in C++.
In order to do that, I first had to understand the range-based for loop<sup id="ftntref:4"><a href="#ftnt:4">4</a></sup>.</p>
<h2 id="Writing_the_code">Writing the code</h2>
<h3 id="Understanding_range-based_for">Understanding range-based for</h3>
<p>As defined by the C++17 standard in section <strong>9.5.4 The range-based for statement ([<em>stmt.ranged</em>])</strong>, there are three main components to the range-based for construct:</p>
<ul>
<li>a range declaration,</li>
<li>a range initializer,</li>
<li>a loop statement.</li>
</ul>
<p>At its simplest, this is expressed like this:</p>
<pre data-lang="c++" style="background-color:#1d1f21;color:#c5c8c6;" class="language-c++ "><code class="language-c++" data-lang="c++"><span style="color:#b294bb;">for</span><span>( for_range_declaration </span><span style="color:#8abeb7;">:</span><span> for_range_initializer ) {
</span><span>   loop_statement
</span><span>}
</span></code></pre>
<p>The <code>for_range_declaration</code> serves to create the variable that will be used in the loop.
The <code>for_range_initializer</code> is what is executed to get the range (can be as simple as what I would call &quot;identity&quot;, i.e. a range can directly be passed in).
The <code>loop_statement</code> is essentially the body of the for loop as with any C style for loop.
The code above will be used by the compiler to generate something similar to the regular iterator loop shown in the [first section]({{&lt; ref &quot;#iterating-over-containers&quot; &gt;}}).
The code looks like this<sup id="ftntref:5"><a href="#ftnt:5">5</a></sup>:</p>
<pre data-lang="c++" style="background-color:#1d1f21;color:#c5c8c6;" class="language-c++ "><code class="language-c++" data-lang="c++"><span style="color:#b294bb;">auto</span><span style="color:#8abeb7;">&amp;&amp;</span><span> rng </span><span style="color:#8abeb7;">=</span><span> for_range_initializer;
</span><span style="color:#b294bb;">auto</span><span> beg </span><span style="color:#8abeb7;">= </span><span style="color:#cc6666;">begin</span><span style="color:#81a2be;">( rng )</span><span>;
</span><span style="color:#b294bb;">auto</span><span> end </span><span style="color:#8abeb7;">= </span><span style="color:#cc6666;">end</span><span style="color:#81a2be;">( rng )</span><span>;
</span><span style="color:#b294bb;">for</span><span>( ; beg </span><span style="color:#8abeb7;">!=</span><span> end; beg</span><span style="color:#8abeb7;">++ </span><span>) {
</span><span>   for_range_declaration </span><span style="color:#8abeb7;">= *</span><span>beg;
</span><span>   loop_statement
</span><span>}
</span></code></pre>
<p>where the <code>begin</code> and <code>end</code> functions are not necessarily free functions, and can be the equivalent member functions of most STL containers.
Actually, if either a <code>begin</code> or an <code>end</code> member function are found in the range object, the pair of member functions is preferred as specified in the standard.
This unfortunately means that if an unrelated function exists in the class, but has one of those names, the class cannot be used in the range-based for statement even if an appropriate free functions pair is provided. This is true regardless of the access specifier of the function (i.e. a private function with such a name will still prevent the range-based for, even if a valid, non member pair of <code>begin</code>/<code>end</code> functions exists).
I believe this might be changed in the future, but for the C++11 to C++17 versions of the standard, range based for is defined this way.</p>
<p>With the definition above in mind, the requirements to use a range-based for loop can then be summarized as having two related types: first, a range like type that has both a <code>begin</code> and an <code>end</code> function (either member, or discoverable through ADL, i.e. in a related namespace) and second, an iterator like type which can be compared for inequality, incremented and dereferenced, i.e. implements the <code>operator!=</code>, <code>operator++</code>, and <code>operator*</code> functions.
The <code>begin</code> and <code>end</code> functions of the range like type must return objects of the iterator type.
If those criteria are met, then the range-based for loop construct is usable with the range like type.
The requirements can be summed up in code like this:</p>
<pre data-lang="c++" style="background-color:#1d1f21;color:#c5c8c6;" class="language-c++ "><code class="language-c++" data-lang="c++"><span style="color:#b294bb;">struct </span><span>range_iterator {
</span><span>   range_iterator </span><span style="color:#81a2be;">operator++</span><span>();
</span><span>   </span><span style="color:#b294bb;">bool </span><span style="color:#81a2be;">operator!=</span><span>( range_iterator </span><span style="color:#b294bb;">const</span><span style="color:#8abeb7;">&amp; </span><span style="color:#de935f;">other </span><span>);
</span><span>   range_value_type </span><span style="color:#81a2be;">operator*</span><span>();
</span><span>}
</span><span>
</span><span style="color:#b294bb;">struct </span><span>range {
</span><span>   range_iterator </span><span style="color:#81a2be;">begin</span><span>();
</span><span>   range_iterator </span><span style="color:#81a2be;">end</span><span>();
</span><span>}
</span></code></pre>
<p>where <code>range_value_type</code> is the type of the data pointed to by the iterator and contained in the range to iterate over.
Implementing those two types should be enough and so that is what I set out to do.</p>
<h3 id="Thinking_of_a_design">Thinking of a design</h3>
<p>I first looked at Anthony William's code to see how it could be done.
I suggest you take a look at the code (<a href="https://www.justsoftwaresolutions.co.uk/files/numeric_range.cpp">download link</a>) to see the approach he has taken.
I wanted to try and make my own implementation, taking a different path.
In my first attempt, I ended up having to write multiple versions of some of the classes in order to customize the behavior for various types.
For instance, comparing floats with <code>operator==</code> is hardly ever what you want (because of floating point errors), but doing so works perfectly with integral types.
Even with templates, I did not arrive at a customizable design that satisfied me.
Having to repeat myself was not so bad, but I wanted to see if I could avoid breaking the DRY principle.
As I said, a good dose of curiosity. :-)</p>
<p>So I needed to change the behavior depending on what type I iterate over.
There are a few alternatives to achieve such behavior in C++.
I wanted an alternative that would be compile time based with no runtime overhead.
I felt it was necessary to get the efficiency I was aiming for.
This meant and abstract base class with virtual functions was not in my solution set.
I decided to explore solutions which allowed me to specify the behavior of the class: some kind of &quot;functionality injection&quot;.
At first, I though of using <a href="http://en.cppreference.com/w/cpp/utility/functional/function">std::function</a> to hold the &quot;pointers&quot; to the functions to call.
That way, I could specify what to use for the three iterator operators when constructing them.
The downside of this, from my perspective, is that this will introduce type erasure (and
possibly/usually accompanying heap allocations) and indirection, which, if I
understand properly, is harder or impossible to optimize for the compiler.
I was worried this would not give me the performance I wanted.
In thinking and searching for alternatives, I remembered <a href="https://www.fluentcpp.com/2017/05/23/strong-types-inheriting-functionalities-from-underlying/">this</a> blog post on inheriting functionalities.
This made me think the same technique applied in the blog post <a href="https://en.wikipedia.org/wiki/Curiously_recurring_template_pattern">CRTP</a> might be the
solution I was looking for (did I mention over-engineering?).</p>
<h3 id="Writing_some_code">Writing some code</h3>
<p>Essentially, there are three functionalities that the iterator has to have and so I created three new types that the iterator would inherit from to &quot;consume&quot; the functionality.
Applying the CRTP pattern, I parametrized those new types so that they would take the iterator class as a template parameter, and I made the iterator class derive from those types.
The implementation ended up as follows:</p>
<pre data-lang="c++" style="background-color:#1d1f21;color:#c5c8c6;" class="language-c++ "><code class="language-c++" data-lang="c++"><span style="color:#b294bb;">enum class </span><span>Direction : </span><span style="color:#b5bd68;">uint_fast8_t </span><span>{
</span><span>   ascending,
</span><span>   descending
</span><span>};
</span><span style="color:#b294bb;">constexpr auto</span><span> Ascending </span><span style="color:#8abeb7;">=</span><span> Direction::ascending;
</span><span style="color:#b294bb;">constexpr auto</span><span> Descending </span><span style="color:#8abeb7;">=</span><span> Direction::descending;
</span><span>
</span><span style="color:#b294bb;">template</span><span>&lt; </span><span style="color:#b294bb;">typename</span><span> Iterator, </span><span style="color:#b294bb;">typename</span><span> Reference &gt;
</span><span style="color:#b294bb;">struct </span><span>Dereference
</span><span>{
</span><span>   </span><span style="color:#b294bb;">auto </span><span style="color:#81a2be;">operator*</span><span>() -&gt; Reference {
</span><span>      </span><span style="color:#b294bb;">return </span><span style="color:#8abeb7;">static_cast</span><span>&lt;Iterator</span><span style="color:#8abeb7;">&amp;</span><span>&gt;(</span><span style="color:#8abeb7;">*</span><span style="color:#cc6666;">this</span><span>).</span><span style="color:#cc6666;">cur_val_</span><span>;
</span><span>   }
</span><span>};
</span><span>
</span><span style="color:#b294bb;">template</span><span>&lt; </span><span style="color:#b294bb;">typename</span><span> Iterator &gt;
</span><span style="color:#b294bb;">struct </span><span>Increment
</span><span>{
</span><span>   </span><span style="color:#b294bb;">auto </span><span style="color:#81a2be;">operator++</span><span>() -&gt; Iterator</span><span style="color:#8abeb7;">&amp; </span><span>{
</span><span>      </span><span style="color:#b294bb;">auto</span><span style="color:#8abeb7;">&amp;</span><span> self </span><span style="color:#8abeb7;">= static_cast</span><span>&lt;Iterator</span><span style="color:#8abeb7;">&amp;</span><span>&gt;(</span><span style="color:#8abeb7;">*</span><span style="color:#cc6666;">this</span><span>);
</span><span>      ( self.</span><span style="color:#cc6666;">direction_ </span><span style="color:#8abeb7;">==</span><span> Ascending ) </span><span style="color:#8abeb7;">? ++</span><span>(self.</span><span style="color:#cc6666;">cur_val_</span><span>)</span><span style="color:#8abeb7;">: --</span><span>(self.</span><span style="color:#cc6666;">cur_val_</span><span>);
</span><span>      </span><span style="color:#b294bb;">return </span><span style="color:#8abeb7;">static_cast</span><span>&lt;Iterator</span><span style="color:#8abeb7;">&amp;</span><span>&gt;(</span><span style="color:#8abeb7;">*</span><span style="color:#cc6666;">this</span><span>);
</span><span>   }
</span><span>};
</span><span>
</span><span style="color:#b294bb;">template</span><span>&lt; </span><span style="color:#b294bb;">typename</span><span> Iterator &gt;
</span><span style="color:#b294bb;">struct </span><span>EqualityComparisons
</span><span>{
</span><span>   </span><span style="color:#b294bb;">bool </span><span style="color:#81a2be;">operator==</span><span>( Iterator </span><span style="color:#b294bb;">const</span><span style="color:#8abeb7;">&amp; </span><span style="color:#de935f;">rhs </span><span>) </span><span style="color:#b294bb;">const </span><span>{
</span><span>      </span><span style="color:#b294bb;">return </span><span style="color:#8abeb7;">static_cast</span><span>&lt;Iterator </span><span style="color:#b294bb;">const</span><span style="color:#8abeb7;">&amp;</span><span>&gt;(</span><span style="color:#8abeb7;">*</span><span style="color:#cc6666;">this</span><span>).</span><span style="color:#cc6666;">cur_val_ </span><span style="color:#8abeb7;">==</span><span> rhs.</span><span style="color:#cc6666;">cur_val_</span><span>;
</span><span>   }
</span><span>   </span><span style="color:#b294bb;">bool </span><span style="color:#81a2be;">operator!=</span><span>( Iterator </span><span style="color:#b294bb;">const</span><span style="color:#8abeb7;">&amp; </span><span style="color:#de935f;">rhs </span><span>) </span><span style="color:#b294bb;">const </span><span>{
</span><span>      </span><span style="color:#b294bb;">return </span><span style="color:#8abeb7;">!</span><span>(</span><span style="color:#8abeb7;">*</span><span style="color:#cc6666;">this </span><span style="color:#8abeb7;">==</span><span> rhs);
</span><span>   }
</span><span>};
</span><span>
</span><span>
</span><span style="color:#b294bb;">template</span><span>&lt; </span><span style="color:#b294bb;">typename</span><span> T &gt;
</span><span style="color:#b294bb;">struct </span><span>range_iterator :
</span><span>      </span><span style="color:#b5bd68;">Dereference</span><span>&lt; range_iterator&lt;T&gt;, T</span><span style="color:#8abeb7;">&amp; </span><span>&gt;,
</span><span>      </span><span style="color:#b5bd68;">Increment</span><span>&lt; range_iterator&lt;T&gt; &gt;,
</span><span>      </span><span style="color:#b5bd68;">EqualityComparisons</span><span>&lt; range_iterator&lt;T&gt; &gt;
</span><span>{
</span><span>   </span><span style="color:#b294bb;">using </span><span>value_type </span><span style="color:#8abeb7;">=</span><span> T;
</span><span>   </span><span style="color:#b294bb;">using </span><span>reference </span><span style="color:#8abeb7;">=</span><span> T</span><span style="color:#8abeb7;">&amp;</span><span>;
</span><span>   </span><span style="color:#b294bb;">using </span><span>iterator_category </span><span style="color:#8abeb7;">=</span><span> std::input_iterator_tag;
</span><span>   </span><span style="color:#b294bb;">using </span><span>pointer </span><span style="color:#8abeb7;">=</span><span> T</span><span style="color:#8abeb7;">*</span><span>;
</span><span>   </span><span style="color:#b294bb;">using </span><span>difference_type </span><span style="color:#8abeb7;">= </span><span style="color:#b294bb;">void</span><span>;
</span><span>
</span><span>   </span><span style="color:#81a2be;">range_iterator</span><span>( T </span><span style="color:#de935f;">val</span><span>, Direction </span><span style="color:#de935f;">dir </span><span>) :
</span><span>                  </span><span style="color:#cc6666;">direction_</span><span>{ dir }, </span><span style="color:#cc6666;">cur_val_</span><span>{ val } {
</span><span>   }
</span><span style="color:#b294bb;">private</span><span>:
</span><span>   Direction direction_;
</span><span>   T cur_val_;
</span><span>
</span><span>   </span><span style="color:#b294bb;">friend</span><span> Dereference</span><span style="color:#8abeb7;">&lt;</span><span> range_iterator&lt;T&gt;, T</span><span style="color:#8abeb7;">&amp; &gt;</span><span>;
</span><span>   </span><span style="color:#b294bb;">friend</span><span> Increment&lt; range_iterator&lt;T&gt; &gt;;
</span><span>   </span><span style="color:#b294bb;">friend</span><span> EqualityComparisons&lt; range_iterator&lt;T&gt; &gt;;
</span><span>};
</span><span>
</span><span>
</span><span style="color:#b294bb;">template</span><span>&lt; </span><span style="color:#b294bb;">typename</span><span> Iterator &gt;
</span><span style="color:#b294bb;">struct </span><span>Range
</span><span>{
</span><span>   </span><span style="color:#b294bb;">private</span><span>:
</span><span>      </span><span style="color:#b294bb;">using </span><span>value_type </span><span style="color:#8abeb7;">= </span><span style="color:#b294bb;">typename</span><span> Iterator::value_type;
</span><span>   </span><span style="color:#b294bb;">public</span><span>:
</span><span>      </span><span style="color:#81a2be;">Range</span><span>( value_type </span><span style="color:#de935f;">start</span><span>, value_type </span><span style="color:#de935f;">stop </span><span>) :
</span><span>         </span><span style="color:#cc6666;">direction_</span><span>{ (start </span><span style="color:#8abeb7;">&lt;</span><span> stop) </span><span style="color:#8abeb7;">?</span><span> Ascending </span><span style="color:#8abeb7;">:</span><span> Descending },
</span><span>                                          </span><span style="color:#cc6666;">cur_val_</span><span>{ start }, </span><span style="color:#cc6666;">end_</span><span>{ stop } {
</span><span>      }
</span><span>      </span><span style="color:#b294bb;">auto </span><span style="color:#81a2be;">begin</span><span>() -&gt; Iterator {
</span><span>         </span><span style="color:#b294bb;">return </span><span style="color:#cc6666;">Iterator</span><span style="color:#81a2be;">{ cur_val_, direction_ }</span><span>;
</span><span>      }
</span><span>      </span><span style="color:#b294bb;">auto </span><span style="color:#81a2be;">end</span><span>() -&gt; Iterator {
</span><span>         </span><span style="color:#b294bb;">return </span><span style="color:#cc6666;">Iterator</span><span style="color:#81a2be;">{ end_, direction_ }</span><span>;
</span><span>      }
</span><span>
</span><span>   </span><span style="color:#b294bb;">private</span><span>:
</span><span>      Direction direction_;
</span><span>      value_type cur_val_;
</span><span>      value_type end_;
</span><span>};
</span></code></pre>
<p>A few things worth mentioning.
I have had to make the &quot;operation&quot; classes friends of the iterator class to give them access to the iterator private data.
If I were designing something for the purpose of having client code specialize and extend the behavior, this break in encapsulation might be more of a concern and I might have to go for a different design, since the friend route seems to be the <a href="https://stackoverflow.com/questions/8523762/crtp-with-protected-derived-member?rq=1">only viable alternative</a> to give the base class access to the derived class data.
But for my current use, it is not something I am worried with.
I also had to explicitly specify the reference type in the <code>Dereference</code> operation.
This is because at the instantiation time of the <code>Dereference</code> template in the inheritance list of the <code>range_iterator</code>, the latter is still an incomplete type and so its <code>typedef</code>s
cannot be used.
Also, for brevity in this blog post, everything is in the global namespace, which is not at all good practice, but in the actual code, I put everything in a <code>estd</code> namespace (for __e__xtended <strong>std</strong>).
The indentation is also slightly modified for the purpose of the blog post.</p>
<p>In any case, with this code (and the appropriate <code>#include</code>s, again omitted for space), one can iterate over numbers using a range-based for loop like this:</p>
<pre data-lang="c++" style="background-color:#1d1f21;color:#c5c8c6;" class="language-c++ "><code class="language-c++" data-lang="c++"><span style="color:#b294bb;">for</span><span>( </span><span style="color:#b294bb;">auto</span><span> idx </span><span style="color:#8abeb7;">: </span><span style="color:#cc6666;">Range</span><span style="color:#81a2be;">&lt; range_iterator&lt;</span><span style="color:#b294bb;">int</span><span style="color:#81a2be;">&gt; &gt;( </span><span style="color:#de935f;">0</span><span style="color:#81a2be;">, </span><span style="color:#de935f;">8 </span><span style="color:#81a2be;">) </span><span>) {
</span><span>   </span><span style="color:#969896;">// use idx
</span><span>}
</span><span>
</span><span style="color:#b294bb;">for</span><span>( </span><span style="color:#b294bb;">auto</span><span> idx </span><span style="color:#8abeb7;">: </span><span style="color:#cc6666;">Range</span><span style="color:#81a2be;">&lt; range_iterator&lt;</span><span style="color:#b294bb;">int</span><span style="color:#81a2be;">&gt; &gt;( </span><span style="color:#de935f;">7</span><span style="color:#81a2be;">, </span><span style="color:#8abeb7;">-</span><span style="color:#de935f;">1 </span><span style="color:#81a2be;">) </span><span>) {
</span><span>   </span><span style="color:#969896;">// use idx
</span><span>}
</span></code></pre>
<p>Verbose, shows implementation details, but a start.
This is the beginning of the interface I set out to have.
It allows specifying <code>start</code> and <code>stop</code> (but not the <code>step</code> yet).
It still requires an explicit type specification, which I would like to get rid of.
It will detect whether you want to go in the increasing of decreasing direction, so increment and decrement are covered.
Some might argue the detection is undesired behavior (Python's <code>range</code> will not do this and a <code>step</code> of -1 must be explicitly specified to decrement).
It is debatable I guess, but this is the interface I went with.</p>
<p>As it stands, in the code above, the implementation will accept floating point
types and character types.
This is not allowed by Python's <code>range</code> object (although using the <a href="http://www.numpy.org/">Numpy</a> <a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.linspace.html"><code>linspace</code></a> function, one can get a floating point range).
Unfortunately, the current implementation of the comparison operator is defined in terms of the underlying type's <code>operator==</code>.
As previously mentioned, comparing floats using this operator is not ideal (and might actually never be true in some cases, which would create an infinite loop).
This has been one of the first reasons I have had for specializing in my earlier designs (which are not presented here), and so I will explore it soon, but before I get to that, I will look at performance to see if my design is good enough for me to pursue further.</p>
<h3 id="Evaluating_the_performance_I">Evaluating the performance I</h3>
<p>Instead of benchmarking the code in the traditional sense of measuring execution time (<a href="https://www.youtube.com/watch?v=zWxSZcpeS8Q">which is complicated</a>), I decided to look at the assembly generated in Code Explorer (i.e. I godbolted my code !) and see if there was any difference between this looping construct and a traditional C style for loop.
My hypothesis is that if the same assembly is generated, then the performance will be the same. I know that <a href="https://channel9.msdn.com/events/Build/2013/4-329?term=The%20Elephant%20in%20the%20CPU">fewer instructions is not a guarantee of better performance</a>, but I think it is safe to assume that if the assembly is the same, then the performance will be the same.</p>
<figure>
    <a href="https://tinyurl.com/ycc42hkx" target="_blank">
        <img src="compiler_explorer.png" alt="https://tinyurl.com/ycc42hkx" />
    </a>
</figure>
<p>In the above figure, the leftmost editor/compiler pane pair illustrates the C style for loop assembly.
The central pane shows the assembly for the version of the range code as it is in the previous section, and, because compiler explorer provides a version of the Boost libraries, the same loop using <code>boost::irange</code> is displayed in the rightmost pane.
The assembly generated is exactly the same even at a low optimization level (<code>O1</code>).
This means GCC is able to completely see through the abstractions and produce the same output whether this range construct or a hand coded C style for loop is used.
When I saw that, I though it was excellent news, and decided to test with two other commonly used compliers: Clang and MSVC<sup id="ftntref:6"><a href="#ftnt:6">6</a></sup>.</p>
<p>Using Clang, I first got disappointing results: a higher optimization level (<code>O2</code>) was necessary to obtain the same result.
Thinking about why that was, I decided to test if it was related to inlining.
Rewriting the code to use <code>__attribute__((always_inline))</code> to suggest more aggressive inlining to the compiler, I was able to get Clang to emit the same assembly as a hand written loop at the lower level (<code>O1</code>).
Great.</p>
<p>I then tried with MSVC.
No matter the optimization level or the inlining hints used, for this compiler, there seems to remain a small difference in the assembly generated when using the <code>Range</code> code presented here compared to that generated when using the C style for loop.
This is shown in the following figure:
<figure>
    
        <img src="msvc.png"/>
    
</figure>
</p>
<p>The loops are structured differently.
In the assembly of the hand written loop, there is a single conditional jump instruction back to the beginning of the loop if the loop exit condition is not met, but no other jump instruction.
When the exit condition is met, the program simply continues with the next instruction,
thereby exiting the loop.
On the other hand, the assembly generated by the <code>Range</code> construct contains two jumps: one back to the beginning of the loop when the loop exit condition is not met, and one out of the loop when the condition is met.
The number of comparison instructions (<code>cmp</code>) is the same though and that should be the most significant performance factor.
I imagine for a very short loop (i.e. low number of iterations), the extra jump <em>could</em> be a significant overhead, but for a long loop, I doubt it.
I guess actual profiling would be needed.</p>
<p>Anyhow, at least in that first attempt, performance did not seem to be a big issue (although compile times will go up if that is your metric).
This was encouraging to me and motivated me to keep exploring this design.</p>
<h3 id="Dealing_with_the_type_specification">Dealing with the type specification</h3>
<p>The next [design goal]({{&lt; ref &quot;#the-initial-design-goals&quot; &gt;}}) I will be talking about is the explicit type specification, or rather removing the need for it.
The <code>Range</code> object is a class template, and prior to C++17, there is no <a href="http://en.cppreference.com/w/cpp/language/class_template_argument_deduction">template parameter argument deduction for class templates</a>.
This means using it directly as in the example above will not allow me to achieve
the &quot;no type specification&quot; goal that I set out for.
However, function templates in C++ always did have <a href="http://en.cppreference.com/w/cpp/language/template_argument_deduction">template argument deduction</a> and so
they could provide a nicer interface.
Given that the range expression in the range-based for loop does not need to be an object, but can be a function returning an object, it is possible to use a set of function template overloads instead of a <code>Range</code> directly.
With those, the types could be deduced.
Such an overload set can be written as follows:</p>
<pre data-lang="c++" style="background-color:#1d1f21;color:#c5c8c6;" class="language-c++ "><code class="language-c++" data-lang="c++"><span style="color:#b294bb;">template</span><span>&lt; </span><span style="color:#b294bb;">typename</span><span> T &gt;
</span><span style="color:#b294bb;">auto </span><span style="color:#81a2be;">range</span><span>( T </span><span style="color:#de935f;">start</span><span>, T </span><span style="color:#de935f;">stop </span><span>) -&gt; Range&lt; range_iterator&lt;T&gt; &gt; {
</span><span>   </span><span style="color:#b294bb;">return </span><span style="color:#cc6666;">Range</span><span style="color:#81a2be;">&lt; range_iterator&lt;T&gt; &gt;{ start, stop }</span><span>;
</span><span>}
</span><span>
</span><span style="color:#b294bb;">template</span><span>&lt; </span><span style="color:#b294bb;">typename</span><span> T &gt;
</span><span style="color:#b294bb;">auto </span><span style="color:#81a2be;">range</span><span>( T </span><span style="color:#de935f;">stop </span><span>) -&gt; Range&lt; range_iterator&lt;T&gt; &gt; {
</span><span>   </span><span style="color:#b294bb;">return </span><span style="color:#cc6666;">range</span><span style="color:#81a2be;">( </span><span style="color:#cc6666;">T</span><span style="color:#81a2be;">{</span><span style="color:#de935f;">0</span><span style="color:#81a2be;">}, stop )</span><span>;
</span><span>}
</span></code></pre>
<p>which can be used without a type specification like this:</p>
<pre data-lang="c++" style="background-color:#1d1f21;color:#c5c8c6;" class="language-c++ "><code class="language-c++" data-lang="c++"><span style="color:#b294bb;">for</span><span>( </span><span style="color:#b294bb;">auto</span><span> i </span><span style="color:#8abeb7;">: </span><span style="color:#cc6666;">range</span><span style="color:#81a2be;">( </span><span style="color:#de935f;">8 </span><span style="color:#81a2be;">) </span><span>) {
</span><span>   </span><span style="color:#969896;">// use i
</span><span>}
</span></code></pre>
<p>which is now very close to the Python version:</p>
<pre data-lang="python" style="background-color:#1d1f21;color:#c5c8c6;" class="language-python "><code class="language-python" data-lang="python"><span style="color:#b294bb;">for </span><span>x </span><span style="color:#b294bb;">in </span><span style="color:#81a2be;">range( </span><span style="color:#de935f;">8 </span><span style="color:#81a2be;">)</span><span>:
</span><span>   </span><span style="color:#969896;"># use i
</span></code></pre>
<p>I have tested this on compiler explorer and it produces the same executable as
the previous version.  So far so good.</p>
<h3 id="Correctly_handling_floating_point_ranges">Correctly handling floating point ranges</h3>
<p>This was not part of the initial [design goals]({{&lt; ref &quot;#the-initial-design-goals&quot; &gt;}}), but dealing with this issue actually helps with the last remaining design goal, so I dealt with it.
In the current version, the main problem with floating point ranges is the
comparison operator.
As it stands, the rest of the code would function properly, but the comparison of <code>begin</code> and <code>end</code> is broken, since it might never yield false and result in an infinite loop (which has happened in testing I should say!).
Said another way, <code>begin</code> might never compare equal to <code>end</code> with the current definition of comparison.</p>
<p>Changing the definition of the <code>operator==</code> to the following unorthodox one would give the proper behavior for floating points:</p>
<pre data-lang="c++" style="background-color:#1d1f21;color:#c5c8c6;" class="language-c++ "><code class="language-c++" data-lang="c++"><span style="color:#b294bb;">bool </span><span style="color:#81a2be;">operator==</span><span>( Iterator </span><span style="color:#b294bb;">const</span><span style="color:#8abeb7;">&amp; </span><span style="color:#de935f;">rhs </span><span>) </span><span style="color:#b294bb;">const </span><span>{
</span><span>   </span><span style="color:#b294bb;">return </span><span>( </span><span style="color:#8abeb7;">static_cast</span><span>&lt;Iterator</span><span style="color:#8abeb7;">&amp;</span><span>&gt;(</span><span style="color:#8abeb7;">*</span><span style="color:#cc6666;">this</span><span>).</span><span style="color:#cc6666;">direction_ </span><span style="color:#8abeb7;">==</span><span> Ascending ) </span><span style="color:#8abeb7;">?
</span><span>            ( </span><span style="color:#8abeb7;">static_cast</span><span>&lt;Iterator</span><span style="color:#8abeb7;">&amp;</span><span>&gt;(</span><span style="color:#8abeb7;">*</span><span style="color:#cc6666;">this</span><span>).</span><span style="color:#cc6666;">cur_val_ </span><span style="color:#8abeb7;">&gt;=</span><span> rhs.</span><span style="color:#cc6666;">cur_val_ </span><span>) </span><span style="color:#8abeb7;">:
</span><span>               ( </span><span style="color:#8abeb7;">static_cast</span><span>&lt;Iterator</span><span style="color:#8abeb7;">&amp;</span><span>&gt;(</span><span style="color:#8abeb7;">*</span><span style="color:#cc6666;">this</span><span>).</span><span style="color:#cc6666;">cur_val_ </span><span style="color:#8abeb7;">&lt;=</span><span> rhs.</span><span style="color:#cc6666;">cur_val_ </span><span>);
</span><span>}
</span></code></pre>
<p>With this definition, for an ascending direction, two iterators are considered equal if the value of the left hand side one is equal <em>or larger</em> than that of the right hand side one.
In the range-based for loop, the right hand side iterator in the comparison is always <code>end()</code>, so for those loops, the comparison as defined above means any iterator with a value of end or more (ascending) are considered equal.
Thus, as soon as the loop iterator's value reaches, or gets past, that of the end iterator, both iterators are considered equal and the loop stops.
This is the desired behavior for the loop, but it is an unusual definition for the iterator <em>if</em> you think of the iterator as the value it holds.</p>
<p>Having an operator with an unusual meaning is generally considered bad practice, and for good reasons.
With the previous definition, the result of comparing two iterators can depend on the order of the parameters:</p>
<pre data-lang="c++" style="background-color:#1d1f21;color:#c5c8c6;" class="language-c++ "><code class="language-c++" data-lang="c++"><span>range_iterator&lt;</span><span style="color:#b294bb;">double</span><span>&gt; </span><span style="color:#81a2be;">a</span><span>( </span><span style="color:#de935f;">42.0</span><span>, </span><span style="color:#de935f;">Ascending </span><span>);
</span><span>range_iterator&lt;</span><span style="color:#b294bb;">double</span><span>&gt; </span><span style="color:#81a2be;">b</span><span>( </span><span style="color:#de935f;">48.5</span><span>, </span><span style="color:#de935f;">Ascending </span><span>);
</span><span style="color:#cc6666;">assert</span><span style="color:#81a2be;">( a </span><span style="color:#8abeb7;">==</span><span style="color:#81a2be;"> b )</span><span>;                    </span><span style="color:#969896;">// will fire,     42.0 &gt;= 48.5 -&gt; false
</span><span style="color:#cc6666;">assert</span><span style="color:#81a2be;">( b </span><span style="color:#8abeb7;">==</span><span style="color:#81a2be;"> a )</span><span>;                    </span><span style="color:#969896;">// will not fire, 48.5 &gt;= 42.0 -&gt; true
</span><span style="color:#cc6666;">assert</span><span style="color:#81a2be;">( ( a </span><span style="color:#8abeb7;">==</span><span style="color:#81a2be;"> b ) </span><span style="color:#8abeb7;">!= </span><span style="color:#81a2be;">( b </span><span style="color:#8abeb7;">==</span><span style="color:#81a2be;"> a )  )</span><span>; </span><span style="color:#969896;">// will not fire, false != true
</span></code></pre>
<p>which is surprising.
Operators having unusual or inconsistent behavior can be confusing (the <a href="https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md">C++ Core Guidelines</a> discuss this in their overload section (C.over), more specifically subsections C.160 and C.167).
The problem I am faced with here is that the range-based for loop cannot be customized to use something other than <code>operator!=</code> to compare the two iterators.  So whatever behavior I want my iterator to have, it must be in the comparison operator.</p>
<p>That said, for the case at hand, these iterators are part of the implementation of the <code>range</code> function, which is the only part of the library that is considered public.
The only use of the comparison operator should therefore be the one in the range-based for, where the only comparison is between the <code>begin</code> and <code>end</code> iterator pair, which will have the correct behavior.
The iterators are not meant to be used directly and I think the implementation is thus reasonable.
That is debatable for sure, but in any case, in the actual implementation, the function above is defined in the <code>EqualityComparisons</code> class and some template metaprogramming ensures that it applies only to floating point types.</p>
<p>I should warn though that using floating points as a loop counter, either manually or using the <code>range</code> functions here, is not as simple as it seems at first: floating point maths and comparisons are hard and floating point error will be present with the naive loop.
Since the construct proposed here aims only at replacing the naive loop, nothing fancy is done to compensate floating point errors in loops involving floating points, and so I thought a reminder was in order.</p>
<h3 id="Allowing_non_unit_steps">Allowing non unit steps</h3>
<p>The last goal in my initial list is the non unit step.
For now, I can select <code>start</code> and <code>stop</code>, I allow increment and decrement, I do not need to specify the type, and the performance penalty (with some optimizations enabled) is almost null on the compilers I tested.
The final goal is to allow non unit steps.
In order to do that, I have to:</p>
<ol>
<li>store the <code>step</code> in the iterator;</li>
<li>adjust the <code>operator++</code> to advance of <code>step</code> units instead of 1;</li>
<li>adjust the <code>operator==</code> for integral types;</li>
<li>add an overload to the <code>range</code> function which takes 3 arguments.</li>
</ol>
<p>The third item was the easiest to deal with.
The change became necessary, since if the step size is not an <em>exact</em> divisor of the distance between <code>start</code> and <code>stop</code>, the original definition of <code>operator==</code> will never stop the loop, because the loop iterator value will never be exactly the end iterator value, even for integral types.
It turns out that using the same definition of the equality operator as was used to deal with floating point iterators, the problem is solved.
Now, when the value of the loop iterator is above the end iterator value, the loop stops, as desired.</p>
<p>Going back to the first item, the decision I made was to add a template parameter to the <code>range_iterator</code> class which will be of a new enum type <code>Length</code> which tells me whether the <code>range_iterator</code> will have unit length steps or any other length.
Then, I create a specialization for the case where the length is unit and one for when the length is other.</p>
<pre data-lang="c++" style="background-color:#1d1f21;color:#c5c8c6;" class="language-c++ "><code class="language-c++" data-lang="c++"><span style="color:#b294bb;">enum class </span><span>Length : </span><span style="color:#b5bd68;">uint_fast8_t </span><span>{
</span><span>   unit,
</span><span>   other
</span><span>};
</span><span>
</span><span style="color:#b294bb;">constexpr auto</span><span> Unit </span><span style="color:#8abeb7;">=</span><span> Length::unit;
</span><span style="color:#b294bb;">constexpr auto</span><span> Other </span><span style="color:#8abeb7;">=</span><span> Length::other;
</span><span>
</span><span style="color:#b294bb;">template</span><span>&lt; </span><span style="color:#b294bb;">typename</span><span> T, Length length &gt;
</span><span style="color:#b294bb;">struct </span><span>range_iterator;
</span><span>
</span><span style="color:#b294bb;">template</span><span>&lt; </span><span style="color:#b294bb;">typename</span><span> T &gt;
</span><span style="color:#b294bb;">struct </span><span>range_iterator&lt; T, Unit &gt; :
</span><span>         </span><span style="color:#b5bd68;">Dereference</span><span>&lt; range_iterator&lt;T&gt;, T</span><span style="color:#8abeb7;">&amp; </span><span>&gt;,
</span><span>         </span><span style="color:#b5bd68;">Increment</span><span>&lt; range_iterator&lt;T&gt; &gt;,
</span><span>         </span><span style="color:#b5bd68;">EqualityComparisons</span><span>&lt; range_iterator&lt;T&gt; &gt;
</span><span>{
</span><span>   </span><span style="color:#969896;">/* implementation here for Unit length */
</span><span style="color:#b294bb;">private</span><span>:
</span><span>   Direction direction_;
</span><span>   T cur_val_;
</span><span>}
</span><span>
</span><span>
</span><span style="color:#b294bb;">template</span><span>&lt; </span><span style="color:#b294bb;">typename</span><span> T &gt;
</span><span style="color:#b294bb;">struct </span><span>range_iterator&lt; T, Other &gt; :
</span><span>         </span><span style="color:#b5bd68;">Dereference</span><span>&lt; range_iterator&lt;T&gt;, T</span><span style="color:#8abeb7;">&amp; </span><span>&gt;,
</span><span>         </span><span style="color:#b5bd68;">Increment</span><span>&lt; range_iterator&lt;T&gt; &gt;,
</span><span>         </span><span style="color:#b5bd68;">EqualityComparisons</span><span>&lt; range_iterator&lt;T&gt; &gt;
</span><span>{
</span><span>   </span><span style="color:#969896;">/* implementation here for Other length */
</span><span style="color:#b294bb;">private</span><span>:
</span><span>   Direction direction_;
</span><span>   T cur_val_;
</span><span>   T step_;
</span><span>}
</span><span>
</span></code></pre>
<p>In the case where the length is not one, the <code>step</code> is kept as a data member and available to the operators.</p>
<p>Changing the <code>operator++</code> was not much more complicated than the change to the comparison operator.
The <code>Increment</code> type is now templated on the length, and, using SFINAE, a different implementation of the <code>operator++</code> is used depending on whether the <code>length</code> argument is <code>Unit</code> or <code>Other</code>.</p>
<pre data-lang="c++" style="background-color:#1d1f21;color:#c5c8c6;" class="language-c++ "><code class="language-c++" data-lang="c++"><span style="color:#b294bb;">auto </span><span style="color:#81a2be;">operator++</span><span>() -&gt; Iterator&lt; T, length &gt; {
</span><span>   </span><span style="color:#8abeb7;">static_cast</span><span>&lt;Iterator&lt; T, length &gt;</span><span style="color:#8abeb7;">&amp;</span><span>&gt;(</span><span style="color:#8abeb7;">*</span><span style="color:#cc6666;">this</span><span>).</span><span style="color:#cc6666;">cur_val_ </span><span style="color:#8abeb7;">+=
</span><span>                           </span><span style="color:#8abeb7;">static_cast</span><span>&lt;Iterator&lt; T, length &gt;</span><span style="color:#8abeb7;">&amp;</span><span>&gt;(</span><span style="color:#8abeb7;">*</span><span style="color:#cc6666;">this</span><span>).</span><span style="color:#cc6666;">step_</span><span>;
</span><span>}
</span></code></pre>
<p>The only remaining task is to add an overload of the <code>range</code> function.
This overload will take one more parameter (the <code>step</code>) and return a range parametrized
with a different iterator type.</p>
<pre data-lang="c++" style="background-color:#1d1f21;color:#c5c8c6;" class="language-c++ "><code class="language-c++" data-lang="c++"><span style="color:#b294bb;">template</span><span>&lt; </span><span style="color:#b294bb;">typename</span><span> T, </span><span style="color:#b294bb;">typename</span><span> U &gt;
</span><span style="color:#b294bb;">auto </span><span style="color:#81a2be;">range</span><span>( T </span><span style="color:#de935f;">start</span><span>, T </span><span style="color:#de935f;">stop</span><span>, U </span><span style="color:#de935f;">step </span><span>) -&gt; detail::range&lt; T &gt; {
</span><span>   </span><span style="color:#b294bb;">return </span><span style="color:#81a2be;">detail::</span><span style="color:#cc6666;">range</span><span style="color:#81a2be;">&lt; T &gt;{ start, stop, step }</span><span>;
</span><span>}
</span></code></pre>
<p>It should be noted that the <code>start</code>/<code>stop</code> and the <code>step</code> parameters can have different types.
This is necessary for someone to be able to call the function like this:</p>
<pre data-lang="c++" style="background-color:#1d1f21;color:#c5c8c6;" class="language-c++ "><code class="language-c++" data-lang="c++"><span style="color:#b294bb;">for</span><span>( </span><span style="color:#b294bb;">auto</span><span> i </span><span style="color:#8abeb7;">: </span><span style="color:#cc6666;">range</span><span style="color:#81a2be;">( </span><span style="color:#de935f;">13</span><span style="color:#b294bb;">u</span><span style="color:#81a2be;">, </span><span style="color:#de935f;">0</span><span style="color:#b294bb;">u</span><span style="color:#81a2be;">, </span><span style="color:#8abeb7;">-</span><span style="color:#de935f;">3 </span><span style="color:#81a2be;">) </span><span>) {}
</span></code></pre>
<p>If all three parameters were of the same type, then the user would have to manually convert one way or the other, which is not a nice interface.
What is done in the implementation is a cast inside the constructor of the <code>Range</code> object to the iterator type.
Unfortunately, this opens the door to quite a few conversion problems.
If you go from signed to unsigned, the behavior is correct and portable.
If you go from unsigned to signed, the behavior is implementation defined, but should mostly work.</p>
<p>Anyhow, with all of this in place, all my goals are achieved!</p>
<h2 id="Mixed_types,_logic_checking...">Mixed types, logic checking...</h2>
<p>As I said, the code above is close to the one I ended up with, but not exactly the same.
You can go on <a href="https://github.com/ghlecl/range_fn">Github</a> to find my range function implementation.
There are more things one could do with it (or do differently).</p>
<p>One thing that could be done is allow for mixed types to be used for specifying the bounds and not only the step (see previous section).
That is actually what prompted my two previous posts about [integer representations]({{&lt; ref &quot;integer_representations&quot; &gt;}}) and [usual conversions in arithmetic]({{&lt; ref &quot;usual_conversions&quot; &gt;}}).
I am not illustrating the code here, since it would make this already long post even longer, but it can be done.
It does bring up some interesting questions though such as which type to return when two types are used.
I am still uncertain what a good answer is.
As far as I can tell, Boost range has decided to simply not allow that.
This is not unreasonable.
That said, the use case I see for
allowing mixed types bounds specification is the following:</p>
<pre data-lang="c++" style="background-color:#1d1f21;color:#c5c8c6;" class="language-c++ "><code class="language-c++" data-lang="c++"><span>std::vector&lt; </span><span style="color:#b294bb;">int </span><span>&gt; </span><span style="color:#cc6666;">v</span><span style="color:#81a2be;">{ </span><span style="color:#de935f;">0</span><span style="color:#81a2be;">, </span><span style="color:#de935f;">2</span><span style="color:#81a2be;">, </span><span style="color:#de935f;">4</span><span style="color:#81a2be;">, </span><span style="color:#de935f;">6</span><span style="color:#81a2be;">, </span><span style="color:#de935f;">8</span><span style="color:#81a2be;">, </span><span style="color:#de935f;">10</span><span style="color:#81a2be;">, </span><span style="color:#de935f;">12 </span><span style="color:#81a2be;">}</span><span>;
</span><span style="color:#b294bb;">for</span><span>( </span><span style="color:#b294bb;">auto</span><span> idx </span><span style="color:#8abeb7;">: </span><span style="color:#cc6666;">range</span><span style="color:#81a2be;">( </span><span style="color:#de935f;">3</span><span style="color:#81a2be;">, v.</span><span style="color:#cc6666;">size</span><span style="color:#81a2be;">() ) </span><span>) {
</span><span>   </span><span style="color:#969896;">// do something with the items 3 to size of vector v
</span><span>}
</span></code></pre>
<p>Since the standard library has made the choice of having <code>size</code> of containers be unsigned, without mixed bound types, this would not work without asking the user to write <code>3u</code> as the first index or cast the <code>.size()</code> call result.</p>
<p>Another thing, you will see in the code is some consistency checks.
For instance, if <code>start</code> &gt; <code>stop</code> while <code>step</code> &gt; 0, there is likely a problem (unless you
allow overflowing loops, which could be done).</p>
<p>There are some parts of the code which, with hindsight, seem superfluous.
For instance, there is no difference in the dereferencing behavior in any of the code here, so it would be simpler to leave it in the <code>range_iterator</code> implementation.
It would not be DRY (repeated in two classes), but the complexity introduced might not be worth it.  As with any code, I think it can be <del>bikeshedded</del> debated forever.  :-)</p>
<p>Anyhow, I hope you have enjoyed reading this post.
Writing it certainly made me clarify the concepts involved in range-based for loops in C++ and yielded a construct I can use to loop over indices with a nice pythonish syntax.
It is what I initially wanted, so for me at least, mission accomplished!</p>
<hr />
<h2 id="Acknowledments">Acknowledments</h2>
<p>I would like to thank <a href="https://www.twitter.com/Gab_AL_">Gabriel Aubut-Lussier</a> for taking the time to read this post before I published it and making constructive comments on the content.
The writing is better for it.</p>
<h2 id="Notes">Notes</h2>
<p id="ftnt:1"><sup>[1]</sup>&nbsp;The work here will probably be made completely useless by the <a href="http://open-std.org/JTC1/SC22/WG21/docs/papers/2017/n4685.pdf">range proposal</a> when it gets in the standard.
On top of that, such a function already exists in <a href="https://www.boost.org/doc/libs/1_67_0/libs/range/doc/html/range/reference/ranges/irange.html">Boost</a>.
The links were valid at the time of writing.
The link to the range proposal is actually to a draft version of the proposal, which might differ from what actually ends up in the standard.&nbsp;<a href="#ftntref:1">&#8617;&#65038;</a></p>
<p id="ftnt:2"><sup>[2]</sup>&nbsp;Link pointed to most recent release on the date of writing.
Might not work on future dates.&nbsp;<a href="#ftntref:2">&#8617;&#65038;</a></p>
<p id="ftnt:3"><sup>[3]</sup>&nbsp;Edit 2018-08-16: Turns out even in C++98, it works for built-in
arrays, albeit not with the <code>std::begin()</code> and <code>std::end()</code> free functions given
they were introduced in C++11.
You can simply pass the array &quot;bounds&quot; (i.e. the array variable and the array variable plus the length) to the standard algorithm (tested with std::sort) and it works.
You learn every day!&nbsp;<a href="#ftntref:3">&#8617;&#65038;</a></p>
<p id="ftnt:4"><sup>[4]</sup>&nbsp;At first, like most I would think, I actually first asked a search engine and that is how I found <a href="https://www.justsoftwaresolutions.co.uk/cplusplus/generating_sequences.html">Anthony's post</a> on the subject.
This was a great starting point.&nbsp;<a href="#ftntref:4">&#8617;&#65038;</a></p>
<p id="ftnt:5"><sup>[5]</sup>&nbsp;Adapted from the C++17 standard draft.&nbsp;<a href="#ftntref:5">&#8617;&#65038;</a></p>
<p id="ftnt:6"><sup>[6]</sup>&nbsp;In the course of writing this article, I realized that a version of the Intel compiler was also available on Compiler Explorer and thus decided to look at the assembly generated with this compiler.
It turns out it takes optimization level 3 for the code to give the same result as the hand-coded loop with this compiler.
Depending on whether or not you can use this optimization level, the performance of the <code>Range</code> presented here might not be very good with this compiler.&nbsp;<a href="#ftntref:6">&#8617;&#65038;</a></p>

    </article>
  </main>


  <footer>
    <div class="footer_text">
      <div>
        <h3>Hi, <a href="https://ghlecl.github.io/about/">I'm Ghyslain</a></h3>
        <p>
          I am a medical physicist by day and a hobby programmer by night.
          You can follow me on <a href="http://twitter.com/ghlecl" target="_blank">Twitter</a>
          and on <a href="http://github.com/ghlecl" target="_blank">GitHub</a>.
          You can reach me via codeattempts [at] gmail [dot] com.
        </p>
        </div>
    </div>
    <div class="footer_copyright">
      &copy; 2022 <a href="https://ghlecl.github.io/about/">Ghyslain Leclerc</a>
      &mdash; Made in Québec, Canada
      &mdash; Generated using <a href="https://www.getzola.org/" target="_blank">Zola</a>
      &mdash; Style ported from <a href="https://jnjosh.com/about/" target="_blank">Josh Johnson's</a>
      Hugo Theme (<a href="https://github.com/jnjosh/internet-weblog"target="_blank">internet-weblog</a>)
    </div>
  </footer>

</body>

</html>
