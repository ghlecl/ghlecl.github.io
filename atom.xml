<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
  <title>Code attempts</title>
  <subtitle>Personnal notes on code</subtitle>
  <link href="https://ghlecl.github.io/atom.xml" rel="self" type="application/atom+xml"/>
  <link href="https://ghlecl.github.io"/>
  <generator uri="https://www.getzola.org/">Zola</generator>
  <updated>2022-04-22T22:30:00</updated>
  <id>"https://ghlecl.github.io/atom.xml"</id>
  <entry xml:lang="en">
    <title>Converting to Zola</title>
    <author>codeattempts@gmail.com</author>
    <published>2022-04-22T22:30:00</published>
    <updated>2022-04-22T22:30:00</updated>
    <link href="https://ghlecl.github.io/posts/conveting_to_zola/" type="text/html"/>
    <id>https://ghlecl.github.io/posts/conveting_to_zola/</id>
    <summary>
   Zola
I haven't had (or taken really) the time to write anything technical in the last few years.
The pandemic definitely did have an impact on me, but also work.
I was not in a frame of mind to program at home, much less write about it.
But lately, I've felt better and I am getting back into that hobby of mine.
In the interim, the static site generator that I was using (Hugo) upgraded quite a few</summary>
    <content>&lt;h1 id=&quot;Zola&quot;&gt;Zola&lt;&#x2F;h1&gt;
&lt;p&gt;I haven&#x27;t had (or taken really) the time to write anything technical in the last few years.
The pandemic definitely did have an impact on me, but also work.
I was not in a frame of mind to program at home, much less write about it.
But lately, I&#x27;ve felt better and I am getting back into that hobby of mine.&lt;&#x2F;p&gt;
&lt;p&gt;In the interim, the static site generator that I was using (Hugo) upgraded quite a few times, so much so that a bunch of warnings&#x2F;errors came up when I tried it again to update my site.
This was a reminder that I don&#x27;t actually understand fully the tool I&#x27;m using and that I could probably understand better.
Given that I would had to change things anyhow, I allowed myself to look at alternatives and came up on &lt;a href=&quot;https:&#x2F;&#x2F;www.getzola.org&#x2F;&quot;&gt;Zola&lt;&#x2F;a&gt;.
One thing that I did not like much about Hugo was the templates.
It is based on the Go templating language.
Zola is based on the &lt;a href=&quot;https:&#x2F;&#x2F;tera.netlify.app&#x2F;&quot;&gt;Tera&lt;&#x2F;a&gt; templating engine which itself is based on the popular &lt;a href=&quot;https:&#x2F;&#x2F;jinja.palletsprojects.com&#x2F;en&#x2F;3.1.x&#x2F;&quot;&gt;Jinja&lt;&#x2F;a&gt;, which I find more intuitive.
So I decided to try and switch.&lt;&#x2F;p&gt;
&lt;p&gt;One thing I did not want to change was the layout of the site.
I quite like the style of the Hugo theme I was using: &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;jnjosh&#x2F;internet-weblog&quot;&gt;Internet-Weblog&lt;&#x2F;a&gt;.
So I set out to replicate it, mostly, but did change a few things.&lt;&#x2F;p&gt;
&lt;p&gt;First, I abandoned microposts, since I realized I have short posts, but nothing micro.
I did not use some of the features of the theme, so I did not put them in and kept the basic minimum.&lt;&#x2F;p&gt;
&lt;p&gt;Then, I have changed the RSS feed for an Atom feed.  Hoping this will not be too problematic.
I probably had one, maybe two subscribers, so I doubt it will affect that many people.&lt;&#x2F;p&gt;
&lt;p&gt;I also added a link footnote system so that the footnotes are clickable and there is a back link after the note to get back to the text.&lt;&#x2F;p&gt;
&lt;p&gt;I also changed the colors of the code samples and the highlighting.  I use a tomorrow night like color scheme (which, incidentally, I like to use in my editors as well).&lt;&#x2F;p&gt;
&lt;p&gt;One thing I couldn&#x27;t achieve is the exact same pagination.
This is a technical limitation of Zola.
It might change in the next versions, but for now, the about page is now considered a &amp;quot;post&amp;quot; just like the rest of the posts.
If the limitation in Zola is lifted, I&#x27;ll remove it.
For now, I&#x27;ve artificially set the date of the about page to be before any other post, so that it is at the end of the pagination.&lt;&#x2F;p&gt;
&lt;p&gt;Other than those, I don&#x27;t think there is much change.  Still, thought I would mark the change by this short post to remember when it happened.&lt;&#x2F;p&gt;
</content>
  </entry>
  <entry xml:lang="en">
    <title>One of std::string ctor</title>
    <author>codeattempts@gmail.com</author>
    <published>2018-09-18T21:45:00</published>
    <updated>2018-09-18T21:45:00</updated>
    <link href="https://ghlecl.github.io/posts/string_ctor/" type="text/html"/>
    <id>https://ghlecl.github.io/posts/string_ctor/</id>
    <summary>
   std::string from C style string ctor
In writing a function template having to create a std::string from a char[], I have had to use the following constructor of std::string:
basic_string( CharT const* s, size_type count, Allocator const&amp; alloc = Allocator() );

which you can find documentation for in the standard or on cppreference.com.
In using this constructor, I have had a &quot;off by one&quot; problem with the count parameter.
The function template I originally wrote used the constructor</summary>
    <content>&lt;h1 id=&quot;std::string_from_C_style_string_ctor&quot;&gt;std::string from C style string ctor&lt;&#x2F;h1&gt;
&lt;p&gt;In writing a function template having to create a &lt;code&gt;std::string&lt;&#x2F;code&gt; from a &lt;code&gt;char[]&lt;&#x2F;code&gt;, I have had to use the following constructor of &lt;code&gt;std::string&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; style=&quot;background-color:#1d1f21;color:#c5c8c6;&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;basic_string&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;( CharT &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;const&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt; s, size_type count, Allocator &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;const&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt; alloc &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;Allocator&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;() )&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;which you can find documentation for in the standard or on &lt;a href=&quot;https:&#x2F;&#x2F;en.cppreference.com&#x2F;w&#x2F;cpp&#x2F;string&#x2F;basic_string&#x2F;basic_string&quot;&gt;cppreference.com&lt;&#x2F;a&gt;.
In using this constructor, I have had a &amp;quot;off by one&amp;quot; problem with the &lt;code&gt;count&lt;&#x2F;code&gt; parameter.
The function template I originally wrote used the constructor like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; style=&quot;background-color:#1d1f21;color:#c5c8c6;&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;template&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt; std::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f0c674;&quot;&gt;size_t&lt;&#x2F;span&gt;&lt;span&gt; N &amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;std::string &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;foo&lt;&#x2F;span&gt;&lt;span&gt;( &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;char const &lt;&#x2F;span&gt;&lt;span&gt;( &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;char_arr )[N] ) {
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;std::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;string&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;( char_arr, N )&lt;&#x2F;span&gt;&lt;span&gt;;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#969896;&quot;&gt;&#x2F;&#x2F; WRONG, do not do this
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;which is a mistake.
The terminating &lt;code&gt;&#x27;\0&#x27;&lt;&#x2F;code&gt; character will be included in the value of &lt;code&gt;N&lt;&#x2F;code&gt; and will thus be part of the &lt;code&gt;std::string&lt;&#x2F;code&gt; (which &lt;em&gt;can&lt;&#x2F;em&gt; contain nulls).
Thus, the size of the new &lt;code&gt;std::string&lt;&#x2F;code&gt; will be one more then expected:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; style=&quot;background-color:#1d1f21;color:#c5c8c6;&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;char const&lt;&#x2F;span&gt;&lt;span&gt; arr[] &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5bd68;&quot;&gt;&amp;quot;string&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;auto&lt;&#x2F;span&gt;&lt;span&gt; bar &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;foo&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;( arr )&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;assert&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;( bar.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;length&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;() &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;!= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;6 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;)&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;assert&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;( bar.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;length&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;() &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;== &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;7 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;)&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Usually, when one is certain that the C style string is null terminated, the recommended way to use the constructor is:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; style=&quot;background-color:#1d1f21;color:#c5c8c6;&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;&lt;span&gt;std::string &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;the_strg&lt;&#x2F;span&gt;&lt;span&gt;( &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;char_arr&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;std::strlen( char_arr ) &lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Since &lt;code&gt;std::strlen&lt;&#x2F;code&gt; will not include the null terminator in the length returned.
To mimic this behavior, my template had to be written as:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; style=&quot;background-color:#1d1f21;color:#c5c8c6;&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;template&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt; std::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f0c674;&quot;&gt;size_t&lt;&#x2F;span&gt;&lt;span&gt; N &amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;std::string &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;foo&lt;&#x2F;span&gt;&lt;span&gt;( &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;char const &lt;&#x2F;span&gt;&lt;span&gt;( &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;char_arr )[N] ) {
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;std::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;string&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;( char_arr, N &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;- &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;1 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;)&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;which will eliminate the need to calculate the length at runtime and yield the correct &lt;code&gt;std::string&lt;&#x2F;code&gt; with the expected length.
This is not exactly a hard problem, but it bit me and I want to remember this little detail!&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;p&gt;Edit (2018-09-19):
&lt;a href=&quot;https:&#x2F;&#x2F;twitter.com&#x2F;PatriceRoy1&quot;&gt;Patrice Roy&lt;&#x2F;a&gt; pointed out that my return statement in the first function was awkward (copy pasting and modifying to make an example is not ideal) and the second version was not returning anything.
Fixed now.
Thanks Patrice for pointing it out.&lt;&#x2F;p&gt;
</content>
  </entry>
  <entry xml:lang="en">
    <title>Invoking a callable in C++</title>
    <author>codeattempts@gmail.com</author>
    <published>2018-09-13T19:15:00</published>
    <updated>2018-09-13T19:15:00</updated>
    <link href="https://ghlecl.github.io/posts/cpp_invoke/" type="text/html"/>
    <id>https://ghlecl.github.io/posts/cpp_invoke/</id>
    <summary>
   Invoking a callable in C++
This is my exploration of the std::invoke utility of C++17.
I started with something vaguely related (which I am discussing here) and ended up reading the standard library implementation of std::invoke (and that of Google's Abseil library).
The funny thing is that in the end, I decided I did not really need any of it for my original motivation, but I did gain some knowledge along the way, so worth the</summary>
    <content>&lt;h1 id=&quot;Invoking_a_callable_in_C++&quot;&gt;Invoking a callable in C++&lt;&#x2F;h1&gt;
&lt;p&gt;This is my exploration of the &lt;a href=&quot;https:&#x2F;&#x2F;en.cppreference.com&#x2F;w&#x2F;cpp&#x2F;utility&#x2F;functional&#x2F;invoke&quot;&gt;&lt;code&gt;std::invoke&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; utility of C++17.
I started with something &lt;em&gt;vaguely&lt;&#x2F;em&gt; related (which I am discussing here) and ended up reading the standard library implementation of &lt;code&gt;std::invoke&lt;&#x2F;code&gt; (and that of Google&#x27;s &lt;a href=&quot;https:&#x2F;&#x2F;abseil.io&#x2F;&quot;&gt;Abseil&lt;&#x2F;a&gt; library).
The funny thing is that in the end, I decided I did not really need any of it for my original motivation, but I did gain some knowledge along the way, so worth the time!&lt;&#x2F;p&gt;
&lt;h2 id=&quot;My_original_motivation&quot;&gt;My original motivation&lt;&#x2F;h2&gt;
&lt;p&gt;Even though &lt;a href=&quot;https:&#x2F;&#x2F;herbsutter.com&#x2F;2011&#x2F;10&#x2F;07&#x2F;why-no-container-based-algorithms&quot;&gt;there are reasons&lt;&#x2F;a&gt; not to have container based algorithms in the C++ standard library (upcoming ranges being one more reason), in my code, I find my main use case for the algorithms is still to work on the whole container.
Because of that, I was looking into ways to get whole container overloads for the algorithms.
In that endeavor, I stumbled upon &lt;a href=&quot;https:&#x2F;&#x2F;ideone.com&#x2F;aruf06&quot;&gt;this&lt;&#x2F;a&gt; solution.
In the usage examples at the bottom of the code, one finds two usage syntaxes:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; style=&quot;background-color:#1d1f21;color:#c5c8c6;&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;apply_on&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;( bobs, for_each, std::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;mem_fn&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;( &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;Bob::stuff) )&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;for_each_on&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;( bobs, std::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;mem_fn&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;( &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;Bob::stuff ) )&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;where the &lt;code&gt;for_each_on&lt;&#x2F;code&gt; is obviously not in the &lt;code&gt;std&lt;&#x2F;code&gt; namespace.
This is very close to what I am looking for, which is a function with the name &lt;code&gt;for_each&lt;&#x2F;code&gt; that will simply forward its call to the &lt;code&gt;std::for_each&lt;&#x2F;code&gt;, but will work on the whole container rather than asking for two iterators.
Something that would look like that:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; style=&quot;background-color:#1d1f21;color:#c5c8c6;&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;for_each&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;( bobs, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;Bob::stuff )&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;where this &lt;code&gt;for_each&lt;&#x2F;code&gt; is not the one in namespace &lt;code&gt;std&lt;&#x2F;code&gt; (but shares its name with it as opposed to the &lt;code&gt;for_each_on&lt;&#x2F;code&gt; function in the solution I found online).&lt;&#x2F;p&gt;
&lt;p&gt;In adapting&#x2F;inserting this solution to my code, I realized that the custom &lt;code&gt;apply_on&lt;&#x2F;code&gt; function I found online is pretty much a particular case of C++17&#x27;s &lt;a href=&quot;https:&#x2F;&#x2F;en.cppreference.com&#x2F;w&#x2F;cpp&#x2F;utility&#x2F;functional&#x2F;invoke&quot;&gt;&lt;code&gt;std::invoke&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;.
Since I am not interested in directly using the &lt;code&gt;apply_on&lt;&#x2F;code&gt; function as shown in the examples of the online solution, I thought I should just adapt it to use &lt;code&gt;std::invoke&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Unfortunately, at work, not all the external libraries that our projects depend on have transitioned to C++17.
Therefore, to use &lt;code&gt;std::invoke&lt;&#x2F;code&gt;, I needed a working C++11 implementation (which would of course then not be in the &lt;code&gt;std&lt;&#x2F;code&gt; namespace, but I digress).
Turns out it is not that hard to find &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;tomaszkam&#x2F;proposals&#x2F;tree&#x2F;master&#x2F;invoke&quot;&gt;a&lt;&#x2F;a&gt; &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;Rapptz&#x2F;Gears&#x2F;blob&#x2F;master&#x2F;gears&#x2F;functional&#x2F;invoke.hpp&quot;&gt;C++11&lt;&#x2F;a&gt; &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;abseil&#x2F;abseil-cpp&#x2F;blob&#x2F;master&#x2F;absl&#x2F;base&#x2F;internal&#x2F;invoke.h&quot;&gt;implementation&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;That said, before using any of them, I wanted to make sure I understand the concepts so that I can provide support if necessary.
Thus, I set out to read and understand those implementations.
In the process, I came up with my own, which I am discussing here.
I do not pretend this implementation is superior or even on par with the others I have seen (and certainly not with the standard library implementations out there), but from the tests I have made (comparing
with Clang&#x27;s implementation on a C++17 compiler I have access to), it seems to be as capable (probably did not think of every conceivable test).
It might, however, be very slow to compile and suboptimal.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;Syntax(es)_of_a_&quot;call&quot;_in_C++&quot;&gt;Syntax(es) of a &amp;quot;call&amp;quot; in C++&lt;&#x2F;h2&gt;
&lt;p&gt;Before I embarked on this journey, I had never needed to make function calls through function pointers or member pointers.
I have had the luxury&#x2F;luck of working only on newer projects that did not involve that many callbacks.
Lambdas have mostly always been available to me, so I was not familiar with the various call syntaxes of function pointers, member pointers and the like.
Since I could use lambdas, when I needed to call some member function on all the elements of a
vector, for instance, I just created a lambda doing exactly that and never considered using a pointer to the member.
Thus, my first hurdle was understanding the problem space of calling something in C++.&lt;&#x2F;p&gt;
&lt;p&gt;Although the section on the magical &lt;code&gt;INVOKE&lt;&#x2F;code&gt; entity&lt;sup id=&quot;ftntref:1&quot;&gt;&lt;a href=&quot;#ftnt:1&quot;&gt;1&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt; in the C++ 17 standard (which is section &lt;em&gt;23.14.3 Requirements ([&lt;em&gt;func.require&lt;&#x2F;em&gt;])&lt;&#x2F;em&gt;) has seven bullet points, when looking at the bigger picture, I think it is a useful approximation to summarize by saying there are three call syntaxes in C++:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;function call syntax&lt;&#x2F;li&gt;
&lt;li&gt;member function pointer call syntax&lt;&#x2F;li&gt;
&lt;li&gt;member object pointer call syntax&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;where member object is roughly standardese for data member.
Translated in pseudo code, the three syntaxes above look like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; style=&quot;background-color:#1d1f21;color:#c5c8c6;&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;invocable&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;( arguments )&lt;&#x2F;span&gt;&lt;span&gt;;           &lt;&#x2F;span&gt;&lt;span style=&quot;color:#969896;&quot;&gt;&#x2F;&#x2F; function syntax
&lt;&#x2F;span&gt;&lt;span&gt;object.*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;invocable&lt;&#x2F;span&gt;&lt;span&gt;( arguments );   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#969896;&quot;&gt;&#x2F;&#x2F; member function pointer syntax
&lt;&#x2F;span&gt;&lt;span&gt;object.*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;invocable&lt;&#x2F;span&gt;&lt;span&gt;;                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#969896;&quot;&gt;&#x2F;&#x2F; member object pointer syntax
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The first syntax can be applied to any invocable that is not a member, be it a regular function, a function pointer, a lambda or a &lt;code&gt;struct&lt;&#x2F;code&gt; defining a call operator (&lt;code&gt;operator()&lt;&#x2F;code&gt;).
The two others are used when dealing with pointers to member.
Whether one is dealing with a pointer to member function or to member object, the standard allows using said pointer to call &amp;quot;into&amp;quot; an object of a related type either directly, through a &lt;code&gt;std::reference_wrapper&lt;&#x2F;code&gt; or through a pointer.
In other words, there is a clause in the standard for each of the following calls (again in pseudo code):&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; style=&quot;background-color:#1d1f21;color:#c5c8c6;&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;&lt;span&gt;(object.*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;invocable&lt;&#x2F;span&gt;&lt;span&gt;)( arguments )         &lt;&#x2F;span&gt;&lt;span style=&quot;color:#969896;&quot;&gt;&#x2F;&#x2F; object
&lt;&#x2F;span&gt;&lt;span&gt;(wrapper.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;get&lt;&#x2F;span&gt;&lt;span&gt;().*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;invocable&lt;&#x2F;span&gt;&lt;span&gt;)( arguments )  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#969896;&quot;&gt;&#x2F;&#x2F; std::reference_wrapper
&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span&gt;pointer.*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;invocable&lt;&#x2F;span&gt;&lt;span&gt;)( arguments )       &lt;&#x2F;span&gt;&lt;span style=&quot;color:#969896;&quot;&gt;&#x2F;&#x2F; pointer to object
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;object.*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;invocable           &lt;&#x2F;span&gt;&lt;span style=&quot;color:#969896;&quot;&gt;&#x2F;&#x2F; object
&lt;&#x2F;span&gt;&lt;span&gt;wrapper.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;get&lt;&#x2F;span&gt;&lt;span&gt;().*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;invocable    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#969896;&quot;&gt;&#x2F;&#x2F; std::reference_wrapper
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span&gt;pointer.*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;invocable         &lt;&#x2F;span&gt;&lt;span style=&quot;color:#969896;&quot;&gt;&#x2F;&#x2F; pointer to object
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Note that the parentheses in the first three lines are necessary because the function call operator (i.e. &lt;code&gt;operator()&lt;&#x2F;code&gt;) has lower &lt;a href=&quot;https:&#x2F;&#x2F;en.cppreference.com&#x2F;w&#x2F;cpp&#x2F;language&#x2F;operator_precedence&quot;&gt;precedence&lt;&#x2F;a&gt; than the pointer-to-member operator (i.e. &lt;code&gt;operator.*&lt;&#x2F;code&gt;).
If the parentheses were not there, i.e. if the first line were written &lt;code&gt;object.*invocable( arguments )&lt;&#x2F;code&gt; instead of the current syntax, then the order of operations would be &lt;code&gt;invocable( arguments )&lt;&#x2F;code&gt; before &lt;code&gt;object.*invocable&lt;&#x2F;code&gt;, and that would error out: the compiler would rightfully complain that the type of &lt;code&gt;invocable&lt;&#x2F;code&gt; is not a callable because it would not access the member before trying to call it.&lt;&#x2F;p&gt;
&lt;p&gt;Adding the general function call syntax to the list above, one gets a total of seven call syntaxes, one per bullet point of the standard.
In the end, a conforming implementation of &lt;code&gt;std::invoke&lt;&#x2F;code&gt; must provide this single function template which will, based on the type of its parameters and arguments, use the correct call syntax for the situation.
Getting there is not as easy as it seems (underestimating implementation difficulty is a recurring theme for me...).
In all the C++11 implementations I have seen, it involves at least &lt;a href=&quot;https:&#x2F;&#x2F;en.cppreference.com&#x2F;w&#x2F;cpp&#x2F;language&#x2F;sfinae&quot;&gt;SFINAE&lt;&#x2F;a&gt; and &lt;a href=&quot;https:&#x2F;&#x2F;en.cppreference.com&#x2F;w&#x2F;cpp&#x2F;language&#x2F;function_template#Function_template_overloading&quot;&gt;function template partial ordering&lt;&#x2F;a&gt;.
In C++17, using &lt;a href=&quot;https:&#x2F;&#x2F;en.cppreference.com&#x2F;w&#x2F;cpp&#x2F;language&#x2F;if#Constexpr_If&quot;&gt;constexpr if&lt;&#x2F;a&gt;, it is possible to have a simpler implementation (see &lt;a href=&quot;https:&#x2F;&#x2F;en.cppreference.com&#x2F;w&#x2F;&quot;&gt;cppreference.com&lt;&#x2F;a&gt; &lt;a href=&quot;https:&#x2F;&#x2F;en.cppreference.com&#x2F;w&#x2F;cpp&#x2F;utility&#x2F;functional&#x2F;invoke#Possible_implementation&quot;&gt;possible implementation&lt;&#x2F;a&gt;), but, as mentioned, that was not a possibility for me.
Before reading on (if you are still interested), I would suggest reading up on SFINAE (specifically the &lt;a href=&quot;https:&#x2F;&#x2F;en.cppreference.com&#x2F;w&#x2F;cpp&#x2F;types&#x2F;enable_if&quot;&gt;&lt;code&gt;std::enable_if&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; technique&#x2F;idiom), and maybe a little on function template partial ordering.
I do not explain the former at all, while I do say a little bit on the latter as I have discovered it while understanding the implementations of &lt;code&gt;invoke&lt;&#x2F;code&gt; and this blog serves a bit as my note-taking!&lt;&#x2F;p&gt;
&lt;h2 id=&quot;C++17&#x27;s_std::invoke&quot;&gt;C++17&#x27;s &lt;code&gt;std::invoke&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;The_naïve_starting_point&quot;&gt;The naïve starting point&lt;&#x2F;h3&gt;
&lt;p&gt;Considering only the function call syntax, the function template needed can be
as simple as:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; style=&quot;background-color:#1d1f21;color:#c5c8c6;&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;template&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;typename&lt;&#x2F;span&gt;&lt;span&gt; Invocable, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;typename&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;...&lt;&#x2F;span&gt;&lt;span&gt; Args &amp;gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;auto &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;invoke&lt;&#x2F;span&gt;&lt;span&gt;( Invocable &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;invocable&lt;&#x2F;span&gt;&lt;span&gt;, Args&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;... &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;args &lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;   -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;decltype&lt;&#x2F;span&gt;&lt;span&gt;( &lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;invocable&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;( args&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;... &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;) &lt;&#x2F;span&gt;&lt;span&gt;) {
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;invocable&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;( args&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;... &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;)&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Although it will work for the function call syntax, this implementation is naïve, not taking into account argument passing efficiency (perfect forwarding) or &lt;code&gt;noexcept&lt;&#x2F;code&gt; specification.
It will also obviously fail for any other syntax in the list presented in the previous section.
We need to have other specializations or overloads which will handle the other call syntaxes.
Since it is a function template and not a class&#x2F;struct template, it is not possible to partially specialize it.
I do not think it is possible to use full specialization to create the overload set needed, but I might be wrong.
That said, it is however possible to overload it and select the appropriate overload via SFINAE or function template partial ordering, which is what I have seen in most implementation, and what is explored next.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;Member_pointers&quot;&gt;Member pointers&lt;&#x2F;h3&gt;
&lt;p&gt;As written above, the &lt;code&gt;invoke&lt;&#x2F;code&gt; function will not work for member pointers.
Different approaches can be taken to deal with this problem and allow the function to be called with other member pointers.
One way is to write an overload of the function which will not take just any invocable as an argument, but only member pointers.
This overload will still need to be a template to accommodate member pointers of any type and some mechanism is needed to insure that the template is selected only when called with a member pointer.
One way to achieve this is through &lt;a href=&quot;https:&#x2F;&#x2F;en.cppreference.com&#x2F;w&#x2F;cpp&#x2F;language&#x2F;function_template#Function_template_overloading&quot;&gt;function template partial ordering&lt;&#x2F;a&gt;, which is what most implementations that I have seen have used.
Since I have been influenced by those implementations, I did the same.
There could have been alternatives, for instance SFINAE.&lt;sup id=&quot;ftntref:2&quot;&gt;&lt;a href=&quot;#ftnt:2&quot;&gt;2&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;  That said, I went with partial ordering.
This concept relies on template parameters and function arguments being such that one function is considered more specialized than the other.
The algorithm for partial ordering is well explained in &lt;a href=&quot;https:&#x2F;&#x2F;stackoverflow.com&#x2F;a&#x2F;17008568&quot;&gt;this StackOverflow answer&lt;&#x2F;a&gt;.
As stated in the answer, a comment of the original question gives a pretty good description of the concept:&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;Partial ordering basically checks in the parameters of two templates, if the parameter of one is more restrictive than the corresponding parameter of the other.
If you have &lt;code&gt;f(T)&lt;&#x2F;code&gt; and &lt;code&gt;f(bar&amp;lt;T&amp;gt;)&lt;&#x2F;code&gt; (with &lt;code&gt;T&lt;&#x2F;code&gt; as a template parameter), then the first overload can take all possible arguments of the second overload, but the second overload can&#x27;t take all possible arguments from the first overload - only those of the &lt;code&gt;bar&amp;lt;T&amp;gt;&lt;&#x2F;code&gt; form.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;Putting aside perfect forwarding and the &lt;code&gt;noexcept&lt;&#x2F;code&gt; specification for now (we&#x27;ll come back to them in the end), an overload of the function template which uses function template partial ordering can be written like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; style=&quot;background-color:#1d1f21;color:#c5c8c6;&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;template&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;typename&lt;&#x2F;span&gt;&lt;span&gt; MemPtr, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;typename&lt;&#x2F;span&gt;&lt;span&gt; Obj, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;typename&lt;&#x2F;span&gt;&lt;span&gt; Arg1, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;typename&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;...&lt;&#x2F;span&gt;&lt;span&gt; Args &amp;gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;auto &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;invoke&lt;&#x2F;span&gt;&lt;span&gt;( MemPtr Obj::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;* &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;invocable&lt;&#x2F;span&gt;&lt;span&gt;, Arg1 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;arg1&lt;&#x2F;span&gt;&lt;span&gt;, Args&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;... &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;args &lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;   -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;decltype&lt;&#x2F;span&gt;&lt;span&gt;( (arg1.*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;invocable&lt;&#x2F;span&gt;&lt;span&gt;)( args&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;... &lt;&#x2F;span&gt;&lt;span&gt;) ) {
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span&gt;(arg1.*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;invocable&lt;&#x2F;span&gt;&lt;span&gt;)( args&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;... &lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The template parameters are the member pointer type (&lt;code&gt;MemPtr&lt;&#x2F;code&gt;), the type pointed into by the member pointer (&lt;code&gt;Obj&lt;&#x2F;code&gt;), the object type the pointer is called on (&lt;code&gt;Arg1&lt;&#x2F;code&gt;&lt;sup id=&quot;ftntref:3&quot;&gt;&lt;a href=&quot;#ftnt:3&quot;&gt;3&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;) and the subsequent argument types (&lt;code&gt;Args...&lt;&#x2F;code&gt;), if any.
For plain function pointers, this deduction will fail because the first function argument will not be a match, and the original overload will be selected.
For member pointers, the substitution will succeed and this overload will be considered more specialized, and it will be selected as intended.
Note again the parentheses around the &lt;code&gt;arg1.*invocable&lt;&#x2F;code&gt; both in the &lt;code&gt;decltype&lt;&#x2F;code&gt; and in the template body.
As mentioned in the previous section, those are mandatory.&lt;&#x2F;p&gt;
&lt;p&gt;Although this template does work, in its current form, it will be selected whenever &lt;code&gt;invoke&lt;&#x2F;code&gt; is called with a member pointer as its first argument, even if the object you want to invoke the pointer on (the second argument to &lt;code&gt;invoke&lt;&#x2F;code&gt; which has type &lt;code&gt;Arg1&lt;&#x2F;code&gt;) is unrelated to the type the pointer points into (type &lt;code&gt;Obj&lt;&#x2F;code&gt;).
This is a problem because for arbitrary unrelated types, using the function pointer from one type on the other will fail to compile.
To prevent this overload from being selected when the types are unrelated, SFINAE can be used.
To do this, a defaulted template parameter is added after the parameter pack and defaulted to &lt;code&gt;enable_if_t&lt;&#x2F;code&gt;&lt;sup id=&quot;ftntref:4&quot;&gt;&lt;a href=&quot;#ftnt:4&quot;&gt;4&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt; with a predicate to filter out the cases that should not match. In this case, the predicate is &lt;code&gt;std::is_base_of&amp;lt; Obj, Arg1 &amp;gt;&lt;&#x2F;code&gt; and the solution looks like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; style=&quot;background-color:#1d1f21;color:#c5c8c6;&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;template&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;typename&lt;&#x2F;span&gt;&lt;span&gt; MemPtr,
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;typename&lt;&#x2F;span&gt;&lt;span&gt; Obj,
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;typename&lt;&#x2F;span&gt;&lt;span&gt; Arg1,
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;typename&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;...&lt;&#x2F;span&gt;&lt;span&gt; Args,
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;typename &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; enable_if_t&amp;lt; std::is_base_of&amp;lt; Obj, Arg1 &amp;gt;::value &amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;auto &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;invoke&lt;&#x2F;span&gt;&lt;span&gt;( MemPtr Obj::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;* &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;invocable&lt;&#x2F;span&gt;&lt;span&gt;, Arg1 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;arg1&lt;&#x2F;span&gt;&lt;span&gt;, Args&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;... &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;args &lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;   -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;decltype&lt;&#x2F;span&gt;&lt;span&gt;( (arg1.*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;invocable&lt;&#x2F;span&gt;&lt;span&gt;)( args&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;... &lt;&#x2F;span&gt;&lt;span&gt;) ) {
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span&gt;(arg1.*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;invocable&lt;&#x2F;span&gt;&lt;span&gt;)( args&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;... &lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;where we can bikeshed my formatting some other time! 🙂
With this in place, this overload will not be selected when there is no inheritance (or identity) relationship between the member pointer object type (&lt;code&gt;Obj&lt;&#x2F;code&gt;) and the invoked-on object type (&lt;code&gt;Arg1&lt;&#x2F;code&gt;).&lt;&#x2F;p&gt;
&lt;p&gt;Alright, this overload is a step in the right direction, but it still cannot be used with member &lt;em&gt;object&lt;&#x2F;em&gt; pointers.
That is because the call syntax is wrong: there must not be an argument list after the invocable.
If we want to have member object pointers working, there has to be a third overload with the appropriate call syntax.
If there is a third overload, there needs to be a way to select it when needed, and one cannot rely only on the function template partial ordering, since this will distinguish between callables and member pointers, but not between different member pointers, since they have the same syntax in the function argument list.
For this, we must rely once more on SFINAE and the standard library type traits, adding one more defaulted template parameter after the parameter pack for one of the overloads:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; style=&quot;background-color:#1d1f21;color:#c5c8c6;&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;template&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;typename&lt;&#x2F;span&gt;&lt;span&gt; MemPtr,
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;typename&lt;&#x2F;span&gt;&lt;span&gt; Obj,
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;typename&lt;&#x2F;span&gt;&lt;span&gt; Arg1,
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;typename&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;...&lt;&#x2F;span&gt;&lt;span&gt; Args,
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;typename &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; enable_if_t&amp;lt; std::is_base_of&amp;lt; Obj, Arg1 &amp;gt;::value &amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;typename &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; enable_if_t&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span&gt; std::is_member_function_pointer&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span&gt; MemPtr Obj::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;* &lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;::value &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;auto &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;invoke&lt;&#x2F;span&gt;&lt;span&gt;( MemPtr Obj::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;* &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;invocable&lt;&#x2F;span&gt;&lt;span&gt;, Arg1 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;arg1&lt;&#x2F;span&gt;&lt;span&gt;, Args&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;... &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;args &lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;   -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;decltype&lt;&#x2F;span&gt;&lt;span&gt;( (arg1.*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;invocable&lt;&#x2F;span&gt;&lt;span&gt;)( args&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;... &lt;&#x2F;span&gt;&lt;span&gt;) ) {
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span&gt;(arg1.*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;invocable&lt;&#x2F;span&gt;&lt;span&gt;)( args&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;... &lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;template&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;typename&lt;&#x2F;span&gt;&lt;span&gt; MemPtr,
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;typename&lt;&#x2F;span&gt;&lt;span&gt; Obj,
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;typename&lt;&#x2F;span&gt;&lt;span&gt; Arg1,
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;typename &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; enable_if_t&amp;lt; std::is_base_of&amp;lt; Obj, Arg1 &amp;gt;::value &amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;auto &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;invoke&lt;&#x2F;span&gt;&lt;span&gt;( MemPtr Obj::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;* &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;invocable&lt;&#x2F;span&gt;&lt;span&gt;, Arg1 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;arg1 &lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;   -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;decltype&lt;&#x2F;span&gt;&lt;span&gt;( arg1.*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;invocable &lt;&#x2F;span&gt;&lt;span&gt;) {
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;return&lt;&#x2F;span&gt;&lt;span&gt; arg1.*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;invocable&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;It should be noted that using the predicate &lt;code&gt;std::is_member_object_pointer&lt;&#x2F;code&gt; on the last overload instead would have also worked.
Now, the overload set of the three &lt;code&gt;invoke&lt;&#x2F;code&gt; functions defined above will be callable on anything that has the free function syntax, the member function pointer syntax or the member object (a.k.a. data member) pointer syntax, if the latter two are used directly with an object of the appropriate type (i.e. a type the member pointer points into or a type derived from it).
This constitutes only three of the seven syntaxes mandated by the standard.
None of the overloads will work if the object to call the member pointer on (&lt;code&gt;arg1&lt;&#x2F;code&gt;) is a &lt;code&gt;std::reference_wrapper&lt;&#x2F;code&gt; of such an object or a pointer to such an object.
Still some distance to go.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;Invoked-on_object_type&quot;&gt;Invoked-on object type&lt;&#x2F;h3&gt;
&lt;p&gt;If you have felt like this is getting verbose already, you are not going to like the rest of this blog post.
Basically, for each of the two last overloads, three variants are needed (the one already defined and two more):&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;one that can be called with an object of the type the member pointer points
into (or a type derived from it),&lt;&#x2F;li&gt;
&lt;li&gt;one that can be called with a &lt;code&gt;std::reference_wrapper&lt;&#x2F;code&gt; to an object of the
type the member pointer points into (or a type derived from it),&lt;&#x2F;li&gt;
&lt;li&gt;or one that can be called on a pointer to an object of the type the member
pointer points into (or a type derived from it).&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Expressed in a more concrete way, considering the &lt;code&gt;invoke&lt;&#x2F;code&gt; overloads as defined above and using the argument types in their declarations, the previous text means that if &lt;code&gt;Arg1&lt;&#x2F;code&gt; is of the type &lt;code&gt;Obj&lt;&#x2F;code&gt; or a type derived from it, &lt;code&gt;invoke&lt;&#x2F;code&gt; should be able to call the member pointer with&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;an object of type &lt;code&gt;Arg1&lt;&#x2F;code&gt;,&lt;&#x2F;li&gt;
&lt;li&gt;an object of type &lt;code&gt;std::reference_wrapper&amp;lt; Arg1 &amp;gt;&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;or an object or type &lt;code&gt;*Arg1&lt;&#x2F;code&gt;.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;As mentioned, the first case (i.e. object) is already written.
Let us tackle the last two.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;std::reference_wrapper&quot;&gt;&lt;code&gt;std::reference_wrapper&lt;&#x2F;code&gt;&lt;&#x2F;h4&gt;
&lt;p&gt;To handle the second case (i.e. &lt;code&gt;std::reference_wrapper&lt;&#x2F;code&gt;, one has to write a template working on member pointers which will be selected only when the second argument is a &lt;code&gt;std::reference_wrapper&lt;&#x2F;code&gt; to an object of an appropriate type, and SFINAE away otherwise.
Again, function template partial ordering is used to distinguish between function call syntax and member pointer syntax.
The new challenge is to find a way for the overload to be selected only when the second argument&#x27;s type is a &lt;code&gt;std::reference_wrapper&lt;&#x2F;code&gt;.
This kind of requirement has been solved with &lt;code&gt;enable_if_t&lt;&#x2F;code&gt; in the previous sections and the same technique can be applied here: add a defaulted template parameter after the parameter pack and default it to &lt;code&gt;enable_if_t&lt;&#x2F;code&gt; with an appropriate predicate.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; style=&quot;background-color:#1d1f21;color:#c5c8c6;&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;template&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;typename&lt;&#x2F;span&gt;&lt;span&gt; MemPtr,
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;typename&lt;&#x2F;span&gt;&lt;span&gt; Obj,
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;typename&lt;&#x2F;span&gt;&lt;span&gt; Arg1,
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;typename&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;...&lt;&#x2F;span&gt;&lt;span&gt; Args,
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;typename &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; enable_if_t&amp;lt; is_reference_wrapper&amp;lt; Arg1 &amp;gt;::value &amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;typename &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; enable_if_t&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span&gt; std::is_member_function_pointer&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span&gt; MemPtr Obj::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;* &lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;::value &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;auto &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;invoke&lt;&#x2F;span&gt;&lt;span&gt;( MemPtr Obj::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;* &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;invocable&lt;&#x2F;span&gt;&lt;span&gt;, Arg1 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;arg1&lt;&#x2F;span&gt;&lt;span&gt;, Args&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;... &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;args &lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;   -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;decltype&lt;&#x2F;span&gt;&lt;span&gt;( (arg1.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;get&lt;&#x2F;span&gt;&lt;span&gt;().*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;invocable&lt;&#x2F;span&gt;&lt;span&gt;)( args&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;... &lt;&#x2F;span&gt;&lt;span&gt;) ) {
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span&gt;(arg1.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;get&lt;&#x2F;span&gt;&lt;span&gt;().*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;invocable&lt;&#x2F;span&gt;&lt;span&gt;)( args&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;... &lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;template&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;typename&lt;&#x2F;span&gt;&lt;span&gt; MemPtr,
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;typename&lt;&#x2F;span&gt;&lt;span&gt; Obj,
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;typename&lt;&#x2F;span&gt;&lt;span&gt; Arg1,
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;typename &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; enable_if_t&amp;lt; is_reference_wrapper&amp;lt; Arg1 &amp;gt;::value &amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;auto &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;invoke&lt;&#x2F;span&gt;&lt;span&gt;( MemPtr Obj::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;* &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;invocable&lt;&#x2F;span&gt;&lt;span&gt;, Arg1 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;arg1 &lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;   -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;decltype&lt;&#x2F;span&gt;&lt;span&gt;( arg1.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;get&lt;&#x2F;span&gt;&lt;span&gt;().*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;invocable &lt;&#x2F;span&gt;&lt;span&gt;) {
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;return&lt;&#x2F;span&gt;&lt;span&gt; arg1.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;get&lt;&#x2F;span&gt;&lt;span&gt;().*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;invocable&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Unfortunately, there is no type trait in the standard library to determine if a type is a &lt;code&gt;std::reference_wrapper&lt;&#x2F;code&gt;.
Such a type trait can be written like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; style=&quot;background-color:#1d1f21;color:#c5c8c6;&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;template &lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;class&lt;&#x2F;span&gt;&lt;span&gt; T&amp;gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span&gt;is_reference_wrapper : &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5bd68;&quot;&gt;std::false_type &lt;&#x2F;span&gt;&lt;span&gt;{};
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;template &lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;class&lt;&#x2F;span&gt;&lt;span&gt; U&amp;gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span&gt;is_reference_wrapper&amp;lt; std::reference_wrapper&amp;lt; U &amp;gt; &amp;gt; : &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5bd68;&quot;&gt;std::true_type &lt;&#x2F;span&gt;&lt;span&gt;{};
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;which would probably be put in a &lt;code&gt;detail&lt;&#x2F;code&gt; namespace as this does not need to be used by user code.
With this type trait and the definition above, the calls where the invoked-on object type is &lt;code&gt;std::reference_wrapper&lt;&#x2F;code&gt; work.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;Pointer_to_object&quot;&gt;Pointer to object&lt;&#x2F;h4&gt;
&lt;p&gt;One would think the last case is handled the same way simply by replacing the type trait used in the &lt;code&gt;enable_if_t&lt;&#x2F;code&gt; by the &lt;a href=&quot;https:&#x2F;&#x2F;en.cppreference.com&#x2F;w&#x2F;cpp&#x2F;types&#x2F;is_pointer&quot;&gt;&lt;code&gt;std::is_pointer&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; type trait of the standard library, but in most implementations I have seen, it is not the case.
I believe the reason is that testing with &lt;code&gt;std::is_pointer&lt;&#x2F;code&gt; will yield &lt;code&gt;false&lt;&#x2F;code&gt; for smart pointers even if the invoked-on pointer syntax should actually work for them.&lt;sup id=&quot;ftntref:5&quot;&gt;&lt;a href=&quot;#ftnt:5&quot;&gt;5&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;
One could test for every smart pointer in the standard library inside the predicate of the &lt;code&gt;enable_if_t&lt;&#x2F;code&gt;, but that would needlessly prevent user defined smart pointers to be used, and the standard library implementer (or the one implementing &lt;code&gt;invoke&lt;&#x2F;code&gt;) cannot reliably test for every user defined smart pointer.
Thus, the implementations usually check that they are neither in the first nor in the second cases (i.e. neither directly on an appropriately typed object nor on a &lt;code&gt;std::reference_wrapper&lt;&#x2F;code&gt; to one such object), and direct any other invoked-on object type to the last case.
This can be done once more using defaulted template parameters after the parameter pack in combination with SFINAE, much like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; style=&quot;background-color:#1d1f21;color:#c5c8c6;&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;template&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;typename&lt;&#x2F;span&gt;&lt;span&gt; MemPtr,
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;typename&lt;&#x2F;span&gt;&lt;span&gt; Obj,
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;typename&lt;&#x2F;span&gt;&lt;span&gt; Arg1,
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;typename&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;...&lt;&#x2F;span&gt;&lt;span&gt; Args,
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;typename &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; enable_if_t&amp;lt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;!&lt;&#x2F;span&gt;&lt;span&gt;std::is_base_of&amp;lt; Obj, Arg1 &amp;gt;::value &amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;typename &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; enable_if_t&amp;lt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;!&lt;&#x2F;span&gt;&lt;span&gt;is_reference_wrapper&amp;lt; Arg1 &amp;gt;::value &amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;typename &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; enable_if_t&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span&gt; std::is_member_function_pointer&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span&gt; MemPtr Obj::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;* &lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;::value &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;auto &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;invoke&lt;&#x2F;span&gt;&lt;span&gt;( MemPtr Obj::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;* &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;invocable&lt;&#x2F;span&gt;&lt;span&gt;, Arg1 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;arg1&lt;&#x2F;span&gt;&lt;span&gt;, Args&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;... &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;args &lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;   -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;decltype&lt;&#x2F;span&gt;&lt;span&gt;( (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span&gt;arg1.*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;invocable&lt;&#x2F;span&gt;&lt;span&gt;)( args&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;... &lt;&#x2F;span&gt;&lt;span&gt;) ) {
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span&gt;arg1.*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;invocable&lt;&#x2F;span&gt;&lt;span&gt;)( args&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;... &lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;template&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;typename&lt;&#x2F;span&gt;&lt;span&gt; MemPtr,
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;typename&lt;&#x2F;span&gt;&lt;span&gt; Obj,
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;typename&lt;&#x2F;span&gt;&lt;span&gt; Arg1,
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;typename &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; enable_if_t&amp;lt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;!&lt;&#x2F;span&gt;&lt;span&gt;std::is_base_of&amp;lt; Obj, Arg1 &amp;gt;::value &amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;typename &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; enable_if_t&amp;lt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;!&lt;&#x2F;span&gt;&lt;span&gt;is_reference_wrapper&amp;lt; Arg1 &amp;gt;::value &amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;auto &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;invoke&lt;&#x2F;span&gt;&lt;span&gt;( MemPtr Obj::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;* &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;invocable&lt;&#x2F;span&gt;&lt;span&gt;, Arg1 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;arg1 &lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;   -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;decltype&lt;&#x2F;span&gt;&lt;span&gt;( &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span&gt;arg1.*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;invocable &lt;&#x2F;span&gt;&lt;span&gt;) {
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span&gt;arg1.*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;invocable&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;where the first condition of &lt;code&gt;!std::is_base_of&amp;lt; Obj, Arg1 &amp;gt;::value&lt;&#x2F;code&gt; ensures this is not the direct object case, and the second condition is the opposite of the one used in the &lt;code&gt;std::reference_wrapper&lt;&#x2F;code&gt; case (thus insuring it is not selected in that case).&lt;&#x2F;p&gt;
&lt;p&gt;This is the last of the syntaxes to cover, and so this is a working implementation of &lt;code&gt;invoke&lt;&#x2F;code&gt; which covers all cases mandated by the standard.
That said, some things can be made better.
If you are interested, read on.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;Perfect_forwarding&quot;&gt;Perfect forwarding&lt;&#x2F;h3&gt;
&lt;p&gt;In order to be more efficient and prevent argument copies, perfect forwarding should be introduced into the mix.
To get perfect forwarding, one must use &lt;del&gt;universal&lt;&#x2F;del&gt;&lt;sup id=&quot;ftntref:6&quot;&gt;&lt;a href=&quot;#ftnt:6&quot;&gt;6&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt; forwarding references, and use &lt;code&gt;std::forward&lt;&#x2F;code&gt; on the arguments inside the implementation.
In what follows, the function call syntax and the member function pointer syntax are explored, both with a direct object case.
All other cases (i.e. member object call syntax and other invoke-on object types) can be modified to use perfect forwarding the same way, so in the name of brevity, they are not explicitly covered here.&lt;&#x2F;p&gt;
&lt;p&gt;Adding forwarding reference to the function argument list (i.e. &lt;code&gt;&amp;amp;&amp;amp;&lt;&#x2F;code&gt;) and using &lt;code&gt;std::forward&lt;&#x2F;code&gt; in the implementation, the &lt;code&gt;invoke&lt;&#x2F;code&gt; template for the two situations covered can introduce perfect forwarding by being modified like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; style=&quot;background-color:#1d1f21;color:#c5c8c6;&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;template&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;typename&lt;&#x2F;span&gt;&lt;span&gt; Invocable, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;typename&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;...&lt;&#x2F;span&gt;&lt;span&gt; Args &amp;gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;auto &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;invoke&lt;&#x2F;span&gt;&lt;span&gt;( Invocable&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;amp;&amp;amp; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;invocable&lt;&#x2F;span&gt;&lt;span&gt;, Args&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;amp;&amp;amp;... &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;args &lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;   -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;decltype&lt;&#x2F;span&gt;&lt;span&gt;(
&lt;&#x2F;span&gt;&lt;span&gt;         &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;std::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;forward&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;&amp;lt;Invocable&amp;gt;(invocable)&lt;&#x2F;span&gt;&lt;span&gt;( &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;std::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;forward&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;&amp;lt;Args&amp;gt;(args)&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;... &lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;   )
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;std::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;forward&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;&amp;lt;Invocable&amp;gt;(invocable)&lt;&#x2F;span&gt;&lt;span&gt;( &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;std::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;forward&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;&amp;lt;Args&amp;gt;(args)&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;... &lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;template&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;typename&lt;&#x2F;span&gt;&lt;span&gt; MemPtr,
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;typename&lt;&#x2F;span&gt;&lt;span&gt; Obj,
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;typename&lt;&#x2F;span&gt;&lt;span&gt; Arg1,
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;typename&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;...&lt;&#x2F;span&gt;&lt;span&gt; Args,
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;typename &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; enable_if_t&amp;lt; std::is_base_of&amp;lt; Obj, decay_t&amp;lt; Arg1 &amp;gt; &amp;gt;::value &amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;typename &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; enable_if_t&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span&gt; std::is_member_function_pointer&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span&gt; MemPtr Obj::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;* &lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;::value &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;auto &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;invoke&lt;&#x2F;span&gt;&lt;span&gt;( MemPtr Obj::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;*&amp;amp;&amp;amp; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;invocable&lt;&#x2F;span&gt;&lt;span&gt;, Arg1&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;amp;&amp;amp; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;arg1&lt;&#x2F;span&gt;&lt;span&gt;, Args&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;amp;&amp;amp;... &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;args &lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;   -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;decltype&lt;&#x2F;span&gt;&lt;span&gt;(
&lt;&#x2F;span&gt;&lt;span&gt;         (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;std::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;forward&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;&amp;lt; Arg1 &amp;gt;(arg1)&lt;&#x2F;span&gt;&lt;span&gt;.*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;std&lt;&#x2F;span&gt;&lt;span&gt;::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;forward&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span&gt; MemPtr Obj::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;* &amp;gt;&lt;&#x2F;span&gt;&lt;span&gt;(invocable))
&lt;&#x2F;span&gt;&lt;span&gt;                                             ( &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;std::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;forward&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;&amp;lt; Args &amp;gt;(args)&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;... &lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;   )
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;std::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;forward&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;&amp;lt; Arg1 &amp;gt;(arg1)&lt;&#x2F;span&gt;&lt;span&gt;.*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;std&lt;&#x2F;span&gt;&lt;span&gt;::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;forward&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span&gt; MemPtr Obj::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;* &amp;gt;&lt;&#x2F;span&gt;&lt;span&gt;(invocable))
&lt;&#x2F;span&gt;&lt;span&gt;                                             ( &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;std::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;forward&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;&amp;lt; Args &amp;gt;(args)&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;... &lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Honestly, the main difficulty becomes formatting and indentation: I find nothing is satisfactory.
I should probably just let &lt;a href=&quot;https:&#x2F;&#x2F;clang.llvm.org&#x2F;docs&#x2F;ClangFormat.html&quot;&gt;ClangFormat&lt;&#x2F;a&gt; do it for me.
In any case, there are two things worth noticing.
The first is the position of the &lt;code&gt;...&lt;&#x2F;code&gt; when forwarding the parameter pack.
If you are familiar with calling functions parameter packs, it is not surprising, but if you&#x27;ve never dealt with this kind of things, it can trip you at first.
The second is the use of &lt;code&gt;decay_t&lt;&#x2F;code&gt;&lt;sup id=&quot;ftntref:7&quot;&gt;&lt;a href=&quot;#ftnt:7&quot;&gt;7&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt; in the &lt;code&gt;std::is_base_of&lt;&#x2F;code&gt; SFINAE condition in the second overload.
This is now necessary because the type &lt;code&gt;Arg1&lt;&#x2F;code&gt; can now be deduced to be a reference and the predicate will be &lt;code&gt;false&lt;&#x2F;code&gt; in that case if you do not remove the reference modifier to the type.
Essentially:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; style=&quot;background-color:#1d1f21;color:#c5c8c6;&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;&lt;span&gt;std::is_base_of&amp;lt; Arg1, Arg1&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;amp;            &lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;::value &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;== &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;false
&lt;&#x2F;span&gt;&lt;span&gt;std::is_base_of&amp;lt; Arg1, decay_t&amp;lt; Arg1&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;amp; &lt;&#x2F;span&gt;&lt;span&gt;&amp;gt; &amp;gt;::value &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;== &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;true
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Other than those two little difficulties, there is nothing very surprising about the modifications to the original function if you are already familiar with perfect forwarding.
If you are not, go read up on it (I have a &lt;a href=&quot;https:&#x2F;&#x2F;ghlecl.github.io&#x2F;posts&#x2F;rvalue_references_in_cxx&#x2F;&quot;&gt;past blog post&lt;&#x2F;a&gt; about rvalues and perfect forwarding).&lt;&#x2F;p&gt;
&lt;h3 id=&quot;noexcept_specification&quot;&gt;noexcept specification&lt;&#x2F;h3&gt;
&lt;p&gt;One final thing that I looked into is getting the &lt;code&gt;noexcept&lt;&#x2F;code&gt; specifier correct using the &lt;code&gt;noexcept&lt;&#x2F;code&gt; operator.
Here is what it looks like for the same cases perfect forwarding was explored with:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; style=&quot;background-color:#1d1f21;color:#c5c8c6;&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;template&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;typename&lt;&#x2F;span&gt;&lt;span&gt; Invocable, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;typename&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;...&lt;&#x2F;span&gt;&lt;span&gt; Args &amp;gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;auto &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;invoke&lt;&#x2F;span&gt;&lt;span&gt;( Invocable&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;amp;&amp;amp; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;invocable&lt;&#x2F;span&gt;&lt;span&gt;, Args&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;amp;&amp;amp;... &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;args &lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;noexcept&lt;&#x2F;span&gt;&lt;span&gt;(
&lt;&#x2F;span&gt;&lt;span&gt;      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;noexcept&lt;&#x2F;span&gt;&lt;span&gt;(
&lt;&#x2F;span&gt;&lt;span&gt;         &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;std::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;forward&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;&amp;lt;Invocable&amp;gt;(invocable)&lt;&#x2F;span&gt;&lt;span&gt;( &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;std::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;forward&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;&amp;lt;Args&amp;gt;(args)&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;... &lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;      )
&lt;&#x2F;span&gt;&lt;span&gt;   )
&lt;&#x2F;span&gt;&lt;span&gt;   -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;decltype&lt;&#x2F;span&gt;&lt;span&gt;(
&lt;&#x2F;span&gt;&lt;span&gt;         &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;std::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;forward&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;&amp;lt;Invocable&amp;gt;(invocable)&lt;&#x2F;span&gt;&lt;span&gt;( &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;std::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;forward&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;&amp;lt;Args&amp;gt;(args)&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;... &lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;   )
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;std::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;forward&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;&amp;lt;Invocable&amp;gt;(invocable)&lt;&#x2F;span&gt;&lt;span&gt;( &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;std::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;forward&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;&amp;lt;Args&amp;gt;(args)&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;... &lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;template&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;typename&lt;&#x2F;span&gt;&lt;span&gt; MemPtr,
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;typename&lt;&#x2F;span&gt;&lt;span&gt; Obj,
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;typename&lt;&#x2F;span&gt;&lt;span&gt; Arg1,
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;typename&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;...&lt;&#x2F;span&gt;&lt;span&gt; Args,
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;typename &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; enable_if_t&amp;lt; std::is_base_of&amp;lt; Obj, decay_t&amp;lt;Arg1&amp;gt; &amp;gt;::value &amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;typename &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; enable_if_t&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span&gt; std::is_member_function_pointer&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span&gt; MemPtr Obj::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;* &lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;::value &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;auto &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;invoke&lt;&#x2F;span&gt;&lt;span&gt;( MemPtr Obj::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;*&amp;amp;&amp;amp; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;invocable&lt;&#x2F;span&gt;&lt;span&gt;, Arg1&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;amp;&amp;amp; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;arg1&lt;&#x2F;span&gt;&lt;span&gt;, Args&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;amp;&amp;amp;... &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;args &lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;noexcept&lt;&#x2F;span&gt;&lt;span&gt;(
&lt;&#x2F;span&gt;&lt;span&gt;      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;noexcept&lt;&#x2F;span&gt;&lt;span&gt;(
&lt;&#x2F;span&gt;&lt;span&gt;         (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;std::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;forward&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;&amp;lt; Arg1 &amp;gt;(arg1)&lt;&#x2F;span&gt;&lt;span&gt;.*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;std&lt;&#x2F;span&gt;&lt;span&gt;::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;forward&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span&gt; MemPtr Obj::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;* &amp;gt;&lt;&#x2F;span&gt;&lt;span&gt;(invocable))
&lt;&#x2F;span&gt;&lt;span&gt;                                             ( &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;std::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;forward&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;&amp;lt; Args &amp;gt;(args)&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;... &lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;      )
&lt;&#x2F;span&gt;&lt;span&gt;   )
&lt;&#x2F;span&gt;&lt;span&gt;   -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;decltype&lt;&#x2F;span&gt;&lt;span&gt;(
&lt;&#x2F;span&gt;&lt;span&gt;         (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;std::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;forward&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;&amp;lt; Arg1 &amp;gt;(arg1)&lt;&#x2F;span&gt;&lt;span&gt;.*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;std&lt;&#x2F;span&gt;&lt;span&gt;::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;forward&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span&gt; MemPtr Obj::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;* &amp;gt;&lt;&#x2F;span&gt;&lt;span&gt;(invocable))
&lt;&#x2F;span&gt;&lt;span&gt;                                             ( &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;std::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;forward&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;&amp;lt; Args &amp;gt;(args)&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;... &lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;   )
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;std::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;forward&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;&amp;lt; Arg1 &amp;gt;(arg1)&lt;&#x2F;span&gt;&lt;span&gt;.*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;std&lt;&#x2F;span&gt;&lt;span&gt;::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;forward&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span&gt; MemPtr Obj::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;* &amp;gt;&lt;&#x2F;span&gt;&lt;span&gt;(invocable))
&lt;&#x2F;span&gt;&lt;span&gt;                                             ( &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;std::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;forward&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;&amp;lt; Args &amp;gt;(args)&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;... &lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;and now the indentation is really screwed up.
Another annoying thing that the reader might notice is that you basically have to write the implementation of the function thrice (see &lt;a href=&quot;https:&#x2F;&#x2F;twitter.com&#x2F;supahvee1234&quot;&gt;Vittorio Romeo&lt;&#x2F;a&gt;&#x27;s &lt;a href=&quot;https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=I3T4lePH-yA&quot;&gt;lightning talk about that&lt;&#x2F;a&gt;).
Not all that DRY, but hey!&lt;&#x2F;p&gt;
&lt;h2 id=&quot;Beyond_std::invoke&quot;&gt;Beyond &lt;code&gt;std::invoke&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;I am sure there are other things that could be improved in this implementation
of &lt;code&gt;invoke&lt;&#x2F;code&gt;.
For instance, from Vittorio&#x27;s talk, I realized that my implementation is not &lt;code&gt;constexpr&lt;&#x2F;code&gt; friendly.
That said, while it might not be a conforming implementation, it is a working one, and it is a more general version of the &lt;code&gt;apply_on&lt;&#x2F;code&gt; template in my motivating use case (which, as I said, was &lt;em&gt;vaguely&lt;&#x2F;em&gt; related).
Writing this implementation made me learn a lot.&lt;&#x2F;p&gt;
&lt;p&gt;Generic function calling in C++ is a large subject where inspiration could come from other languages as well.
For instance, at C++Now 2018, &lt;a href=&quot;https:&#x2F;&#x2F;twitter.com&#x2F;CppSage&quot;&gt;Matt Calabrese&lt;&#x2F;a&gt; presented a library (&lt;a href=&quot;https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=pKVCB_Bzalk&quot;&gt;Argot&lt;&#x2F;a&gt;) he is working on which seeks to provide better language ergonomics for invoking &lt;em&gt;things&lt;&#x2F;em&gt;, any &lt;em&gt;callable&lt;&#x2F;em&gt;.
Already, in 2016, he was making a &lt;a href=&quot;http:&#x2F;&#x2F;open-std.org&#x2F;JTC1&#x2F;SC22&#x2F;WG21&#x2F;docs&#x2F;papers&#x2F;2016&#x2F;p0376r0.html&quot;&gt;proposal&lt;&#x2F;a&gt; to the standards committee about unifying &lt;code&gt;std::invoke&lt;&#x2F;code&gt;, &lt;code&gt;std::apply&lt;&#x2F;code&gt;, and &lt;code&gt;std::visit&lt;&#x2F;code&gt;, and then 2017, again at C++ Now, he was giving a talk about the beginnings of a similar library (if not the same library) called &lt;a href=&quot;https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=Fjw7NjndQ50&amp;amp;list=PLTXJhw4sOAviW1OdRgPlxU5m5GU2UzJiJ&quot;&gt;Call&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;In this work, he not only explores how to provide a more uniform way to invoke things, but he also explores, amongst other things, argument unpacking from tuples much like in Python.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;Python&quot; style=&quot;background-color:#1d1f21;color:#c5c8c6;&quot; class=&quot;language-Python &quot;&gt;&lt;code class=&quot;language-Python&quot; data-lang=&quot;Python&quot;&gt;&lt;span style=&quot;color:#969896;&quot;&gt;# Function taking 4 arguments and printing them
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;def &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;fn&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;a&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;b&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;c&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;d&lt;&#x2F;span&gt;&lt;span&gt;):
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;print( a, b, c, d )
&lt;&#x2F;span&gt;&lt;span&gt; 
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;my_list &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span&gt;[ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;3&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;4 &lt;&#x2F;span&gt;&lt;span&gt;] 
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#969896;&quot;&gt;# Unpacking list into four arguments
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;fn&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;( &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;my_list )
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;From his 2018 C++ Now talk, I gather he is not ready to submit such an addition to the language and&#x2F;or the standard library at this point, but I find his ideas interesting and will try to stay informed (although I am far from that level of C++).&lt;&#x2F;p&gt;
&lt;p&gt;Anyhow, I hope this post was of some interest. As Jon Kalb would say: safe coding!&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;Acknowledgments&quot;&gt;Acknowledgments&lt;&#x2F;h2&gt;
&lt;p&gt;I would like to thank &lt;a href=&quot;https:&#x2F;&#x2F;twitter.com&#x2F;sephdebusser&quot;&gt;Seph De Busser&lt;&#x2F;a&gt; for taking the time to read this post before I published it and reassuring me that the mistakes in there were not too bad. 🙂&lt;&#x2F;p&gt;
&lt;h2 id=&quot;Notes&quot;&gt;Notes&lt;&#x2F;h2&gt;
&lt;p id=&quot;ftnt:1&quot;&gt;&lt;sup&gt;[1]&lt;&#x2F;sup&gt;&amp;nbsp;I think &lt;code&gt;INVOKE&lt;&#x2F;code&gt; is not strictly the same as &lt;code&gt;std::invoke&lt;&#x2F;code&gt;, although I find this confusing.
As far as I can tell, &lt;code&gt;INVOKE&lt;&#x2F;code&gt; was in the standard before &lt;code&gt;std::invoke&lt;&#x2F;code&gt; and represents the idea of calling something.
&lt;code&gt;std::invoke&lt;&#x2F;code&gt; is just the library implementation of this idea.
I could not find an appropriate name for such an entity.&amp;nbsp;&lt;a href=&quot;#ftntref:1&quot;&gt;&amp;#8617;&amp;#65038;&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p id=&quot;ftnt:2&quot;&gt;&lt;sup&gt;[2]&lt;&#x2F;sup&gt;&amp;nbsp;For SFINAE, it would be easy to add a third defaulted template parameter after the parameter pack in the original definition of the previous section.
Something like:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; style=&quot;background-color:#1d1f21;color:#c5c8c6;&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;template&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;typename&lt;&#x2F;span&gt;&lt;span&gt; Invocable,
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;typename&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;...&lt;&#x2F;span&gt;&lt;span&gt; Args,
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;typename &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; enable_if_t&amp;lt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;!&lt;&#x2F;span&gt;&lt;span&gt;std::is_member_pointer&amp;lt; decay_t&amp;lt; Invocable &amp;gt; &amp;gt;::value &amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;auto &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;invoke&lt;&#x2F;span&gt;&lt;span&gt;( Invocable &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;invocable&lt;&#x2F;span&gt;&lt;span&gt;, Args&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;... &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;args &lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;   -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;decltype&lt;&#x2F;span&gt;&lt;span&gt;( &lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;invocable&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;( args&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;... &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;) &lt;&#x2F;span&gt;&lt;span&gt;) {
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;invocable&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;( args&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;... &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;)&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;I would have put it in this overload instead of putting the opposite verification in every other overload.
If you are wondering why the &lt;code&gt;decay_t&lt;&#x2F;code&gt; is used, see the main text.&amp;nbsp;&lt;a href=&quot;#ftntref:2&quot;&gt;&amp;#8617;&amp;#65038;&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p id=&quot;ftnt:3&quot;&gt;&lt;sup&gt;[3]&lt;&#x2F;sup&gt;&amp;nbsp;In the following function template declaration:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; style=&quot;background-color:#1d1f21;color:#c5c8c6;&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;template&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;typename&lt;&#x2F;span&gt;&lt;span&gt; MemPtr, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;typename&lt;&#x2F;span&gt;&lt;span&gt; Obj, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;typename&lt;&#x2F;span&gt;&lt;span&gt; Arg1, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;typename&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;...&lt;&#x2F;span&gt;&lt;span&gt; Args &amp;gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;auto &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;invoke&lt;&#x2F;span&gt;&lt;span&gt;( MemPtr Obj::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;* &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;invocable&lt;&#x2F;span&gt;&lt;span&gt;, Arg1 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;arg1&lt;&#x2F;span&gt;&lt;span&gt;, Args&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;... &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;args &lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;the type the pointer points into (&lt;code&gt;Obj&lt;&#x2F;code&gt;) and the type of the object the pointer will be invoked on (&lt;code&gt;Arg1&lt;&#x2F;code&gt;) are not necessarily the same, since a derived object could be used with &lt;code&gt;invoke&lt;&#x2F;code&gt;.
Thus, they must be different template parameters to allow the compiler to deduce different types.&amp;nbsp;&lt;a href=&quot;#ftntref:3&quot;&gt;&amp;#8617;&amp;#65038;&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p id=&quot;ftnt:4&quot;&gt;&lt;sup&gt;[4]&lt;&#x2F;sup&gt;&amp;nbsp;One might have noticed that I said I was limiting myself to C++11, but I use the C++14 &lt;code&gt;enable_if_t&lt;&#x2F;code&gt; and &lt;code&gt;decay_t&lt;&#x2F;code&gt; helpers of &lt;code&gt;std::enable_if&lt;&#x2F;code&gt; and &lt;code&gt;std::decay&lt;&#x2F;code&gt;.
Those helpers are so useful that I usually define and use them even in C++11.
The &lt;code&gt;_v&lt;&#x2F;code&gt; helpers cannot be defined in C++11, but the &lt;code&gt;_t&lt;&#x2F;code&gt; helpers work perfectly.
The two of interest in this code can be defined like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; style=&quot;background-color:#1d1f21;color:#c5c8c6;&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;template&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;bool&lt;&#x2F;span&gt;&lt;span&gt; B, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;typename&lt;&#x2F;span&gt;&lt;span&gt; T &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;void &lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;using &lt;&#x2F;span&gt;&lt;span&gt;enable_if_t &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;typename&lt;&#x2F;span&gt;&lt;span&gt; std::enable_if&amp;lt; B, T &amp;gt;::type;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;template&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;typename&lt;&#x2F;span&gt;&lt;span&gt; T &amp;gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;using &lt;&#x2F;span&gt;&lt;span&gt;decay_t &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;typename&lt;&#x2F;span&gt;&lt;span&gt; std::decay_t&amp;lt; T &amp;gt;::type;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&amp;nbsp;&lt;a href=&quot;#ftntref:4&quot;&gt;&amp;#8617;&amp;#65038;&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p id=&quot;ftnt:5&quot;&gt;&lt;sup&gt;[5]&lt;&#x2F;sup&gt;&amp;nbsp;Provided you use the right semantics, e.g. you &lt;code&gt;std::move&lt;&#x2F;code&gt; the &lt;code&gt;std::unique_ptr&lt;&#x2F;code&gt;.&amp;nbsp;&lt;a href=&quot;#ftntref:5&quot;&gt;&amp;#8617;&amp;#65038;&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p id=&quot;ftnt:6&quot;&gt;&lt;sup&gt;[6]&lt;&#x2F;sup&gt;&amp;nbsp;I still prefer the previous term... sigh.&amp;nbsp;&lt;a href=&quot;#ftntref:6&quot;&gt;&amp;#8617;&amp;#65038;&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p id=&quot;ftnt:7&quot;&gt;&lt;sup&gt;[7]&lt;&#x2F;sup&gt;&amp;nbsp;See note 4.&amp;nbsp;&lt;a href=&quot;#ftntref:7&quot;&gt;&amp;#8617;&amp;#65038;&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
</content>
  </entry>
  <entry xml:lang="en">
    <title>Python&#x27;s range in C++</title>
    <author>codeattempts@gmail.com</author>
    <published>2018-08-05</published>
    <updated>2018-08-05</updated>
    <link href="https://ghlecl.github.io/posts/range_function/" type="text/html"/>
    <id>https://ghlecl.github.io/posts/range_function/</id>
    <summary>
   Exploring loops: Python's range in C++
In spite of what Sean Parent would like (i.e. no raw loops ;-) ), loops are a common control flow in programming.
So common that most languages have more than one loop syntax:
for loop,
while loop,
do while loop...
Given their prevalence, loops might seem uninteresting, but when I decided to look into
creating a range function1 for C++ which would behave like Python's
range object, I learned a thing or two and decided</summary>
    <content>&lt;h1 id=&quot;Exploring_loops:_Python&#x27;s_range_in_C++&quot;&gt;Exploring loops: Python&#x27;s range in C++&lt;&#x2F;h1&gt;
&lt;p&gt;In spite of what Sean Parent would like (i.e. &lt;a href=&quot;https:&#x2F;&#x2F;channel9.msdn.com&#x2F;Events&#x2F;GoingNative&#x2F;2013&#x2F;Cpp-Seasoning&quot;&gt;no raw loops&lt;&#x2F;a&gt; ;-) ), loops are a common control flow in programming.
So common that most languages have more than one &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Control_flow#Loops&quot;&gt;loop&lt;&#x2F;a&gt; syntax:
&lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;For_loop&quot;&gt;for loop&lt;&#x2F;a&gt;,
&lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;While_loop&quot;&gt;while loop&lt;&#x2F;a&gt;,
&lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Do_while_loop&quot;&gt;do while loop&lt;&#x2F;a&gt;...
Given their prevalence, loops might seem uninteresting, but when I decided to look into
creating a &lt;code&gt;range&lt;&#x2F;code&gt; function&lt;sup id=&quot;ftntref:1&quot;&gt;&lt;a href=&quot;#ftnt:1&quot;&gt;1&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt; for C++ which would behave like Python&#x27;s
&lt;code&gt;range&lt;&#x2F;code&gt; object, I learned a thing or two and decided to write them down.&lt;&#x2F;p&gt;
&lt;p&gt;For the impatient, the code I came up with is available on &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;ghlecl&#x2F;range_fn&quot;&gt;Github&lt;&#x2F;a&gt;.  It was inspired by [Anthony William&#x27;s post](https:&#x2F;&#x2F;www.justsoftwaresolutions.co.uk&#x2F;cplusplus&#x2F;
generating_sequences.html) on the subject.
I will put the same disclaimer here that Anthony put in his post:&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;...hopefully people will find this instructive, if not useful.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;As he points out, there are more complete alternatives (e.g. the &lt;a href=&quot;https:&#x2F;&#x2F;www.boost.org&#x2F;doc&#x2F;libs&#x2F;1_67_0&#x2F;libs&#x2F;range&#x2F;doc&#x2F;html&#x2F;index.html&quot;&gt;Boost range library&lt;&#x2F;a&gt;) with a probably higher quality of implementation (at the price of bringing the whole of Boost into your project if you do not already depend on it).&lt;sup id=&quot;ftntref:2&quot;&gt;&lt;a href=&quot;#ftnt:2&quot;&gt;2&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;&lt;&#x2F;p&gt;
&lt;p&gt;This turned out to be quite a longer blog entry than I anticipated.  Consider yourself warned!&lt;&#x2F;p&gt;
&lt;h2 id=&quot;Iterating_over_containers&quot;&gt;Iterating over containers&lt;&#x2F;h2&gt;
&lt;p&gt;Out of the C++11 (and beyond) features, &lt;a href=&quot;http:&#x2F;&#x2F;en.cppreference.com&#x2F;w&#x2F;cpp&#x2F;language&#x2F;range-for&quot;&gt;range-based for loop&lt;&#x2F;a&gt; is a favorite of mine.
Prior to that being available, if you wanted to iterate over every element of a container, the alternatives were rather verbose.
Amongst others, there is the C style for loop using the &lt;a href=&quot;http:&#x2F;&#x2F;en.cppreference.com&#x2F;w&#x2F;cpp&#x2F;iterator&quot;&gt;iterators&lt;&#x2F;a&gt; that can be retrieved by the &lt;code&gt;begin()&lt;&#x2F;code&gt; and &lt;code&gt;end()&lt;&#x2F;code&gt; functions of the STL
containers:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; style=&quot;background-color:#1d1f21;color:#c5c8c6;&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;&lt;span&gt;std::list&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;double&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt; lst;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#969896;&quot;&gt;&#x2F;&#x2F; ... fill list somehow ...
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;typedef&lt;&#x2F;span&gt;&lt;span&gt; std::list&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;double&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;::iterator lst_iter;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;for&lt;&#x2F;span&gt;&lt;span&gt;( lst_iter beg &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; lst.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;begin&lt;&#x2F;span&gt;&lt;span&gt;(), end &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; lst.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;end&lt;&#x2F;span&gt;&lt;span&gt;(); beg &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;!=&lt;&#x2F;span&gt;&lt;span&gt; end; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;++&lt;&#x2F;span&gt;&lt;span&gt;beg ) {
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;double&lt;&#x2F;span&gt;&lt;span&gt; cur &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;= *&lt;&#x2F;span&gt;&lt;span&gt;beg;
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#969896;&quot;&gt;&#x2F;&#x2F; use cur (or use *beg directly everywhere)
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;or the &lt;a href=&quot;http:&#x2F;&#x2F;en.cppreference.com&#x2F;w&#x2F;cpp&#x2F;algorithm&#x2F;for_each&quot;&gt;&lt;code&gt;for_each&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; algorithm to which one provides a function object to apply to every element of the container:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; style=&quot;background-color:#1d1f21;color:#c5c8c6;&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;&lt;span&gt;std::list&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;double&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt; lst;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#969896;&quot;&gt;&#x2F;&#x2F; ... fill list somehow ...
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span&gt;my_op {
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;void &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;operator()&lt;&#x2F;span&gt;&lt;span&gt;( &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;double &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;item &lt;&#x2F;span&gt;&lt;span&gt;) {
&lt;&#x2F;span&gt;&lt;span&gt;      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#969896;&quot;&gt;&#x2F;&#x2F; use item
&lt;&#x2F;span&gt;&lt;span&gt;   }
&lt;&#x2F;span&gt;&lt;span&gt;};
&lt;&#x2F;span&gt;&lt;span&gt;std::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;for_each&lt;&#x2F;span&gt;&lt;span&gt;( lst.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;begin&lt;&#x2F;span&gt;&lt;span&gt;(), lst.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;end&lt;&#x2F;span&gt;&lt;span&gt;(), &lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;my_op&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;() &lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Those work, but they have a few drawbacks, amongst which you can find 1) being verbose &lt;del&gt;and 2) not working with built-in arrays&lt;&#x2F;del&gt;&lt;sup id=&quot;ftntref:3&quot;&gt;&lt;a href=&quot;#ftnt:3&quot;&gt;3&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;.
Compare that to other languages where the syntax for iterating over a container is more concise and more universally applied, like Python for instance:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;python&quot; style=&quot;background-color:#1d1f21;color:#c5c8c6;&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span&gt;a &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span&gt;[ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;3&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;4 &lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;x &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;in &lt;&#x2F;span&gt;&lt;span&gt;a:
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#969896;&quot;&gt;#use x
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;and you can see a difference, at a minimum in verbosity.
With range-based for loops, C++ closes the gap.
The syntax, introduced in C++11, is terser and works with both containers and built-in arrays (which is what I show in the example below).
Here is what it looks like, which is much closer to the Python for loop:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; style=&quot;background-color:#1d1f21;color:#c5c8c6;&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;int&lt;&#x2F;span&gt;&lt;span&gt; ints[] &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span&gt;{ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;3&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;4 &lt;&#x2F;span&gt;&lt;span&gt;};
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;for&lt;&#x2F;span&gt;&lt;span&gt;( &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;int&lt;&#x2F;span&gt;&lt;span&gt; x &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;:&lt;&#x2F;span&gt;&lt;span&gt; ints ) {
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#969896;&quot;&gt;&#x2F;&#x2F; use x
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;On top of the afore mentioned properties, and probably even more importantly, this construct is much more expressive: it clearly says that you want to use every element of the container.
C++ being what it is, of course, the syntax gives you more control than in Python (at the expense of more complexity some would argue): you can specify if you want a copy of each object in the container, a reference to them, or a const reference to them.
Thus, all the following declarations (iterating over the same range as the previous example) would be valid:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; style=&quot;background-color:#1d1f21;color:#c5c8c6;&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;for&lt;&#x2F;span&gt;&lt;span&gt;( &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;int&lt;&#x2F;span&gt;&lt;span&gt; x &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;:&lt;&#x2F;span&gt;&lt;span&gt; lst ) { &lt;&#x2F;span&gt;&lt;span style=&quot;color:#969896;&quot;&gt;&#x2F;* body *&#x2F; &lt;&#x2F;span&gt;&lt;span&gt;}        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#969896;&quot;&gt;&#x2F;&#x2F; copy
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;for&lt;&#x2F;span&gt;&lt;span&gt;( &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;int&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt; x &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;:&lt;&#x2F;span&gt;&lt;span&gt; lst ) { &lt;&#x2F;span&gt;&lt;span style=&quot;color:#969896;&quot;&gt;&#x2F;* body *&#x2F; &lt;&#x2F;span&gt;&lt;span&gt;}       &lt;&#x2F;span&gt;&lt;span style=&quot;color:#969896;&quot;&gt;&#x2F;&#x2F; reference
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;for&lt;&#x2F;span&gt;&lt;span&gt;( &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;int const&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt; x &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;:&lt;&#x2F;span&gt;&lt;span&gt; lst ) { &lt;&#x2F;span&gt;&lt;span style=&quot;color:#969896;&quot;&gt;&#x2F;* body *&#x2F; &lt;&#x2F;span&gt;&lt;span&gt;} &lt;&#x2F;span&gt;&lt;span style=&quot;color:#969896;&quot;&gt;&#x2F;&#x2F; const reference
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;That is to say that in C++, you can express that you want to iterate over all the items &lt;em&gt;and&lt;&#x2F;em&gt; whether you intend to modify them or not.&lt;&#x2F;p&gt;
&lt;p&gt;One condition to keep in mind is that in the constructs above, the loop variable type (&lt;code&gt;int&lt;&#x2F;code&gt; in the example above) must be initializable from the type in the container&#x2F;array you want to iterate over.
This can lead to some errors:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; style=&quot;background-color:#1d1f21;color:#c5c8c6;&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;int&lt;&#x2F;span&gt;&lt;span&gt; ints[] &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span&gt;{ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;3&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;4 &lt;&#x2F;span&gt;&lt;span&gt;};
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;for&lt;&#x2F;span&gt;&lt;span&gt;( &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;long&lt;&#x2F;span&gt;&lt;span&gt; x &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;:&lt;&#x2F;span&gt;&lt;span&gt; ints ) {
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#969896;&quot;&gt;&#x2F;&#x2F; OK, a long can be initialized from an int
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;for&lt;&#x2F;span&gt;&lt;span&gt;( &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;long&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt; x &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;:&lt;&#x2F;span&gt;&lt;span&gt; ints ) {
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#969896;&quot;&gt;&#x2F;&#x2F; Won&amp;#39;t compile: long&amp;amp; can&amp;#39;t be &amp;quot;initialized from&amp;quot;&#x2F;&amp;quot;bind to&amp;quot; an int
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;That said, unless you really need to specify the type, it is usually recommended
that you use &lt;a href=&quot;http:&#x2F;&#x2F;en.cppreference.com&#x2F;w&#x2F;cpp&#x2F;language&#x2F;auto&quot;&gt;C++11&#x27;s auto specifier&lt;&#x2F;a&gt; to
get type deduction on the loop variable.
That would look like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; style=&quot;background-color:#1d1f21;color:#c5c8c6;&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;int&lt;&#x2F;span&gt;&lt;span&gt; ints[] &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span&gt;{ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;3&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;4 &lt;&#x2F;span&gt;&lt;span&gt;};
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;for&lt;&#x2F;span&gt;&lt;span&gt;( &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;auto&lt;&#x2F;span&gt;&lt;span&gt; x &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;:&lt;&#x2F;span&gt;&lt;span&gt; ints ) {
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#969896;&quot;&gt;&#x2F;&#x2F; use x
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;which eschews the problems of type mismatch mentioned above.
Even with this type deduction, the type decoration can be used so that all those syntaxes are
correct and should (usually) have the expected behavior:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; style=&quot;background-color:#1d1f21;color:#c5c8c6;&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;for&lt;&#x2F;span&gt;&lt;span&gt;( &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;auto&lt;&#x2F;span&gt;&lt;span&gt; x &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;:&lt;&#x2F;span&gt;&lt;span&gt; lst ) { &lt;&#x2F;span&gt;&lt;span style=&quot;color:#969896;&quot;&gt;&#x2F;* body *&#x2F; &lt;&#x2F;span&gt;&lt;span&gt;}        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#969896;&quot;&gt;&#x2F;&#x2F; copy
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;for&lt;&#x2F;span&gt;&lt;span&gt;( &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;auto&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt; x &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;:&lt;&#x2F;span&gt;&lt;span&gt; lst ) { &lt;&#x2F;span&gt;&lt;span style=&quot;color:#969896;&quot;&gt;&#x2F;* body *&#x2F; &lt;&#x2F;span&gt;&lt;span&gt;}       &lt;&#x2F;span&gt;&lt;span style=&quot;color:#969896;&quot;&gt;&#x2F;&#x2F; reference
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;for&lt;&#x2F;span&gt;&lt;span&gt;( &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;auto const&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt; x &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;:&lt;&#x2F;span&gt;&lt;span&gt; lst ) { &lt;&#x2F;span&gt;&lt;span style=&quot;color:#969896;&quot;&gt;&#x2F;* body *&#x2F; &lt;&#x2F;span&gt;&lt;span&gt;} &lt;&#x2F;span&gt;&lt;span style=&quot;color:#969896;&quot;&gt;&#x2F;&#x2F; const reference
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;which can have the advantage that if you change the type in the container, you do
not have to change the type in the loop.
There are some more caveats, especially related to lifetime of temporary objects and accessibility, but the information here is enough in most cases.
If you want more information on type deduction in range-based for loops, see &lt;a href=&quot;https:&#x2F;&#x2F;blog.petrzemek.net&#x2F;2016&#x2F;08&#x2F;17&#x2F;auto-type-deduction-in-range-based-for-loops&#x2F;&quot;&gt;this article&lt;&#x2F;a&gt;
by Petr Zemek.&lt;&#x2F;p&gt;
&lt;p&gt;One limitation of the C++ syntax compared to Python&#x27;s is that there is no way to limit the iteration to a sub-range of the container.
For this, you still need to use the previous constructs.
C++11 made it easier to use these constructs with &lt;a href=&quot;http:&#x2F;&#x2F;en.cppreference.com&#x2F;w&#x2F;cpp&#x2F;language&#x2F;auto&quot;&gt;auto type deduction&lt;&#x2F;a&gt;, but allowing iteration over a portion of the container is still missed, if you ask me, because if it were available, it would mean the same syntax could be used for any iteration over a container.
In future versions of the standard, ranges (which are a completely different concept from the function I am writing in what follows... naming things is hard) or view&#x2F;span types might provide a better alternative, but for now nothing is provided in the standard to iterate over a subrange.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;Iterating_over_indices&quot;&gt;Iterating over indices&lt;&#x2F;h2&gt;
&lt;p&gt;Containers (unfortunately or not, depending who you ask), are not the only thing we need to loop over.
Iterating over indices can be necessary, and for that, Python has an easy way of creating a temporary &amp;quot;container&amp;quot; that will represent a range of integers.
Using this container, the same syntax that was used to iterate over lists can easily be applied to index iteration:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;python&quot; style=&quot;background-color:#1d1f21;color:#c5c8c6;&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span&gt;a &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span&gt;[ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;3&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;4 &lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;x &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;in &lt;&#x2F;span&gt;&lt;span&gt;a:
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#969896;&quot;&gt;# use x
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;x &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;in &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;range( &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;5 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;)&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#969896;&quot;&gt;# use x
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;As mentioned, the &lt;a href=&quot;https:&#x2F;&#x2F;docs.python.org&#x2F;3&#x2F;library&#x2F;stdtypes.html?highlight=range#range&quot;&gt;&lt;code&gt;range&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; object created using this syntax will generate the sequence of integers for the loop.
This object can be initialized with a single &lt;code&gt;stop&lt;&#x2F;code&gt; value (as shown), but can also be declared with a &lt;code&gt;start&lt;&#x2F;code&gt;&#x2F;&lt;code&gt;stop&lt;&#x2F;code&gt; pair or a &lt;code&gt;start&lt;&#x2F;code&gt;&#x2F;&lt;code&gt;stop&lt;&#x2F;code&gt;&#x2F;&lt;code&gt;step&lt;&#x2F;code&gt; triplet.
It will go from &lt;code&gt;start&lt;&#x2F;code&gt; to &lt;code&gt;stop&lt;&#x2F;code&gt; (with &lt;code&gt;stop&lt;&#x2F;code&gt; being exclusive, i.e. the interval is&lt;code&gt;[start, stop[&lt;&#x2F;code&gt;) in steps of &lt;code&gt;step&lt;&#x2F;code&gt;.  The default value of &lt;code&gt;start&lt;&#x2F;code&gt; is zero and the default value of &lt;code&gt;step&lt;&#x2F;code&gt; is one, which is why you can use the  variations with a single parameter or a &lt;code&gt;start&lt;&#x2F;code&gt;&#x2F;&lt;code&gt;stop&lt;&#x2F;code&gt; pair (which are not strictly speaking overloads, since Python does not allow that).
The parameter &lt;code&gt;step&lt;&#x2F;code&gt; can be negative.
The &lt;code&gt;start&lt;&#x2F;code&gt; value must be smaller than &lt;code&gt;stop&lt;&#x2F;code&gt; when &lt;code&gt;step&lt;&#x2F;code&gt; is positive and greater than &lt;code&gt;stop&lt;&#x2F;code&gt; when &lt;code&gt;step&lt;&#x2F;code&gt; is negative.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;python&quot; style=&quot;background-color:#1d1f21;color:#c5c8c6;&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;range( &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;10 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;)          &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&#x2F;&#x2F; &lt;&#x2F;span&gt;&lt;span&gt;iterates &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;from &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;0 &lt;&#x2F;span&gt;&lt;span&gt;to &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;9
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;range( &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;8&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;32 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;)       &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&#x2F;&#x2F; &lt;&#x2F;span&gt;&lt;span&gt;iterates &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;from &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;8 &lt;&#x2F;span&gt;&lt;span&gt;to &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;31
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;range( &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;10&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;5&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;-&lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;2 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;)   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&#x2F;&#x2F; &lt;&#x2F;span&gt;&lt;span&gt;iterates &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;from &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;10 &lt;&#x2F;span&gt;&lt;span&gt;to &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;5 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;in &lt;&#x2F;span&gt;&lt;span&gt;steps of &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;2
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;range( &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;10&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;5&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;2 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;)    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&#x2F;&#x2F; &lt;&#x2F;span&gt;&lt;span&gt;does nothing
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;In C++, neither the language nor its standard library provides such a facility.
Thus, to iterate over numbers, one falls back to the C style for loop:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; style=&quot;background-color:#1d1f21;color:#c5c8c6;&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;int&lt;&#x2F;span&gt;&lt;span&gt; ints[] &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span&gt;{ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;3&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;4 &lt;&#x2F;span&gt;&lt;span&gt;};
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;for&lt;&#x2F;span&gt;&lt;span&gt;( &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;auto&lt;&#x2F;span&gt;&lt;span&gt; x &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;:&lt;&#x2F;span&gt;&lt;span&gt; ints ) {
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#969896;&quot;&gt;&#x2F;&#x2F; use x
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;for&lt;&#x2F;span&gt;&lt;span&gt;( &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;int &lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;x&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;{&lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;}&lt;&#x2F;span&gt;&lt;span&gt;; x &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;lt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;5&lt;&#x2F;span&gt;&lt;span&gt;; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;++&lt;&#x2F;span&gt;&lt;span&gt;x ) {
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#969896;&quot;&gt;&#x2F;&#x2F; use x
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This is not actually so bad, but I like the consistency and expressiveness of Python&#x27;s &lt;code&gt;range&lt;&#x2F;code&gt; object.
In the end, although those reasons might not be the strongest arguments, they still drove me to think about (over-engineer maybe ;-) ) a construct similar to Python&#x27;s range in C++.
Admittedly, I was also simply a bit curious.
So, I set out to try and see if I could make a function or an object which could work with the range-based for loop much like Python&#x27;s &lt;code&gt;range&lt;&#x2F;code&gt; object.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;The_initial_&quot;design_goals&quot;&quot;&gt;The initial &amp;quot;design goals&amp;quot;&lt;&#x2F;h2&gt;
&lt;p&gt;Initially, I really wanted the behavior of Python&#x27;s &lt;code&gt;range&lt;&#x2F;code&gt; object.
I did not want to have to specify the type to iterate over (i.e. &lt;code&gt;short&lt;&#x2F;code&gt;, &lt;code&gt;int&lt;&#x2F;code&gt;, &lt;code&gt;long&lt;&#x2F;code&gt;,
&lt;code&gt;unsigned&lt;&#x2F;code&gt;...).
I wanted to be able to go in both directions, i.e. increment or decrement the counter.
I wanted to be able to specify the step size.
Basically, I wanted to be able to write loops over indices like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; style=&quot;background-color:#1d1f21;color:#c5c8c6;&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;for&lt;&#x2F;span&gt;&lt;span&gt;( &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;auto&lt;&#x2F;span&gt;&lt;span&gt; idx &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;range&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;( &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;6 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;) &lt;&#x2F;span&gt;&lt;span&gt;) { &lt;&#x2F;span&gt;&lt;span style=&quot;color:#969896;&quot;&gt;&#x2F;* body *&#x2F; &lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;for&lt;&#x2F;span&gt;&lt;span&gt;( &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;auto&lt;&#x2F;span&gt;&lt;span&gt; idx &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;range&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;( &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;7 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;) &lt;&#x2F;span&gt;&lt;span&gt;) { &lt;&#x2F;span&gt;&lt;span style=&quot;color:#969896;&quot;&gt;&#x2F;* body *&#x2F; &lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;for&lt;&#x2F;span&gt;&lt;span&gt;( &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;auto&lt;&#x2F;span&gt;&lt;span&gt; idx &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;range&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;( &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;38&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;13&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;-&lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;3 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;) &lt;&#x2F;span&gt;&lt;span&gt;) { &lt;&#x2F;span&gt;&lt;span style=&quot;color:#969896;&quot;&gt;&#x2F;* body *&#x2F; &lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;I also wanted it to be as close to the raw C style loop efficiency as possible, or the same even.
If there were a large performance penalty, this would probably be a show stopper: C++&#x27;s &amp;quot;&lt;em&gt;zero-cost abstractions&lt;&#x2F;em&gt;&amp;quot; mantra.
Actually, I would argue that usually, in C++, even in non performance critical code, a cost in performance has to be greatly outweighed by a gain in expressiveness for a feature&#x2F;proposal to even be considered, for better or worse.&lt;&#x2F;p&gt;
&lt;p&gt;So, with the following short list of goals:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Python &lt;code&gt;range&lt;&#x2F;code&gt; behavior,
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;start&lt;&#x2F;code&gt; &#x2F; &lt;code&gt;stop&lt;&#x2F;code&gt; &#x2F; &lt;code&gt;step&lt;&#x2F;code&gt;,&lt;&#x2F;li&gt;
&lt;li&gt;increment&#x2F;decrement,&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;no explicit type specification,&lt;&#x2F;li&gt;
&lt;li&gt;no runtime overhead,&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;I set out to build a function (or object) in C++.
In order to do that, I first had to understand the range-based for loop&lt;sup id=&quot;ftntref:4&quot;&gt;&lt;a href=&quot;#ftnt:4&quot;&gt;4&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;Writing_the_code&quot;&gt;Writing the code&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;Understanding_range-based_for&quot;&gt;Understanding range-based for&lt;&#x2F;h3&gt;
&lt;p&gt;As defined by the C++17 standard in section &lt;strong&gt;9.5.4 The range-based for statement ([&lt;em&gt;stmt.ranged&lt;&#x2F;em&gt;])&lt;&#x2F;strong&gt;, there are three main components to the range-based for construct:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;a range declaration,&lt;&#x2F;li&gt;
&lt;li&gt;a range initializer,&lt;&#x2F;li&gt;
&lt;li&gt;a loop statement.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;At its simplest, this is expressed like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; style=&quot;background-color:#1d1f21;color:#c5c8c6;&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;for&lt;&#x2F;span&gt;&lt;span&gt;( for_range_declaration &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;:&lt;&#x2F;span&gt;&lt;span&gt; for_range_initializer ) {
&lt;&#x2F;span&gt;&lt;span&gt;   loop_statement
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The &lt;code&gt;for_range_declaration&lt;&#x2F;code&gt; serves to create the variable that will be used in the loop.
The &lt;code&gt;for_range_initializer&lt;&#x2F;code&gt; is what is executed to get the range (can be as simple as what I would call &amp;quot;identity&amp;quot;, i.e. a range can directly be passed in).
The &lt;code&gt;loop_statement&lt;&#x2F;code&gt; is essentially the body of the for loop as with any C style for loop.
The code above will be used by the compiler to generate something similar to the regular iterator loop shown in the [first section]({{&amp;lt; ref &amp;quot;#iterating-over-containers&amp;quot; &amp;gt;}}).
The code looks like this&lt;sup id=&quot;ftntref:5&quot;&gt;&lt;a href=&quot;#ftnt:5&quot;&gt;5&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; style=&quot;background-color:#1d1f21;color:#c5c8c6;&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;auto&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;amp;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt; rng &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; for_range_initializer;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;auto&lt;&#x2F;span&gt;&lt;span&gt; beg &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;begin&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;( rng )&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;auto&lt;&#x2F;span&gt;&lt;span&gt; end &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;end&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;( rng )&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;for&lt;&#x2F;span&gt;&lt;span&gt;( ; beg &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;!=&lt;&#x2F;span&gt;&lt;span&gt; end; beg&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;++ &lt;&#x2F;span&gt;&lt;span&gt;) {
&lt;&#x2F;span&gt;&lt;span&gt;   for_range_declaration &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;= *&lt;&#x2F;span&gt;&lt;span&gt;beg;
&lt;&#x2F;span&gt;&lt;span&gt;   loop_statement
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;where the &lt;code&gt;begin&lt;&#x2F;code&gt; and &lt;code&gt;end&lt;&#x2F;code&gt; functions are not necessarily free functions, and can be the equivalent member functions of most STL containers.
Actually, if either a &lt;code&gt;begin&lt;&#x2F;code&gt; or an &lt;code&gt;end&lt;&#x2F;code&gt; member function are found in the range object, the pair of member functions is preferred as specified in the standard.
This unfortunately means that if an unrelated function exists in the class, but has one of those names, the class cannot be used in the range-based for statement even if an appropriate free functions pair is provided. This is true regardless of the access specifier of the function (i.e. a private function with such a name will still prevent the range-based for, even if a valid, non member pair of &lt;code&gt;begin&lt;&#x2F;code&gt;&#x2F;&lt;code&gt;end&lt;&#x2F;code&gt; functions exists).
I believe this might be changed in the future, but for the C++11 to C++17 versions of the standard, range based for is defined this way.&lt;&#x2F;p&gt;
&lt;p&gt;With the definition above in mind, the requirements to use a range-based for loop can then be summarized as having two related types: first, a range like type that has both a &lt;code&gt;begin&lt;&#x2F;code&gt; and an &lt;code&gt;end&lt;&#x2F;code&gt; function (either member, or discoverable through ADL, i.e. in a related namespace) and second, an iterator like type which can be compared for inequality, incremented and dereferenced, i.e. implements the &lt;code&gt;operator!=&lt;&#x2F;code&gt;, &lt;code&gt;operator++&lt;&#x2F;code&gt;, and &lt;code&gt;operator*&lt;&#x2F;code&gt; functions.
The &lt;code&gt;begin&lt;&#x2F;code&gt; and &lt;code&gt;end&lt;&#x2F;code&gt; functions of the range like type must return objects of the iterator type.
If those criteria are met, then the range-based for loop construct is usable with the range like type.
The requirements can be summed up in code like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; style=&quot;background-color:#1d1f21;color:#c5c8c6;&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span&gt;range_iterator {
&lt;&#x2F;span&gt;&lt;span&gt;   range_iterator &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;operator++&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;bool &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;operator!=&lt;&#x2F;span&gt;&lt;span&gt;( range_iterator &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;const&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;amp; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;other &lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;   range_value_type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;operator*&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span&gt;range {
&lt;&#x2F;span&gt;&lt;span&gt;   range_iterator &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;begin&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;   range_iterator &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;end&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;where &lt;code&gt;range_value_type&lt;&#x2F;code&gt; is the type of the data pointed to by the iterator and contained in the range to iterate over.
Implementing those two types should be enough and so that is what I set out to do.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;Thinking_of_a_design&quot;&gt;Thinking of a design&lt;&#x2F;h3&gt;
&lt;p&gt;I first looked at Anthony William&#x27;s code to see how it could be done.
I suggest you take a look at the code (&lt;a href=&quot;https:&#x2F;&#x2F;www.justsoftwaresolutions.co.uk&#x2F;files&#x2F;numeric_range.cpp&quot;&gt;download link&lt;&#x2F;a&gt;) to see the approach he has taken.
I wanted to try and make my own implementation, taking a different path.
In my first attempt, I ended up having to write multiple versions of some of the classes in order to customize the behavior for various types.
For instance, comparing floats with &lt;code&gt;operator==&lt;&#x2F;code&gt; is hardly ever what you want (because of floating point errors), but doing so works perfectly with integral types.
Even with templates, I did not arrive at a customizable design that satisfied me.
Having to repeat myself was not so bad, but I wanted to see if I could avoid breaking the DRY principle.
As I said, a good dose of curiosity. :-)&lt;&#x2F;p&gt;
&lt;p&gt;So I needed to change the behavior depending on what type I iterate over.
There are a few alternatives to achieve such behavior in C++.
I wanted an alternative that would be compile time based with no runtime overhead.
I felt it was necessary to get the efficiency I was aiming for.
This meant and abstract base class with virtual functions was not in my solution set.
I decided to explore solutions which allowed me to specify the behavior of the class: some kind of &amp;quot;functionality injection&amp;quot;.
At first, I though of using &lt;a href=&quot;http:&#x2F;&#x2F;en.cppreference.com&#x2F;w&#x2F;cpp&#x2F;utility&#x2F;functional&#x2F;function&quot;&gt;std::function&lt;&#x2F;a&gt; to hold the &amp;quot;pointers&amp;quot; to the functions to call.
That way, I could specify what to use for the three iterator operators when constructing them.
The downside of this, from my perspective, is that this will introduce type erasure (and
possibly&#x2F;usually accompanying heap allocations) and indirection, which, if I
understand properly, is harder or impossible to optimize for the compiler.
I was worried this would not give me the performance I wanted.
In thinking and searching for alternatives, I remembered &lt;a href=&quot;https:&#x2F;&#x2F;www.fluentcpp.com&#x2F;2017&#x2F;05&#x2F;23&#x2F;strong-types-inheriting-functionalities-from-underlying&#x2F;&quot;&gt;this&lt;&#x2F;a&gt; blog post on inheriting functionalities.
This made me think the same technique applied in the blog post &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Curiously_recurring_template_pattern&quot;&gt;CRTP&lt;&#x2F;a&gt; might be the
solution I was looking for (did I mention over-engineering?).&lt;&#x2F;p&gt;
&lt;h3 id=&quot;Writing_some_code&quot;&gt;Writing some code&lt;&#x2F;h3&gt;
&lt;p&gt;Essentially, there are three functionalities that the iterator has to have and so I created three new types that the iterator would inherit from to &amp;quot;consume&amp;quot; the functionality.
Applying the CRTP pattern, I parametrized those new types so that they would take the iterator class as a template parameter, and I made the iterator class derive from those types.
The implementation ended up as follows:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; style=&quot;background-color:#1d1f21;color:#c5c8c6;&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;enum class &lt;&#x2F;span&gt;&lt;span&gt;Direction : &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5bd68;&quot;&gt;uint_fast8_t &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;   ascending,
&lt;&#x2F;span&gt;&lt;span&gt;   descending
&lt;&#x2F;span&gt;&lt;span&gt;};
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;constexpr auto&lt;&#x2F;span&gt;&lt;span&gt; Ascending &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; Direction::ascending;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;constexpr auto&lt;&#x2F;span&gt;&lt;span&gt; Descending &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; Direction::descending;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;template&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;typename&lt;&#x2F;span&gt;&lt;span&gt; Iterator, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;typename&lt;&#x2F;span&gt;&lt;span&gt; Reference &amp;gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span&gt;Dereference
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;auto &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;operator*&lt;&#x2F;span&gt;&lt;span&gt;() -&amp;gt; Reference {
&lt;&#x2F;span&gt;&lt;span&gt;      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;static_cast&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;Iterator&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;this&lt;&#x2F;span&gt;&lt;span&gt;).&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;cur_val_&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;   }
&lt;&#x2F;span&gt;&lt;span&gt;};
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;template&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;typename&lt;&#x2F;span&gt;&lt;span&gt; Iterator &amp;gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span&gt;Increment
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;auto &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;operator++&lt;&#x2F;span&gt;&lt;span&gt;() -&amp;gt; Iterator&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;amp; &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;auto&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt; self &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;= static_cast&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;Iterator&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;this&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;      ( self.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;direction_ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;==&lt;&#x2F;span&gt;&lt;span&gt; Ascending ) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;? ++&lt;&#x2F;span&gt;&lt;span&gt;(self.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;cur_val_&lt;&#x2F;span&gt;&lt;span&gt;)&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;: --&lt;&#x2F;span&gt;&lt;span&gt;(self.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;cur_val_&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;static_cast&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;Iterator&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;this&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;   }
&lt;&#x2F;span&gt;&lt;span&gt;};
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;template&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;typename&lt;&#x2F;span&gt;&lt;span&gt; Iterator &amp;gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span&gt;EqualityComparisons
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;bool &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;operator==&lt;&#x2F;span&gt;&lt;span&gt;( Iterator &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;const&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;amp; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;rhs &lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;const &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;static_cast&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;Iterator &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;const&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;this&lt;&#x2F;span&gt;&lt;span&gt;).&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;cur_val_ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;==&lt;&#x2F;span&gt;&lt;span&gt; rhs.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;cur_val_&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;   }
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;bool &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;operator!=&lt;&#x2F;span&gt;&lt;span&gt;( Iterator &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;const&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;amp; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;rhs &lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;const &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;!&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;this &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;==&lt;&#x2F;span&gt;&lt;span&gt; rhs);
&lt;&#x2F;span&gt;&lt;span&gt;   }
&lt;&#x2F;span&gt;&lt;span&gt;};
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;template&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;typename&lt;&#x2F;span&gt;&lt;span&gt; T &amp;gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span&gt;range_iterator :
&lt;&#x2F;span&gt;&lt;span&gt;      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5bd68;&quot;&gt;Dereference&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt; range_iterator&amp;lt;T&amp;gt;, T&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;amp; &lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5bd68;&quot;&gt;Increment&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt; range_iterator&amp;lt;T&amp;gt; &amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5bd68;&quot;&gt;EqualityComparisons&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt; range_iterator&amp;lt;T&amp;gt; &amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;using &lt;&#x2F;span&gt;&lt;span&gt;value_type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; T;
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;using &lt;&#x2F;span&gt;&lt;span&gt;reference &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; T&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;using &lt;&#x2F;span&gt;&lt;span&gt;iterator_category &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; std::input_iterator_tag;
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;using &lt;&#x2F;span&gt;&lt;span&gt;pointer &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; T&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;using &lt;&#x2F;span&gt;&lt;span&gt;difference_type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;void&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;range_iterator&lt;&#x2F;span&gt;&lt;span&gt;( T &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;val&lt;&#x2F;span&gt;&lt;span&gt;, Direction &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;dir &lt;&#x2F;span&gt;&lt;span&gt;) :
&lt;&#x2F;span&gt;&lt;span&gt;                  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;direction_&lt;&#x2F;span&gt;&lt;span&gt;{ dir }, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;cur_val_&lt;&#x2F;span&gt;&lt;span&gt;{ val } {
&lt;&#x2F;span&gt;&lt;span&gt;   }
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;private&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;   Direction direction_;
&lt;&#x2F;span&gt;&lt;span&gt;   T cur_val_;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;friend&lt;&#x2F;span&gt;&lt;span&gt; Dereference&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span&gt; range_iterator&amp;lt;T&amp;gt;, T&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;amp; &amp;gt;&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;friend&lt;&#x2F;span&gt;&lt;span&gt; Increment&amp;lt; range_iterator&amp;lt;T&amp;gt; &amp;gt;;
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;friend&lt;&#x2F;span&gt;&lt;span&gt; EqualityComparisons&amp;lt; range_iterator&amp;lt;T&amp;gt; &amp;gt;;
&lt;&#x2F;span&gt;&lt;span&gt;};
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;template&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;typename&lt;&#x2F;span&gt;&lt;span&gt; Iterator &amp;gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span&gt;Range
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;private&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;using &lt;&#x2F;span&gt;&lt;span&gt;value_type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;typename&lt;&#x2F;span&gt;&lt;span&gt; Iterator::value_type;
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;public&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;Range&lt;&#x2F;span&gt;&lt;span&gt;( value_type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;start&lt;&#x2F;span&gt;&lt;span&gt;, value_type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;stop &lt;&#x2F;span&gt;&lt;span&gt;) :
&lt;&#x2F;span&gt;&lt;span&gt;         &lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;direction_&lt;&#x2F;span&gt;&lt;span&gt;{ (start &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span&gt; stop) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;?&lt;&#x2F;span&gt;&lt;span&gt; Ascending &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;:&lt;&#x2F;span&gt;&lt;span&gt; Descending },
&lt;&#x2F;span&gt;&lt;span&gt;                                          &lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;cur_val_&lt;&#x2F;span&gt;&lt;span&gt;{ start }, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;end_&lt;&#x2F;span&gt;&lt;span&gt;{ stop } {
&lt;&#x2F;span&gt;&lt;span&gt;      }
&lt;&#x2F;span&gt;&lt;span&gt;      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;auto &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;begin&lt;&#x2F;span&gt;&lt;span&gt;() -&amp;gt; Iterator {
&lt;&#x2F;span&gt;&lt;span&gt;         &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;Iterator&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;{ cur_val_, direction_ }&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;      }
&lt;&#x2F;span&gt;&lt;span&gt;      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;auto &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;end&lt;&#x2F;span&gt;&lt;span&gt;() -&amp;gt; Iterator {
&lt;&#x2F;span&gt;&lt;span&gt;         &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;Iterator&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;{ end_, direction_ }&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;      }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;private&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;      Direction direction_;
&lt;&#x2F;span&gt;&lt;span&gt;      value_type cur_val_;
&lt;&#x2F;span&gt;&lt;span&gt;      value_type end_;
&lt;&#x2F;span&gt;&lt;span&gt;};
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;A few things worth mentioning.
I have had to make the &amp;quot;operation&amp;quot; classes friends of the iterator class to give them access to the iterator private data.
If I were designing something for the purpose of having client code specialize and extend the behavior, this break in encapsulation might be more of a concern and I might have to go for a different design, since the friend route seems to be the &lt;a href=&quot;https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;8523762&#x2F;crtp-with-protected-derived-member?rq=1&quot;&gt;only viable alternative&lt;&#x2F;a&gt; to give the base class access to the derived class data.
But for my current use, it is not something I am worried with.
I also had to explicitly specify the reference type in the &lt;code&gt;Dereference&lt;&#x2F;code&gt; operation.
This is because at the instantiation time of the &lt;code&gt;Dereference&lt;&#x2F;code&gt; template in the inheritance list of the &lt;code&gt;range_iterator&lt;&#x2F;code&gt;, the latter is still an incomplete type and so its &lt;code&gt;typedef&lt;&#x2F;code&gt;s
cannot be used.
Also, for brevity in this blog post, everything is in the global namespace, which is not at all good practice, but in the actual code, I put everything in a &lt;code&gt;estd&lt;&#x2F;code&gt; namespace (for __e__xtended &lt;strong&gt;std&lt;&#x2F;strong&gt;).
The indentation is also slightly modified for the purpose of the blog post.&lt;&#x2F;p&gt;
&lt;p&gt;In any case, with this code (and the appropriate &lt;code&gt;#include&lt;&#x2F;code&gt;s, again omitted for space), one can iterate over numbers using a range-based for loop like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; style=&quot;background-color:#1d1f21;color:#c5c8c6;&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;for&lt;&#x2F;span&gt;&lt;span&gt;( &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;auto&lt;&#x2F;span&gt;&lt;span&gt; idx &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;Range&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;&amp;lt; range_iterator&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;int&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;&amp;gt; &amp;gt;( &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;8 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;) &lt;&#x2F;span&gt;&lt;span&gt;) {
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#969896;&quot;&gt;&#x2F;&#x2F; use idx
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;for&lt;&#x2F;span&gt;&lt;span&gt;( &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;auto&lt;&#x2F;span&gt;&lt;span&gt; idx &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;Range&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;&amp;lt; range_iterator&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;int&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;&amp;gt; &amp;gt;( &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;7&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;-&lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;1 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;) &lt;&#x2F;span&gt;&lt;span&gt;) {
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#969896;&quot;&gt;&#x2F;&#x2F; use idx
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Verbose, shows implementation details, but a start.
This is the beginning of the interface I set out to have.
It allows specifying &lt;code&gt;start&lt;&#x2F;code&gt; and &lt;code&gt;stop&lt;&#x2F;code&gt; (but not the &lt;code&gt;step&lt;&#x2F;code&gt; yet).
It still requires an explicit type specification, which I would like to get rid of.
It will detect whether you want to go in the increasing of decreasing direction, so increment and decrement are covered.
Some might argue the detection is undesired behavior (Python&#x27;s &lt;code&gt;range&lt;&#x2F;code&gt; will not do this and a &lt;code&gt;step&lt;&#x2F;code&gt; of -1 must be explicitly specified to decrement).
It is debatable I guess, but this is the interface I went with.&lt;&#x2F;p&gt;
&lt;p&gt;As it stands, in the code above, the implementation will accept floating point
types and character types.
This is not allowed by Python&#x27;s &lt;code&gt;range&lt;&#x2F;code&gt; object (although using the &lt;a href=&quot;http:&#x2F;&#x2F;www.numpy.org&#x2F;&quot;&gt;Numpy&lt;&#x2F;a&gt; &lt;a href=&quot;https:&#x2F;&#x2F;docs.scipy.org&#x2F;doc&#x2F;numpy&#x2F;reference&#x2F;generated&#x2F;numpy.linspace.html&quot;&gt;&lt;code&gt;linspace&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; function, one can get a floating point range).
Unfortunately, the current implementation of the comparison operator is defined in terms of the underlying type&#x27;s &lt;code&gt;operator==&lt;&#x2F;code&gt;.
As previously mentioned, comparing floats using this operator is not ideal (and might actually never be true in some cases, which would create an infinite loop).
This has been one of the first reasons I have had for specializing in my earlier designs (which are not presented here), and so I will explore it soon, but before I get to that, I will look at performance to see if my design is good enough for me to pursue further.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;Evaluating_the_performance_I&quot;&gt;Evaluating the performance I&lt;&#x2F;h3&gt;
&lt;p&gt;Instead of benchmarking the code in the traditional sense of measuring execution time (&lt;a href=&quot;https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=zWxSZcpeS8Q&quot;&gt;which is complicated&lt;&#x2F;a&gt;), I decided to look at the assembly generated in Code Explorer (i.e. I godbolted my code !) and see if there was any difference between this looping construct and a traditional C style for loop.
My hypothesis is that if the same assembly is generated, then the performance will be the same. I know that &lt;a href=&quot;https:&#x2F;&#x2F;channel9.msdn.com&#x2F;events&#x2F;Build&#x2F;2013&#x2F;4-329?term=The%20Elephant%20in%20the%20CPU&quot;&gt;fewer instructions is not a guarantee of better performance&lt;&#x2F;a&gt;, but I think it is safe to assume that if the assembly is the same, then the performance will be the same.&lt;&#x2F;p&gt;
&lt;figure&gt;
    &lt;a href=&quot;https:&#x2F;&#x2F;tinyurl.com&#x2F;ycc42hkx&quot; target=&quot;_blank&quot;&gt;
        &lt;img src=&quot;compiler_explorer.png&quot; alt=&quot;https:&#x2F;&#x2F;tinyurl.com&#x2F;ycc42hkx&quot; &#x2F;&gt;
    &lt;&#x2F;a&gt;
&lt;&#x2F;figure&gt;
&lt;p&gt;In the above figure, the leftmost editor&#x2F;compiler pane pair illustrates the C style for loop assembly.
The central pane shows the assembly for the version of the range code as it is in the previous section, and, because compiler explorer provides a version of the Boost libraries, the same loop using &lt;code&gt;boost::irange&lt;&#x2F;code&gt; is displayed in the rightmost pane.
The assembly generated is exactly the same even at a low optimization level (&lt;code&gt;O1&lt;&#x2F;code&gt;).
This means GCC is able to completely see through the abstractions and produce the same output whether this range construct or a hand coded C style for loop is used.
When I saw that, I though it was excellent news, and decided to test with two other commonly used compliers: Clang and MSVC&lt;sup id=&quot;ftntref:6&quot;&gt;&lt;a href=&quot;#ftnt:6&quot;&gt;6&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Using Clang, I first got disappointing results: a higher optimization level (&lt;code&gt;O2&lt;&#x2F;code&gt;) was necessary to obtain the same result.
Thinking about why that was, I decided to test if it was related to inlining.
Rewriting the code to use &lt;code&gt;__attribute__((always_inline))&lt;&#x2F;code&gt; to suggest more aggressive inlining to the compiler, I was able to get Clang to emit the same assembly as a hand written loop at the lower level (&lt;code&gt;O1&lt;&#x2F;code&gt;).
Great.&lt;&#x2F;p&gt;
&lt;p&gt;I then tried with MSVC.
No matter the optimization level or the inlining hints used, for this compiler, there seems to remain a small difference in the assembly generated when using the &lt;code&gt;Range&lt;&#x2F;code&gt; code presented here compared to that generated when using the C style for loop.
This is shown in the following figure:
&lt;figure&gt;
    
        &lt;img src=&quot;msvc.png&quot;&#x2F;&gt;
    
&lt;&#x2F;figure&gt;
&lt;&#x2F;p&gt;
&lt;p&gt;The loops are structured differently.
In the assembly of the hand written loop, there is a single conditional jump instruction back to the beginning of the loop if the loop exit condition is not met, but no other jump instruction.
When the exit condition is met, the program simply continues with the next instruction,
thereby exiting the loop.
On the other hand, the assembly generated by the &lt;code&gt;Range&lt;&#x2F;code&gt; construct contains two jumps: one back to the beginning of the loop when the loop exit condition is not met, and one out of the loop when the condition is met.
The number of comparison instructions (&lt;code&gt;cmp&lt;&#x2F;code&gt;) is the same though and that should be the most significant performance factor.
I imagine for a very short loop (i.e. low number of iterations), the extra jump &lt;em&gt;could&lt;&#x2F;em&gt; be a significant overhead, but for a long loop, I doubt it.
I guess actual profiling would be needed.&lt;&#x2F;p&gt;
&lt;p&gt;Anyhow, at least in that first attempt, performance did not seem to be a big issue (although compile times will go up if that is your metric).
This was encouraging to me and motivated me to keep exploring this design.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;Dealing_with_the_type_specification&quot;&gt;Dealing with the type specification&lt;&#x2F;h3&gt;
&lt;p&gt;The next [design goal]({{&amp;lt; ref &amp;quot;#the-initial-design-goals&amp;quot; &amp;gt;}}) I will be talking about is the explicit type specification, or rather removing the need for it.
The &lt;code&gt;Range&lt;&#x2F;code&gt; object is a class template, and prior to C++17, there is no &lt;a href=&quot;http:&#x2F;&#x2F;en.cppreference.com&#x2F;w&#x2F;cpp&#x2F;language&#x2F;class_template_argument_deduction&quot;&gt;template parameter argument deduction for class templates&lt;&#x2F;a&gt;.
This means using it directly as in the example above will not allow me to achieve
the &amp;quot;no type specification&amp;quot; goal that I set out for.
However, function templates in C++ always did have &lt;a href=&quot;http:&#x2F;&#x2F;en.cppreference.com&#x2F;w&#x2F;cpp&#x2F;language&#x2F;template_argument_deduction&quot;&gt;template argument deduction&lt;&#x2F;a&gt; and so
they could provide a nicer interface.
Given that the range expression in the range-based for loop does not need to be an object, but can be a function returning an object, it is possible to use a set of function template overloads instead of a &lt;code&gt;Range&lt;&#x2F;code&gt; directly.
With those, the types could be deduced.
Such an overload set can be written as follows:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; style=&quot;background-color:#1d1f21;color:#c5c8c6;&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;template&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;typename&lt;&#x2F;span&gt;&lt;span&gt; T &amp;gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;auto &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;range&lt;&#x2F;span&gt;&lt;span&gt;( T &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;start&lt;&#x2F;span&gt;&lt;span&gt;, T &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;stop &lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; Range&amp;lt; range_iterator&amp;lt;T&amp;gt; &amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;Range&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;&amp;lt; range_iterator&amp;lt;T&amp;gt; &amp;gt;{ start, stop }&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;template&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;typename&lt;&#x2F;span&gt;&lt;span&gt; T &amp;gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;auto &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;range&lt;&#x2F;span&gt;&lt;span&gt;( T &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;stop &lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; Range&amp;lt; range_iterator&amp;lt;T&amp;gt; &amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;range&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;( &lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;T&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;{&lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;}, stop )&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;which can be used without a type specification like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; style=&quot;background-color:#1d1f21;color:#c5c8c6;&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;for&lt;&#x2F;span&gt;&lt;span&gt;( &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;auto&lt;&#x2F;span&gt;&lt;span&gt; i &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;range&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;( &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;8 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;) &lt;&#x2F;span&gt;&lt;span&gt;) {
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#969896;&quot;&gt;&#x2F;&#x2F; use i
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;which is now very close to the Python version:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;python&quot; style=&quot;background-color:#1d1f21;color:#c5c8c6;&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;x &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;in &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;range( &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;8 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;)&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#969896;&quot;&gt;# use i
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;I have tested this on compiler explorer and it produces the same executable as
the previous version.  So far so good.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;Correctly_handling_floating_point_ranges&quot;&gt;Correctly handling floating point ranges&lt;&#x2F;h3&gt;
&lt;p&gt;This was not part of the initial [design goals]({{&amp;lt; ref &amp;quot;#the-initial-design-goals&amp;quot; &amp;gt;}}), but dealing with this issue actually helps with the last remaining design goal, so I dealt with it.
In the current version, the main problem with floating point ranges is the
comparison operator.
As it stands, the rest of the code would function properly, but the comparison of &lt;code&gt;begin&lt;&#x2F;code&gt; and &lt;code&gt;end&lt;&#x2F;code&gt; is broken, since it might never yield false and result in an infinite loop (which has happened in testing I should say!).
Said another way, &lt;code&gt;begin&lt;&#x2F;code&gt; might never compare equal to &lt;code&gt;end&lt;&#x2F;code&gt; with the current definition of comparison.&lt;&#x2F;p&gt;
&lt;p&gt;Changing the definition of the &lt;code&gt;operator==&lt;&#x2F;code&gt; to the following unorthodox one would give the proper behavior for floating points:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; style=&quot;background-color:#1d1f21;color:#c5c8c6;&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;bool &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;operator==&lt;&#x2F;span&gt;&lt;span&gt;( Iterator &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;const&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;amp; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;rhs &lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;const &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span&gt;( &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;static_cast&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;Iterator&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;this&lt;&#x2F;span&gt;&lt;span&gt;).&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;direction_ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;==&lt;&#x2F;span&gt;&lt;span&gt; Ascending ) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;?
&lt;&#x2F;span&gt;&lt;span&gt;            ( &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;static_cast&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;Iterator&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;this&lt;&#x2F;span&gt;&lt;span&gt;).&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;cur_val_ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;gt;=&lt;&#x2F;span&gt;&lt;span&gt; rhs.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;cur_val_ &lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;               ( &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;static_cast&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;Iterator&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;this&lt;&#x2F;span&gt;&lt;span&gt;).&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;cur_val_ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;lt;=&lt;&#x2F;span&gt;&lt;span&gt; rhs.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;cur_val_ &lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;With this definition, for an ascending direction, two iterators are considered equal if the value of the left hand side one is equal &lt;em&gt;or larger&lt;&#x2F;em&gt; than that of the right hand side one.
In the range-based for loop, the right hand side iterator in the comparison is always &lt;code&gt;end()&lt;&#x2F;code&gt;, so for those loops, the comparison as defined above means any iterator with a value of end or more (ascending) are considered equal.
Thus, as soon as the loop iterator&#x27;s value reaches, or gets past, that of the end iterator, both iterators are considered equal and the loop stops.
This is the desired behavior for the loop, but it is an unusual definition for the iterator &lt;em&gt;if&lt;&#x2F;em&gt; you think of the iterator as the value it holds.&lt;&#x2F;p&gt;
&lt;p&gt;Having an operator with an unusual meaning is generally considered bad practice, and for good reasons.
With the previous definition, the result of comparing two iterators can depend on the order of the parameters:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; style=&quot;background-color:#1d1f21;color:#c5c8c6;&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;&lt;span&gt;range_iterator&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;double&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;a&lt;&#x2F;span&gt;&lt;span&gt;( &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;42.0&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;Ascending &lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;range_iterator&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;double&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;b&lt;&#x2F;span&gt;&lt;span&gt;( &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;48.5&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;Ascending &lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;assert&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;( a &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;==&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt; b )&lt;&#x2F;span&gt;&lt;span&gt;;                    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#969896;&quot;&gt;&#x2F;&#x2F; will fire,     42.0 &amp;gt;= 48.5 -&amp;gt; false
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;assert&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;( b &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;==&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt; a )&lt;&#x2F;span&gt;&lt;span&gt;;                    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#969896;&quot;&gt;&#x2F;&#x2F; will not fire, 48.5 &amp;gt;= 42.0 -&amp;gt; true
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;assert&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;( ( a &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;==&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt; b ) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;!= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;( b &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;==&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt; a )  )&lt;&#x2F;span&gt;&lt;span&gt;; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#969896;&quot;&gt;&#x2F;&#x2F; will not fire, false != true
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;which is surprising.
Operators having unusual or inconsistent behavior can be confusing (the &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;isocpp&#x2F;CppCoreGuidelines&#x2F;blob&#x2F;master&#x2F;CppCoreGuidelines.md&quot;&gt;C++ Core Guidelines&lt;&#x2F;a&gt; discuss this in their overload section (C.over), more specifically subsections C.160 and C.167).
The problem I am faced with here is that the range-based for loop cannot be customized to use something other than &lt;code&gt;operator!=&lt;&#x2F;code&gt; to compare the two iterators.  So whatever behavior I want my iterator to have, it must be in the comparison operator.&lt;&#x2F;p&gt;
&lt;p&gt;That said, for the case at hand, these iterators are part of the implementation of the &lt;code&gt;range&lt;&#x2F;code&gt; function, which is the only part of the library that is considered public.
The only use of the comparison operator should therefore be the one in the range-based for, where the only comparison is between the &lt;code&gt;begin&lt;&#x2F;code&gt; and &lt;code&gt;end&lt;&#x2F;code&gt; iterator pair, which will have the correct behavior.
The iterators are not meant to be used directly and I think the implementation is thus reasonable.
That is debatable for sure, but in any case, in the actual implementation, the function above is defined in the &lt;code&gt;EqualityComparisons&lt;&#x2F;code&gt; class and some template metaprogramming ensures that it applies only to floating point types.&lt;&#x2F;p&gt;
&lt;p&gt;I should warn though that using floating points as a loop counter, either manually or using the &lt;code&gt;range&lt;&#x2F;code&gt; functions here, is not as simple as it seems at first: floating point maths and comparisons are hard and floating point error will be present with the naive loop.
Since the construct proposed here aims only at replacing the naive loop, nothing fancy is done to compensate floating point errors in loops involving floating points, and so I thought a reminder was in order.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;Allowing_non_unit_steps&quot;&gt;Allowing non unit steps&lt;&#x2F;h3&gt;
&lt;p&gt;The last goal in my initial list is the non unit step.
For now, I can select &lt;code&gt;start&lt;&#x2F;code&gt; and &lt;code&gt;stop&lt;&#x2F;code&gt;, I allow increment and decrement, I do not need to specify the type, and the performance penalty (with some optimizations enabled) is almost null on the compilers I tested.
The final goal is to allow non unit steps.
In order to do that, I have to:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;store the &lt;code&gt;step&lt;&#x2F;code&gt; in the iterator;&lt;&#x2F;li&gt;
&lt;li&gt;adjust the &lt;code&gt;operator++&lt;&#x2F;code&gt; to advance of &lt;code&gt;step&lt;&#x2F;code&gt; units instead of 1;&lt;&#x2F;li&gt;
&lt;li&gt;adjust the &lt;code&gt;operator==&lt;&#x2F;code&gt; for integral types;&lt;&#x2F;li&gt;
&lt;li&gt;add an overload to the &lt;code&gt;range&lt;&#x2F;code&gt; function which takes 3 arguments.&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;The third item was the easiest to deal with.
The change became necessary, since if the step size is not an &lt;em&gt;exact&lt;&#x2F;em&gt; divisor of the distance between &lt;code&gt;start&lt;&#x2F;code&gt; and &lt;code&gt;stop&lt;&#x2F;code&gt;, the original definition of &lt;code&gt;operator==&lt;&#x2F;code&gt; will never stop the loop, because the loop iterator value will never be exactly the end iterator value, even for integral types.
It turns out that using the same definition of the equality operator as was used to deal with floating point iterators, the problem is solved.
Now, when the value of the loop iterator is above the end iterator value, the loop stops, as desired.&lt;&#x2F;p&gt;
&lt;p&gt;Going back to the first item, the decision I made was to add a template parameter to the &lt;code&gt;range_iterator&lt;&#x2F;code&gt; class which will be of a new enum type &lt;code&gt;Length&lt;&#x2F;code&gt; which tells me whether the &lt;code&gt;range_iterator&lt;&#x2F;code&gt; will have unit length steps or any other length.
Then, I create a specialization for the case where the length is unit and one for when the length is other.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; style=&quot;background-color:#1d1f21;color:#c5c8c6;&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;enum class &lt;&#x2F;span&gt;&lt;span&gt;Length : &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5bd68;&quot;&gt;uint_fast8_t &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;   unit,
&lt;&#x2F;span&gt;&lt;span&gt;   other
&lt;&#x2F;span&gt;&lt;span&gt;};
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;constexpr auto&lt;&#x2F;span&gt;&lt;span&gt; Unit &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; Length::unit;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;constexpr auto&lt;&#x2F;span&gt;&lt;span&gt; Other &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; Length::other;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;template&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;typename&lt;&#x2F;span&gt;&lt;span&gt; T, Length length &amp;gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span&gt;range_iterator;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;template&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;typename&lt;&#x2F;span&gt;&lt;span&gt; T &amp;gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span&gt;range_iterator&amp;lt; T, Unit &amp;gt; :
&lt;&#x2F;span&gt;&lt;span&gt;         &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5bd68;&quot;&gt;Dereference&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt; range_iterator&amp;lt;T&amp;gt;, T&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;amp; &lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;         &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5bd68;&quot;&gt;Increment&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt; range_iterator&amp;lt;T&amp;gt; &amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;         &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5bd68;&quot;&gt;EqualityComparisons&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt; range_iterator&amp;lt;T&amp;gt; &amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#969896;&quot;&gt;&#x2F;* implementation here for Unit length *&#x2F;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;private&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;   Direction direction_;
&lt;&#x2F;span&gt;&lt;span&gt;   T cur_val_;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;template&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;typename&lt;&#x2F;span&gt;&lt;span&gt; T &amp;gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span&gt;range_iterator&amp;lt; T, Other &amp;gt; :
&lt;&#x2F;span&gt;&lt;span&gt;         &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5bd68;&quot;&gt;Dereference&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt; range_iterator&amp;lt;T&amp;gt;, T&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;amp; &lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;         &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5bd68;&quot;&gt;Increment&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt; range_iterator&amp;lt;T&amp;gt; &amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;         &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5bd68;&quot;&gt;EqualityComparisons&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt; range_iterator&amp;lt;T&amp;gt; &amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#969896;&quot;&gt;&#x2F;* implementation here for Other length *&#x2F;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;private&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;   Direction direction_;
&lt;&#x2F;span&gt;&lt;span&gt;   T cur_val_;
&lt;&#x2F;span&gt;&lt;span&gt;   T step_;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;In the case where the length is not one, the &lt;code&gt;step&lt;&#x2F;code&gt; is kept as a data member and available to the operators.&lt;&#x2F;p&gt;
&lt;p&gt;Changing the &lt;code&gt;operator++&lt;&#x2F;code&gt; was not much more complicated than the change to the comparison operator.
The &lt;code&gt;Increment&lt;&#x2F;code&gt; type is now templated on the length, and, using SFINAE, a different implementation of the &lt;code&gt;operator++&lt;&#x2F;code&gt; is used depending on whether the &lt;code&gt;length&lt;&#x2F;code&gt; argument is &lt;code&gt;Unit&lt;&#x2F;code&gt; or &lt;code&gt;Other&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; style=&quot;background-color:#1d1f21;color:#c5c8c6;&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;auto &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;operator++&lt;&#x2F;span&gt;&lt;span&gt;() -&amp;gt; Iterator&amp;lt; T, length &amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;static_cast&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;Iterator&amp;lt; T, length &amp;gt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;this&lt;&#x2F;span&gt;&lt;span&gt;).&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;cur_val_ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;+=
&lt;&#x2F;span&gt;&lt;span&gt;                           &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;static_cast&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;Iterator&amp;lt; T, length &amp;gt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;this&lt;&#x2F;span&gt;&lt;span&gt;).&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;step_&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The only remaining task is to add an overload of the &lt;code&gt;range&lt;&#x2F;code&gt; function.
This overload will take one more parameter (the &lt;code&gt;step&lt;&#x2F;code&gt;) and return a range parametrized
with a different iterator type.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; style=&quot;background-color:#1d1f21;color:#c5c8c6;&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;template&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;typename&lt;&#x2F;span&gt;&lt;span&gt; T, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;typename&lt;&#x2F;span&gt;&lt;span&gt; U &amp;gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;auto &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;range&lt;&#x2F;span&gt;&lt;span&gt;( T &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;start&lt;&#x2F;span&gt;&lt;span&gt;, T &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;stop&lt;&#x2F;span&gt;&lt;span&gt;, U &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;step &lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; detail::range&amp;lt; T &amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;detail::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;range&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;&amp;lt; T &amp;gt;{ start, stop, step }&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;It should be noted that the &lt;code&gt;start&lt;&#x2F;code&gt;&#x2F;&lt;code&gt;stop&lt;&#x2F;code&gt; and the &lt;code&gt;step&lt;&#x2F;code&gt; parameters can have different types.
This is necessary for someone to be able to call the function like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; style=&quot;background-color:#1d1f21;color:#c5c8c6;&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;for&lt;&#x2F;span&gt;&lt;span&gt;( &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;auto&lt;&#x2F;span&gt;&lt;span&gt; i &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;range&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;( &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;13&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;u&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;u&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;-&lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;3 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;) &lt;&#x2F;span&gt;&lt;span&gt;) {}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;If all three parameters were of the same type, then the user would have to manually convert one way or the other, which is not a nice interface.
What is done in the implementation is a cast inside the constructor of the &lt;code&gt;Range&lt;&#x2F;code&gt; object to the iterator type.
Unfortunately, this opens the door to quite a few conversion problems.
If you go from signed to unsigned, the behavior is correct and portable.
If you go from unsigned to signed, the behavior is implementation defined, but should mostly work.&lt;&#x2F;p&gt;
&lt;p&gt;Anyhow, with all of this in place, all my goals are achieved!&lt;&#x2F;p&gt;
&lt;h2 id=&quot;Mixed_types,_logic_checking...&quot;&gt;Mixed types, logic checking...&lt;&#x2F;h2&gt;
&lt;p&gt;As I said, the code above is close to the one I ended up with, but not exactly the same.
You can go on &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;ghlecl&#x2F;range_fn&quot;&gt;Github&lt;&#x2F;a&gt; to find my range function implementation.
There are more things one could do with it (or do differently).&lt;&#x2F;p&gt;
&lt;p&gt;One thing that could be done is allow for mixed types to be used for specifying the bounds and not only the step (see previous section).
That is actually what prompted my two previous posts about [integer representations]({{&amp;lt; ref &amp;quot;integer_representations&amp;quot; &amp;gt;}}) and [usual conversions in arithmetic]({{&amp;lt; ref &amp;quot;usual_conversions&amp;quot; &amp;gt;}}).
I am not illustrating the code here, since it would make this already long post even longer, but it can be done.
It does bring up some interesting questions though such as which type to return when two types are used.
I am still uncertain what a good answer is.
As far as I can tell, Boost range has decided to simply not allow that.
This is not unreasonable.
That said, the use case I see for
allowing mixed types bounds specification is the following:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; style=&quot;background-color:#1d1f21;color:#c5c8c6;&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;&lt;span&gt;std::vector&amp;lt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;int &lt;&#x2F;span&gt;&lt;span&gt;&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;v&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;{ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;4&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;6&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;8&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;10&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;12 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;}&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;for&lt;&#x2F;span&gt;&lt;span&gt;( &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;auto&lt;&#x2F;span&gt;&lt;span&gt; idx &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;range&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;( &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;3&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;, v.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;size&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;() ) &lt;&#x2F;span&gt;&lt;span&gt;) {
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#969896;&quot;&gt;&#x2F;&#x2F; do something with the items 3 to size of vector v
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Since the standard library has made the choice of having &lt;code&gt;size&lt;&#x2F;code&gt; of containers be unsigned, without mixed bound types, this would not work without asking the user to write &lt;code&gt;3u&lt;&#x2F;code&gt; as the first index or cast the &lt;code&gt;.size()&lt;&#x2F;code&gt; call result.&lt;&#x2F;p&gt;
&lt;p&gt;Another thing, you will see in the code is some consistency checks.
For instance, if &lt;code&gt;start&lt;&#x2F;code&gt; &amp;gt; &lt;code&gt;stop&lt;&#x2F;code&gt; while &lt;code&gt;step&lt;&#x2F;code&gt; &amp;gt; 0, there is likely a problem (unless you
allow overflowing loops, which could be done).&lt;&#x2F;p&gt;
&lt;p&gt;There are some parts of the code which, with hindsight, seem superfluous.
For instance, there is no difference in the dereferencing behavior in any of the code here, so it would be simpler to leave it in the &lt;code&gt;range_iterator&lt;&#x2F;code&gt; implementation.
It would not be DRY (repeated in two classes), but the complexity introduced might not be worth it.  As with any code, I think it can be &lt;del&gt;bikeshedded&lt;&#x2F;del&gt; debated forever.  :-)&lt;&#x2F;p&gt;
&lt;p&gt;Anyhow, I hope you have enjoyed reading this post.
Writing it certainly made me clarify the concepts involved in range-based for loops in C++ and yielded a construct I can use to loop over indices with a nice pythonish syntax.
It is what I initially wanted, so for me at least, mission accomplished!&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;Acknowledments&quot;&gt;Acknowledments&lt;&#x2F;h2&gt;
&lt;p&gt;I would like to thank &lt;a href=&quot;https:&#x2F;&#x2F;www.twitter.com&#x2F;Gab_AL_&quot;&gt;Gabriel Aubut-Lussier&lt;&#x2F;a&gt; for taking the time to read this post before I published it and making constructive comments on the content.
The writing is better for it.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;Notes&quot;&gt;Notes&lt;&#x2F;h2&gt;
&lt;p id=&quot;ftnt:1&quot;&gt;&lt;sup&gt;[1]&lt;&#x2F;sup&gt;&amp;nbsp;The work here will probably be made completely useless by the &lt;a href=&quot;http:&#x2F;&#x2F;open-std.org&#x2F;JTC1&#x2F;SC22&#x2F;WG21&#x2F;docs&#x2F;papers&#x2F;2017&#x2F;n4685.pdf&quot;&gt;range proposal&lt;&#x2F;a&gt; when it gets in the standard.
On top of that, such a function already exists in &lt;a href=&quot;https:&#x2F;&#x2F;www.boost.org&#x2F;doc&#x2F;libs&#x2F;1_67_0&#x2F;libs&#x2F;range&#x2F;doc&#x2F;html&#x2F;range&#x2F;reference&#x2F;ranges&#x2F;irange.html&quot;&gt;Boost&lt;&#x2F;a&gt;.
The links were valid at the time of writing.
The link to the range proposal is actually to a draft version of the proposal, which might differ from what actually ends up in the standard.&amp;nbsp;&lt;a href=&quot;#ftntref:1&quot;&gt;&amp;#8617;&amp;#65038;&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p id=&quot;ftnt:2&quot;&gt;&lt;sup&gt;[2]&lt;&#x2F;sup&gt;&amp;nbsp;Link pointed to most recent release on the date of writing.
Might not work on future dates.&amp;nbsp;&lt;a href=&quot;#ftntref:2&quot;&gt;&amp;#8617;&amp;#65038;&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p id=&quot;ftnt:3&quot;&gt;&lt;sup&gt;[3]&lt;&#x2F;sup&gt;&amp;nbsp;Edit 2018-08-16: Turns out even in C++98, it works for built-in
arrays, albeit not with the &lt;code&gt;std::begin()&lt;&#x2F;code&gt; and &lt;code&gt;std::end()&lt;&#x2F;code&gt; free functions given
they were introduced in C++11.
You can simply pass the array &amp;quot;bounds&amp;quot; (i.e. the array variable and the array variable plus the length) to the standard algorithm (tested with std::sort) and it works.
You learn every day!&amp;nbsp;&lt;a href=&quot;#ftntref:3&quot;&gt;&amp;#8617;&amp;#65038;&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p id=&quot;ftnt:4&quot;&gt;&lt;sup&gt;[4]&lt;&#x2F;sup&gt;&amp;nbsp;At first, like most I would think, I actually first asked a search engine and that is how I found &lt;a href=&quot;https:&#x2F;&#x2F;www.justsoftwaresolutions.co.uk&#x2F;cplusplus&#x2F;generating_sequences.html&quot;&gt;Anthony&#x27;s post&lt;&#x2F;a&gt; on the subject.
This was a great starting point.&amp;nbsp;&lt;a href=&quot;#ftntref:4&quot;&gt;&amp;#8617;&amp;#65038;&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p id=&quot;ftnt:5&quot;&gt;&lt;sup&gt;[5]&lt;&#x2F;sup&gt;&amp;nbsp;Adapted from the C++17 standard draft.&amp;nbsp;&lt;a href=&quot;#ftntref:5&quot;&gt;&amp;#8617;&amp;#65038;&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p id=&quot;ftnt:6&quot;&gt;&lt;sup&gt;[6]&lt;&#x2F;sup&gt;&amp;nbsp;In the course of writing this article, I realized that a version of the Intel compiler was also available on Compiler Explorer and thus decided to look at the assembly generated with this compiler.
It turns out it takes optimization level 3 for the code to give the same result as the hand-coded loop with this compiler.
Depending on whether or not you can use this optimization level, the performance of the &lt;code&gt;Range&lt;&#x2F;code&gt; presented here might not be very good with this compiler.&amp;nbsp;&lt;a href=&quot;#ftntref:6&quot;&gt;&amp;#8617;&amp;#65038;&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
</content>
  </entry>
  <entry xml:lang="en">
    <title>Mixed types arithmetic in C++</title>
    <author>codeattempts@gmail.com</author>
    <published>2018-05-19</published>
    <updated>2018-05-19</updated>
    <link href="https://ghlecl.github.io/posts/usual_conversions/" type="text/html"/>
    <id>https://ghlecl.github.io/posts/usual_conversions/</id>
    <summary>
   Arithmetic on mixed fundamental types in C++
For a weekend project of mine, I have had to think about mixed type arithmetic on fundamental types in C++.
In the process, I made sense of a few fundamental things (no pun intended ;-) ) and I have decided to write them down.
Hopefully, writing about it will allow me to both clarify my thoughts and remember the information!
Arithmetic conversions
Applying binary operators to different types might seem trivial in</summary>
    <content>&lt;h1 id=&quot;Arithmetic_on_mixed_fundamental_types_in_C++&quot;&gt;Arithmetic on mixed fundamental types in C++&lt;&#x2F;h1&gt;
&lt;p&gt;For a weekend project of mine, I have had to think about mixed type arithmetic on fundamental types in C++.
In the process, I made sense of a few fundamental things (no &lt;em&gt;pun&lt;&#x2F;em&gt; intended ;-) ) and I have decided to write them down.
Hopefully, writing about it will allow me to both clarify my thoughts and remember the information!&lt;&#x2F;p&gt;
&lt;h2 id=&quot;Arithmetic_conversions&quot;&gt;Arithmetic conversions&lt;&#x2F;h2&gt;
&lt;p&gt;Applying binary operators to different types might seem trivial in C++, because it mostly just works.
If you write the following code:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; style=&quot;background-color:#1d1f21;color:#c5c8c6;&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;float &lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;flt&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;{&lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;15.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;f&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;}&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;long &lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;lng_a&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;{&lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;30&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;L&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;}&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;long&lt;&#x2F;span&gt;&lt;span&gt; lng_b &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; lng_a &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;+&lt;&#x2F;span&gt;&lt;span&gt; flt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;assert&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;( lng_b &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;== &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;45 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;)&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;and then run it, the value of &lt;code&gt;lng_b&lt;&#x2F;code&gt; will be 45.
No surprises...
Except when you stop to think about what happened in the background and how many rules were involved in the computation.&lt;sup id=&quot;ftntref:1&quot;&gt;&lt;a href=&quot;#ftnt:1&quot;&gt;1&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Naively (as seems to often be the case for me...), because of the performance reputation of C++, I assumed that the addition expression above mapped to an assembly language instruction&lt;sup id=&quot;ftntref:2&quot;&gt;&lt;a href=&quot;#ftnt:2&quot;&gt;2&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt; to add two registers.
Then, I started thinking more seriously about the problem, and even though I am anything but an expert in assembly, it brought me to this question: is there an opcode to add an &lt;code&gt;int&lt;&#x2F;code&gt; to a &lt;code&gt;float&lt;&#x2F;code&gt;?  Are there mixed type instructions for the CPUs?
With modern hardware, &lt;a href=&quot;https:&#x2F;&#x2F;queue.acm.org&#x2F;detail.cfm?id=3212479&quot;&gt;it is not as simple as we think anymore&lt;&#x2F;a&gt;, but as far as I could find out, in most hardware, &lt;a href=&quot;https:&#x2F;&#x2F;stackoverflow.com&#x2F;a&#x2F;42184775&quot;&gt;there&lt;&#x2F;a&gt; &lt;a href=&quot;https:&#x2F;&#x2F;stackoverflow.com&#x2F;a&#x2F;28011249&quot;&gt;is not&lt;&#x2F;a&gt;.
This means that at the hardware level, both datum have to have the same representation to allow the operation, which is not completely unreasonable.
Thus, even for the simple expression in the code above, conversions are needed to select a common type to apply the operation on.&lt;&#x2F;p&gt;
&lt;p&gt;The C++ language standard explicitly states which conversions will take place (inherited from C) allowing one to take control and override the behavior manually using a cast if preferred.
This could be needed if, for instance, the default conversion introduces loss of precision on a given platform or if a specific wrapping behavior is required.&lt;&#x2F;p&gt;
&lt;p&gt;One should note that the type selected for the operation by the conversion rules will be the type of both operands &lt;strong&gt;&lt;em&gt;and&lt;&#x2F;em&gt;&lt;&#x2F;strong&gt; of the return value.
This means that a supplementary conversion might happen if the type in which the result of the operation is put is not that which would have been selected by the usual conversions (as is the case in the example above).
Something to keep in mind.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;Usual_arithmetic_conversions&quot;&gt;Usual arithmetic conversions&lt;&#x2F;h2&gt;
&lt;p&gt;The conversion rules applied before binary operations on fundamental types are called the &lt;em&gt;usual arithmetic conversions&lt;&#x2F;em&gt; and can be found in section &lt;strong&gt;8 Expressions&lt;&#x2F;strong&gt; of the C++ standard document&lt;sup id=&quot;ftntref:3&quot;&gt;&lt;a href=&quot;#ftnt:3&quot;&gt;3&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;.
For those like me who do not easily read &amp;quot;standardese&amp;quot;, information on the subject with some explanations can be &lt;a href=&quot;https:&#x2F;&#x2F;docs.microsoft.com&#x2F;en-us&#x2F;cpp&#x2F;cpp&#x2F;standard-conversions&quot;&gt;found&lt;&#x2F;a&gt; &lt;a href=&quot;https:&#x2F;&#x2F;wiki.sei.cmu.edu&#x2F;confluence&#x2F;display&#x2F;c&#x2F;INT02-C.+Understand+integer+conversion+rules&quot;&gt;in&lt;&#x2F;a&gt; &lt;a href=&quot;http:&#x2F;&#x2F;en.cppreference.com&#x2F;w&#x2F;cpp&#x2F;language&#x2F;implicit_conversion&quot;&gt;other&lt;&#x2F;a&gt; &lt;a href=&quot;https:&#x2F;&#x2F;www.ibm.com&#x2F;support&#x2F;knowledgecenter&#x2F;en&#x2F;SSQ2R2_9.0.0&#x2F;com.ibm.tpf.toolkit.compilers.doc&#x2F;ref&#x2F;langref_os390&#x2F;cbclr21011.htm&quot;&gt;places&lt;&#x2F;a&gt;.
That said, I have had to read some of the standard&#x27;s sections relating to the topic and I have found them not too hard to read.
Might be a sign that I am slowly getting assimilated...&lt;&#x2F;p&gt;
&lt;p&gt;In the discussion that follows, I will consider an operation &lt;code&gt;op&lt;&#x2F;code&gt; on two operands &lt;code&gt;t1&lt;&#x2F;code&gt; and &lt;code&gt;t2&lt;&#x2F;code&gt; respectively of types &lt;code&gt;T1&lt;&#x2F;code&gt; and &lt;code&gt;T2&lt;&#x2F;code&gt;.
This can be conceptually represented as:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; style=&quot;background-color:#1d1f21;color:#c5c8c6;&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;&lt;span&gt;T1 t1;
&lt;&#x2F;span&gt;&lt;span&gt;T2 t2;
&lt;&#x2F;span&gt;&lt;span&gt;t1 op t2;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;In the discussion, I will consider the following cases:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;T1&lt;&#x2F;code&gt; and &lt;code&gt;T2&lt;&#x2F;code&gt; are the same type (yes, conversions &lt;em&gt;can&lt;&#x2F;em&gt; happen...)&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;T1&lt;&#x2F;code&gt; is floating point and &lt;code&gt;T2&lt;&#x2F;code&gt; is integral (or vice versa)&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;T1&lt;&#x2F;code&gt; and &lt;code&gt;T2&lt;&#x2F;code&gt; are both floating point, but different types&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;T1&lt;&#x2F;code&gt; and &lt;code&gt;T2&lt;&#x2F;code&gt; are both integral, but different types&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;These are almost all the situations covered in paragraph 11 of section 8 of the standard (but the last point is actually split in several sub-sections).
The only case I am not considering is when one of the type (or both) is a scoped enumeration (i.e. an &lt;code&gt;enum class&lt;&#x2F;code&gt;), because that had nothing to do with my project and I simply did not think about it as much.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;Same_type&quot;&gt;Same type&lt;&#x2F;h2&gt;
&lt;p&gt;Even if the types are not actually mixed, I had to consider the case where both operands are of the same type, i.e., &lt;code&gt;T1 == T2&lt;&#x2F;code&gt;.
Intuitively, nothing should happen in this case, but it turns out that it is a false assumption.
Because arithmetic operators in C++ do not accept any type smaller than &lt;code&gt;int&lt;&#x2F;code&gt;, &lt;a href=&quot;http:&#x2F;&#x2F;en.cppreference.com&#x2F;w&#x2F;cpp&#x2F;language&#x2F;implicit_conversion#Integral_promotion&quot;&gt;integral promotion&lt;&#x2F;a&gt; will take place before the operation.
This is described in section &lt;strong&gt;7.6 Integral promotions&lt;&#x2F;strong&gt; of the standard and can be roughly summarized as: any type smaller than &lt;code&gt;int&lt;&#x2F;code&gt; will be converted to &lt;code&gt;int&lt;&#x2F;code&gt; or &lt;code&gt;unsigned int&lt;&#x2F;code&gt;.
For instance, the following relation holds:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; style=&quot;background-color:#1d1f21;color:#c5c8c6;&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;short &lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;a&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;{&lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;}&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;short &lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;b&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;{&lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;}&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;static_assert&lt;&#x2F;span&gt;&lt;span&gt;( is_same_v&amp;lt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;int&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;decltype&lt;&#x2F;span&gt;&lt;span&gt;( a &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;+&lt;&#x2F;span&gt;&lt;span&gt; b ) &amp;gt; );
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Other than that, nothing else happens in terms of conversions.
As the name suggests, this applies only for integral types.
I would assume that is because the smallest floating point type is at least as large as an &lt;code&gt;int&lt;&#x2F;code&gt;, but I don&#x27;t think that is guaranteed.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;Mixed_integral_and_floating_point_types&quot;&gt;Mixed integral and floating point types&lt;&#x2F;h2&gt;
&lt;p&gt;Now, to look at mixed type arithmetic, the simplest case to start with is that of integral and floating point mixed operations, i.e. either &lt;code&gt;T1&lt;&#x2F;code&gt; or &lt;code&gt;T2&lt;&#x2F;code&gt; is a floating point and the other is integral.
In this case, the standard simply mandates that the integer value be converted to the floating point type:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; style=&quot;background-color:#1d1f21;color:#c5c8c6;&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;int &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;+ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;float &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;float&lt;&#x2F;span&gt;&lt;span&gt;)&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;int &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;+ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;float
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;unsigned long long &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;- &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;float &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;float&lt;&#x2F;span&gt;&lt;span&gt;)&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;unsigned long long &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;- &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;float
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;long double &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;+ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;unsigned &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;long double &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;+ &lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;long double&lt;&#x2F;span&gt;&lt;span&gt;)&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;unsigned
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;...
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The casts illustrated here are at least what &lt;em&gt;conceptually happens&lt;&#x2F;em&gt; if not what &lt;em&gt;actually happens&lt;&#x2F;em&gt;, but, as far as I can tell, it is what actually happens.
The type selected in this situation is not too surprising when you think about it.
At least for IEEE floating points, the range of the smallest floating point type (&lt;code&gt;float&lt;&#x2F;code&gt;: 3.4×10&lt;sup&gt;38&lt;&#x2F;sup&gt;) is much larger than that of the largest integer type (&lt;code&gt;unsigned long long&lt;&#x2F;code&gt;: 1.84×10&lt;sup&gt;19&lt;&#x2F;sup&gt;).
Thus, neglecting the issue of not being able to represent the value exactly if the mantissa of the floating point type cannot hold the value of the integer type, the floating point type will accommodate the integer type.
On top of that, the fractional part of the floating point would necessarily be lost (either by rounding, truncating or any other choice) if the conversion would be in the other direction.&lt;&#x2F;p&gt;
&lt;p&gt;So again, because of those two points, the standard here makes sense (at least to me!).&lt;&#x2F;p&gt;
&lt;h2 id=&quot;Mixed_floating_points&quot;&gt;Mixed floating points&lt;&#x2F;h2&gt;
&lt;p&gt;Next on the scale of simplicity is the case where both arguments are of a (different) floating point type.
In this case, the rule is simple: the smaller type is cast to the larger type before the operation.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; style=&quot;background-color:#1d1f21;color:#c5c8c6;&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;double &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&#x2F; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;float &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;double &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&#x2F; &lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;double&lt;&#x2F;span&gt;&lt;span&gt;)&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;float
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;long double &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;+ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;double &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;long double &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;+ &lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;long double&lt;&#x2F;span&gt;&lt;span&gt;)&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;double
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;...
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This makes sense.
The value in the smaller sized variable will fit in the larger one, so no change in value.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;Mixed_integrals&quot;&gt;Mixed integrals&lt;&#x2F;h2&gt;
&lt;p&gt;The final case is that of both operands being of integral types. Here, there are a few more things to consider, since for the same type size, there are signed and unsigned types (for instance, &lt;code&gt;int&lt;&#x2F;code&gt; and &lt;code&gt;unsigned int&lt;&#x2F;code&gt; must be the same size, e.g. 4 bytes).
This complicates matters a little and before we continue, we need to first define the concept of integer conversion rank (section &lt;strong&gt;7.15 Integer conversion rank&lt;&#x2F;strong&gt; of the standard document) which will be used in deciding the conversions to apply for mixed integer types arithmetic.
Once these ranks are defined, the first situation that applies in the following four scenarios is the conversion mandated by the standard:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;both have the same signedness, independent of ranks;&lt;&#x2F;li&gt;
&lt;li&gt;rank( unsigned ) &amp;gt;= rank( signed );&lt;&#x2F;li&gt;
&lt;li&gt;rank( signed ) &amp;gt; rank( unsigned ), unsigned in signed range;&lt;&#x2F;li&gt;
&lt;li&gt;rank( signed ) &amp;gt; rank( unsigned ), unsigned not in signed range;&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;Note that the order of the rank that I have written in situations 3 and 4 are not mentioned in the standard, but the fact that situations 1 and 2 do not apply implies that the rank of the signed integer is strictly greater than that of the unsigned integer, so I wrote it explicitly.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;Integer_conversion_rank&quot;&gt;Integer conversion rank&lt;&#x2F;h3&gt;
&lt;p&gt;From what I understand from reading the standard, the integer types in C++ are not given explicit values, but the relative ordering of the ranks is specified.
This can be &lt;strong&gt;&lt;em&gt;loosely&lt;&#x2F;em&gt;&lt;&#x2F;strong&gt; interpreted as: the integer ranks are in corresponding order of size where the larger integral types have a higher rank.
In particular, the standard says (section 7.15, par. 1.3):&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;The rank of &lt;code&gt;long long int&lt;&#x2F;code&gt; shall be greater than the rank of &lt;code&gt;long int&lt;&#x2F;code&gt;, which shall be greater than the rank of &lt;code&gt;int&lt;&#x2F;code&gt;, which shall be greater than the rank of &lt;code&gt;short int&lt;&#x2F;code&gt;, which shall be greater than the rank of &lt;code&gt;signed char&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;In order to remove any ambiguity, the standard adds quite a few details (there are 10 clauses to the section), but I believe that the following order of ranks, from smallest rank to highest rank, is mandated by the standard:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;bool&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;char&lt;&#x2F;code&gt;, &lt;code&gt;signed char&lt;&#x2F;code&gt;, &lt;code&gt;unsigned char&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;short&lt;&#x2F;code&gt;, &lt;code&gt;unsigned short&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;int&lt;&#x2F;code&gt;, &lt;code&gt;unsigned int&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;long&lt;&#x2F;code&gt;, &lt;code&gt;unsigned long&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;long long&lt;&#x2F;code&gt;, &lt;code&gt;unsigned long long&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;where for a given type size, signed and unsigned types share their rank.
I said the rule of thumb as presented above loosely interprets the standard because the standard does not explicitly mandate the size of &lt;code&gt;short&lt;&#x2F;code&gt;, &lt;code&gt;int&lt;&#x2F;code&gt;, &lt;code&gt;long&lt;&#x2F;code&gt;, and others.
This freedom is to allow the implementers to represent the various hardware architectures that exist.
I think this is mostly an artifact of history, since a lot of modern hardware is 32 or 64 bits, but it is still how the standard is written.
That said, it remains that on some machines, two types could share the same size, e.g. on a particular architecture, &lt;code&gt;sizeof(long)&lt;&#x2F;code&gt; could be the same as &lt;code&gt;sizeof(int)&lt;&#x2F;code&gt;.
In such a case, the standard would still stipulate that those types&#x27; ranks are different.
Specifically, in the example give, &lt;code&gt;long&lt;&#x2F;code&gt; would still have a higher rank than &lt;code&gt;int&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;Same_signedness&quot;&gt;Same signedness&lt;&#x2F;h3&gt;
&lt;p&gt;So, getting back to the mixed operations and the usual conversion, in the case of two integral types with the same signedness, i.e. both &lt;code&gt;T1&lt;&#x2F;code&gt; and &lt;code&gt;T2&lt;&#x2F;code&gt; are signed or both of them are unsigned, the standard mandates that the integer with the smaller rank be converted (after promotion), to the integer with the higher rank.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; style=&quot;background-color:#1d1f21;color:#c5c8c6;&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;long &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;+ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;int &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;long &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;+ &lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;long&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;int
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;unsigned short &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;* &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;unsigned int &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;unsigned int&lt;&#x2F;span&gt;&lt;span&gt;)&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;unsigned short &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;* &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;unsigned int
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;...
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The higher ranked integer will accommodate the values of the smaller ranked one without problem, and there are no considerations of sign, so no possible loss of value or overflow in the conversion (there is possible overflow in the &lt;em&gt;operation&lt;&#x2F;em&gt;, but not in the &lt;em&gt;conversion&lt;&#x2F;em&gt;).
This case is an easy one.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;Differing_signedness,_unsigned_with_larger_or_equal_rank&quot;&gt;Differing signedness, unsigned with larger or equal rank&lt;&#x2F;h3&gt;
&lt;p&gt;In this case, the standard says that the signed integer will be converted to the unsigned type.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; style=&quot;background-color:#1d1f21;color:#c5c8c6;&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;int &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;+ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;unsigned int &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;unsigned int&lt;&#x2F;span&gt;&lt;span&gt;)&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;int &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;+ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;unsigned int
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;short &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;- &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;unsigned int &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;unsigned int&lt;&#x2F;span&gt;&lt;span&gt;)&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;short &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;- &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;unsigned int
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;...
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The fact that the operation then yields the correct answer is mandated by the standard.
In section &lt;strong&gt;7.8 Integral conversions&lt;&#x2F;strong&gt;, the standard says:&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;If the destination type is unsigned, the resulting value is the least unsigned integer congruent to the source integer (modulo 2&lt;sup&gt;&lt;em&gt;n&lt;&#x2F;em&gt;&lt;&#x2F;sup&gt; where &lt;em&gt;n&lt;&#x2F;em&gt; is the number of bits used to represent the unsigned type).
[ &lt;em&gt;Note&lt;&#x2F;em&gt;: In a two’s complement representation, this conversion is conceptual and there is no change in the bit pattern (if there is no truncation). — &lt;em&gt;end note&lt;&#x2F;em&gt;]&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;Because of the modulo 2&lt;sup&gt;&lt;em&gt;n&lt;&#x2F;em&gt;&lt;&#x2F;sup&gt; arithmetic, this will give the correct unsigned answer... most of the time.
See the discussion in the &lt;a href=&quot;https:&#x2F;&#x2F;ghlecl.github.io&#x2F;posts&#x2F;usual_conversions&#x2F;#Keep_informed&quot;&gt;last section&lt;&#x2F;a&gt; for an example where this rule yields a surprising result.&lt;&#x2F;p&gt;
&lt;p&gt;This being the case, if you are putting the result of the operation in a variable, at this point, it is worth thinking about that variable&#x27;s type, because if that type is not the type of the unsigned operand (or larger unsigned integral type), you will incur a conversion.
That is, while the operation is guaranteed to be correct by the standard, putting it back into anything but a large enough unsigned integral type might not yield the result you expect.
In a smaller unsigned integral type, there is at least another modulo conversion happening.
If the type is signed (whether it is large enough or not), then the result is implementation defined as stipulated by the standard, again in section 7.8:&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;If the destination type is signed, the value is unchanged if it can be represented in the destination type; otherwise, the value is implementation-defined.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;The standard does not specify what happens in this case and instead gives latitude to the compiler vendor saying the result is implementation defined.
This means that if you rely on this conversion, the behavior might not be portable (&lt;strong&gt;&lt;em&gt;not&lt;&#x2F;em&gt;&lt;&#x2F;strong&gt; undefined as in the case of overflow, just not portable and tied to the compiler you use). On &lt;a href=&quot;http:&#x2F;&#x2F;www.cs.cornell.edu&#x2F;%7Etomf&#x2F;notes&#x2F;cps104&#x2F;twoscomp.html&quot;&gt;two&#x27;s complement&lt;&#x2F;a&gt; machines, this will actually give you wrapping behavior, but relying on this is actually non portable (even if, from what I understand, most hardware uses two&#x27;s complement these days).
On other architectures, the behavior will be different and so portable code should not rely on the conversions without some kind of checks.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;Differing_signedness,_signed_with_larger_rank,_unsigned_in_range&quot;&gt;Differing signedness, signed with larger rank, unsigned in range&lt;&#x2F;h3&gt;
&lt;p&gt;Here, the standard says that the unsigned integral type is converted to the signed integral type.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; style=&quot;background-color:#1d1f21;color:#c5c8c6;&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;long long int &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;+ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;unsigned long&lt;&#x2F;span&gt;&lt;span&gt;( value &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span&gt; long_long_int_max )
&lt;&#x2F;span&gt;&lt;span&gt;                           &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;long long int &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;+ &lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;long long int&lt;&#x2F;span&gt;&lt;span&gt;)&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;unsigned long
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Given that the unsigned integer is representable in the range of the signed integer, the conversion will work as stipulated in section 7.8 of the standard that I quoted in the previous part of this post (at least, that is my understanding).
So that should always give the correct answer since the unsigned &lt;em&gt;value&lt;&#x2F;em&gt; is in range of the signed &lt;em&gt;type&lt;&#x2F;em&gt;.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;Differing_signedness,_signed_with_larger_rank,_unsigned_not_in_range&quot;&gt;Differing signedness, signed with larger rank, unsigned not in range&lt;&#x2F;h3&gt;
&lt;p&gt;Here, the standard says that both operands are converted to the unsigned type of same rank as that of the signed integer in the operation.
The unsigned should be in range of the unsigned with the larger rank (i.e. the unsigned with same rank as the signed in the operation, which is higher than that of the unsigned in the operation).
The signed one will be modulo 2&lt;sup&gt;&lt;em&gt;n&lt;&#x2F;em&gt;&lt;&#x2F;sup&gt; converted.
Thus the result should be right given the modulo arithmetic, but with the usual caveats of what you do with the result.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;Back_to_the_first_example&quot;&gt;Back to the first example&lt;&#x2F;h2&gt;
&lt;p&gt;So coming back to the first example, let&#x27;s see if I can apply the rules to it.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; style=&quot;background-color:#1d1f21;color:#c5c8c6;&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;float &lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;flt&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;{&lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;15.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;f&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;}&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;long &lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;lng_a&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;{&lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;30&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;L&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;}&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;long&lt;&#x2F;span&gt;&lt;span&gt; lng_b &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; lng_a &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;+&lt;&#x2F;span&gt;&lt;span&gt; flt;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;According to the conversion rules, I would say that the &lt;code&gt;long&lt;&#x2F;code&gt; value will first be converted to &lt;code&gt;float&lt;&#x2F;code&gt; to allow the addition, and that the resulting &lt;code&gt;float&lt;&#x2F;code&gt; will be truncated&lt;sup id=&quot;ftntref:1&quot;&gt;&lt;a href=&quot;#ftnt:1&quot;&gt;1&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;, which is what the standard mandates in section &lt;strong&gt;7.10 Floating-integral conversions&lt;&#x2F;strong&gt;:&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;A prvalue of a floating-point type can be converted to a prvalue of an integertype.
The conversion truncates; that is, the fractional part is discarded.
The behavior is undefined if the truncated value cannot be represented in the destination type.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;The numbers above are small enough that it just works as expected!
This is probably true for a lot of use cases, which is why I think I can stand by my initial affirmation that &amp;quot;applying binary operations to different types might seem trivial in C++, because it mostly just works&amp;quot;.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;Keep_informed&quot;&gt;Keep informed&lt;&#x2F;h2&gt;
&lt;p&gt;As mentioned in the previous post, there is a (controversial?) &lt;a href=&quot;http:&#x2F;&#x2F;www.open-std.org&#x2F;jtc1&#x2F;sc22&#x2F;wg21&#x2F;docs&#x2F;papers&#x2F;2018&#x2F;p0907r0.html&quot;&gt;proposal&lt;&#x2F;a&gt; that has been brought to the the C++ standards committee by JF Bastien which would make two&#x27;s complement the only allowed representation for signed integers.
This could change some of the details of this article, namely the parts where conversion from unsigned to signed is implementation defined.
So in C++20 or C++23, the information here could be out of date (already).&lt;&#x2F;p&gt;
&lt;p&gt;Also, because of conversions, the following assert will actually fire as the operation will yield false even if the mathematics would suggest otherwise:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; style=&quot;background-color:#1d1f21;color:#c5c8c6;&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;assert&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;( &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;-&lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;1 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;lt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;u &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;That is because this is a case where both integers have the same rank (the &lt;code&gt;-1&lt;&#x2F;code&gt; literal is &lt;code&gt;int&lt;&#x2F;code&gt; and the &lt;code&gt;0u&lt;&#x2F;code&gt; literal is &lt;code&gt;unsigned int&lt;&#x2F;code&gt;), but differing signedness.
Here, according to the rules above, the signed integer is converted to the unsigned integer, which means &lt;code&gt;-1&lt;&#x2F;code&gt; becomes the largest unsigned integer, which will not be smaller than 0.
This kind of surprising behavior is currently being discussed in the context of a &lt;a href=&quot;http:&#x2F;&#x2F;open-std.org&#x2F;JTC1&#x2F;SC22&#x2F;WG21&#x2F;docs&#x2F;papers&#x2F;2017&#x2F;p0515r0.pdf&quot;&gt;proposal by Herb Sutter&lt;&#x2F;a&gt;.
Richard Smith is &lt;a href=&quot;http:&#x2F;&#x2F;www.open-std.org&#x2F;jtc1&#x2F;sc22&#x2F;wg21&#x2F;docs&#x2F;papers&#x2F;2018&#x2F;p0946r0.html&quot;&gt;proposing&lt;&#x2F;a&gt; to bring consistency between the new three-way comparison operator (a.k.a the &lt;em&gt;spaceship operator&lt;&#x2F;em&gt; &lt;code&gt;&amp;lt;=&amp;gt;&lt;&#x2F;code&gt;) and the usual C comparison operators.
This might have no impact on what I discussed here or might change it completely.
I will admit that I am aware of the proposal, but I have not had time to read it through.&lt;&#x2F;p&gt;
&lt;p&gt;In any case, the two proposals above, if they are adopted, will change some of what I discussed here, so keep informed if this matters to you!&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;Notes&quot;&gt;Notes&lt;&#x2F;h2&gt;
&lt;p&gt;I would like to thank &lt;a href=&quot;https:&#x2F;&#x2F;twitter.com&#x2F;PatriceRoy1&quot;&gt;Patrice Roy&lt;&#x2F;a&gt; for reading my post and giving me some advice on it. His time is greatly appreciated.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;p id=&quot;ftnt:1&quot;&gt;&lt;sup&gt;[1]&lt;&#x2F;sup&gt;&amp;nbsp;&lt;a href=&quot;https:&#x2F;&#x2F;tinyurl.com&#x2F;ycdz8rky&quot;&gt;Here is a link&lt;&#x2F;a&gt; to the code of the first example in compiler explorer (put in a main function so it compiles).
You can see the &lt;code&gt;cvtsi2ss&lt;&#x2F;code&gt;, &lt;code&gt;addss&lt;&#x2F;code&gt; and &lt;code&gt;cvttss2si&lt;&#x2F;code&gt; instructions which respectively convert the &lt;code&gt;long&lt;&#x2F;code&gt; to a &lt;code&gt;float&lt;&#x2F;code&gt;, adds the resulting &lt;code&gt;float&lt;&#x2F;code&gt; with the &lt;code&gt;flt&lt;&#x2F;code&gt; variable, and converts back the result to a &lt;code&gt;long&lt;&#x2F;code&gt;.&amp;nbsp;&lt;a href=&quot;#ftntref:1&quot;&gt;&amp;#8617;&amp;#65038;&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;

&lt;p id=&quot;ftnt:2&quot;&gt;&lt;sup&gt;[2]&lt;&#x2F;sup&gt;&amp;nbsp;I believe assembly instructions, assembly code, machine code, and opcodes are roughly the same (according to Wikipedia, some assembly instructions do not map directly to opcodes, but most do).
In the context of this post, I don&#x27;t think it makes much of a difference.
Thus, I use the terms interchangeably, but I might be assuming a bit.
I am out of my depths in this domain.&amp;nbsp;&lt;a href=&quot;#ftntref:2&quot;&gt;&amp;#8617;&amp;#65038;&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;p&gt;
&lt;p id=&quot;ftnt:3&quot;&gt;&lt;sup&gt;[3]&lt;&#x2F;sup&gt;&amp;nbsp;The official published document must be purchased from the ISO organization, but the draft papers are freely available and can be found on the web.
For instance, a C++17 draft paper (the latest draft before publication I believe, but I might be wrong) can be found &lt;a href=&quot;http:&#x2F;&#x2F;www.open-std.org&#x2F;jtc1&#x2F;sc22&#x2F;wg21&#x2F;docs&#x2F;papers&#x2F;2017&#x2F;n4659.pdf&quot;&gt;here&lt;&#x2F;a&gt;.&amp;nbsp;&lt;a href=&quot;#ftntref:3&quot;&gt;&amp;#8617;&amp;#65038;&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
</content>
  </entry>
  <entry xml:lang="en">
    <title>Integer binary representations</title>
    <author>codeattempts@gmail.com</author>
    <published>2018-04-30</published>
    <updated>2018-04-30</updated>
    <link href="https://ghlecl.github.io/posts/integer_representations/" type="text/html"/>
    <id>https://ghlecl.github.io/posts/integer_representations/</id>
    <summary>
   Integer binary representations
I had never had to look closely at integer binary representations in computers.
The mental model I had for them was not wrong, but it turns out it was sub-optimal and there are better ways to do things.
If you use high level abstractions and do not mainly work with fundamental types, or if you do not convert between integer types, you do not have to be mindful of the binary representation of</summary>
    <content>&lt;h1 id=&quot;Integer_binary_representations&quot;&gt;Integer binary representations&lt;&#x2F;h1&gt;
&lt;p&gt;I had never had to look closely at integer binary representations in computers.
The mental model I had for them was not wrong, but it turns out it was sub-optimal and there are better ways to do things.
If you use high level abstractions and do not mainly work with fundamental types, or if you do not convert between integer types, you do not have to be mindful of the binary representation of integers all the time as you program.
Thus, before the last few weeks, I never had to look more closely at that, but I have started a project for which binary representation had a direct effect and I finally looked into them.
I thought I would write down some notes and observations.&lt;&#x2F;p&gt;
&lt;p&gt;I am pretty sure that this is probably covered in all computer science degrees and so might seem trivial and basic knowledge to many programmers, but since I don&#x27;t have a CS degree and never had to think much about binary representation, this was informative to me!
I should also point out that although I have used the C and C++ standards as references, the concepts here are not exclusive to these languages.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;Unsigned_integers&quot;&gt;Unsigned integers&lt;&#x2F;h2&gt;
&lt;p&gt;The &lt;a href=&quot;http:&#x2F;&#x2F;www.open-std.org&#x2F;jtc1&#x2F;sc22&#x2F;WG14&#x2F;www&#x2F;docs&#x2F;n1570.pdf&quot;&gt;C standard&lt;&#x2F;a&gt; is explicit in its definition of unsigned integers (at least up to C11, the latest standard at the time of writing).
It can be found in section &lt;strong&gt;6.2.6.2 Integer types&lt;&#x2F;strong&gt;, paragraph 1:&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;For unsigned integer types other than unsigned char, the bits of the object
representation shall be divided into two groups: value bits and padding bits
(there need not be any of the latter). If there are &lt;code&gt;N&lt;&#x2F;code&gt; value bits, each bit
shall represent a different power of 2 between 1 and 2&lt;sup&gt;&lt;code&gt;N&lt;&#x2F;code&gt;−1&lt;&#x2F;sup&gt;, so that
objects of that type shall be capable of representing values from 0 to
2&lt;sup&gt;&lt;code&gt;N&lt;&#x2F;code&gt;&lt;&#x2F;sup&gt; − 1 using a pure binary representation; this shall
be known as the value representation. The values of any padding bits are
unspecified.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;which is sometimes referred to as the pure binary representation.
Other than the fact that the wording confused me at first&lt;sup id=&quot;ftntref:1&quot;&gt;&lt;a href=&quot;#ftnt:1&quot;&gt;1&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;, this basically describes a usual &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Binary_number&quot;&gt;binary&lt;&#x2F;a&gt; &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Positional_notation&quot;&gt;positional number notation&lt;&#x2F;a&gt;, which is much like the decimal positional number notation we commonly use but forget about.
This is rather intuitive if you are familiar with positional number systems.
The most significant bit position (&lt;em&gt;i.e.&lt;&#x2F;em&gt; the largest exponent bit) is not specified in the standard as it varies with hardware (and is more complicated then it seems if you get into byte ordering on top of that).
The range of the pure binary unsigned representation is the following:
&lt;p style=&quot;text-align: center;&quot;&gt;0   to   2&lt;sup&gt;&lt;code&gt;n&lt;&#x2F;code&gt;&lt;&#x2F;sup&gt; – 1&lt;&#x2F;p&gt;
&lt;&#x2F;p&gt;
&lt;p&gt;where &lt;code&gt;n&lt;&#x2F;code&gt; is the number of bits used in the representation.
That is how you get to the range 0 to 255 (= 2&lt;sup&gt;8&lt;&#x2F;sup&gt; – 1) for an 8 bit number.&lt;&#x2F;p&gt;
&lt;p&gt;On the other hand, the &lt;a href=&quot;http:&#x2F;&#x2F;www.open-std.org&#x2F;JTC1&#x2F;SC22&#x2F;WG21&#x2F;docs&#x2F;papers&#x2F;2017&#x2F;n4659.pdf&quot;&gt;C++ standard&lt;&#x2F;a&gt; is more vague on the subject (at least up to C++17, the latest standard at the time of writing).
As far as I can tell, it does not impose an explicit representation for its unsigned type.
Section &lt;strong&gt;6.9 Types&lt;&#x2F;strong&gt; of the standard deals with type representations and the closest I have found to having an explicit representation specified for unsigned types is footnote 45 which says:&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;The intent is that the memory model of C++ is compatible with that of ISO&#x2F;IEC 9899 Programming Language C.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;which would suggest, I think, that the type representations have to be compatible.
But that is not exactly explicit.
Then, in paragraph 3, section &lt;strong&gt;6.9.1 Fundamental types&lt;&#x2F;strong&gt;, the standard says:&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;The range of non-negative values of a signed integer type is a subrange of the
corresponding unsigned integer type, the representation of the same value in
each of the two types is the same, and the value representation of each
corresponding signed&#x2F;unsigned type shall be the same. [...]  The signed and
unsigned integer types shall satisfy the constraints given in the C standard,
section 5.2.4.2.1.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;This does not imply a pure binary representation.
That said, most if not all C++ implementations in the field will actually have a pure binary representation for unsigned integers.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;Signed_integers&quot;&gt;Signed integers&lt;&#x2F;h2&gt;
&lt;p&gt;There are a few &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Signed_number_representations&quot;&gt;signed integer representations&lt;&#x2F;a&gt; and, for now at least&lt;sup id=&quot;ftntref:2&quot;&gt;&lt;a href=&quot;#ftnt:2&quot;&gt;2&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;, none of them is explicitly specified (or forbidden) by the C or C++ standards.
I have looked at three different representations, the last one being the most common if I understand correctly.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;Signed_magnitude&quot;&gt;Signed magnitude&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;a href=&quot;(https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Signed_number_representations#Signed_magnitude_representation)&quot;&gt;Signed magnitude&lt;&#x2F;a&gt; is the obvious solution to the problem: take the first bit and make it a sign bit, &lt;em&gt;i.e.&lt;&#x2F;em&gt; model the + or – sign as a 0 or a 1.
This is actually the mental model I had for signed integers.
The range of this solution is:
&lt;p style=&quot;text-align: center;&quot;&gt;–(2&lt;sup&gt;(&lt;code&gt;n&lt;&#x2F;code&gt; – 1)&lt;&#x2F;sup&gt; – 1)   
to   2&lt;sup&gt;(&lt;code&gt;n&lt;&#x2F;code&gt; – 1)&lt;&#x2F;sup&gt; – 1&lt;&#x2F;p&gt;
&lt;&#x2F;p&gt;
&lt;p&gt;where &lt;code&gt;n&lt;&#x2F;code&gt; is the number of bits in the representation.
This gives only one less number then the unsigned solution, because there are now two bit patterns that represent 0.
For instance, for 8 bits, both:
&lt;p style=&quot;text-align: center;&quot;&gt;&lt;code&gt;00000000&lt;&#x2F;code&gt;   and   &lt;code&gt;10000000&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;p&gt;
&lt;p&gt;represent the number zero (albeit, positive 0 and negative 0).
This is not really a problem although comparison with zero now has to check for two cases.&lt;&#x2F;p&gt;
&lt;p&gt;Although the signed magnitude approach seems very natural, it makes the hardware to do simple arithmetic operations (+, –) more complex to write.
&lt;a href=&quot;https:&#x2F;&#x2F;www2.cs.duke.edu&#x2F;courses&#x2F;cps104&#x2F;fall98&#x2F;lectures&#x2F;week1-l2&#x2F;tsld021.htm&quot;&gt;From what&lt;&#x2F;a&gt; &lt;a href=&quot;http:&#x2F;&#x2F;scientific-solutions.com&#x2F;products&#x2F;faq&#x2F;ssi_faq_bin_sm_2comp.shtml&quot;&gt;I read&lt;&#x2F;a&gt; (I am no expert), this is mostly because the sign bit has to be dealt with before the operation and the circuitry becomes more complex.
It is mainly for this reason that other approaches have been developed.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;One&#x27;s_complement&quot;&gt;One&#x27;s complement&lt;&#x2F;h3&gt;
&lt;p&gt;In the &lt;a href=&quot;(https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Ones%27_complement)&quot;&gt;one&#x27;s complement&lt;&#x2F;a&gt; signed number representation, a negative number is obtained by taking the complement of its unsigned representation, &lt;em&gt;i.e.&lt;&#x2F;em&gt; inverting every bit.
The range of this binary representation is the same as that of the signed magnitude representation, for the exact same reason: there are two ways of representing the number 0.
So, again, the range is:
&lt;p style=&quot;text-align: center;&quot;&gt;–(2&lt;sup&gt;(&lt;code&gt;n&lt;&#x2F;code&gt; – 1)&lt;&#x2F;sup&gt; – 1)   
to   2&lt;sup&gt;(&lt;code&gt;n&lt;&#x2F;code&gt; – 1)&lt;&#x2F;sup&gt; – 1&lt;&#x2F;p&gt;
&lt;&#x2F;p&gt;
&lt;p&gt;where &lt;code&gt;n&lt;&#x2F;code&gt; is the number of bits in the representation and again, there are two representations of zero, albeit not the same as for signed magnitude (e.g. for 8 bits):
&lt;p style=&quot;text-align: center;&quot;&gt;&lt;code&gt;00000000&lt;&#x2F;code&gt;   and   &lt;code&gt;11111111&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;p&gt;
&lt;p&gt;This binary representation makes algorithms for the addition and subtraction of integers much simpler than the signed magnitude representation.
With one&#x27;s complement encoding, the usual algorithm that we do by hand for addition works and yields the correct value so long as the leftmost carry bit is added back to the result (if it is 0, that&#x27;s fairly easy ;-) ).
There is a way to remove the need to add back the carry bit and that is one characteristic of the next representation discussed.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;Two&#x27;s_complement&quot;&gt;Two&#x27;s complement&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Two%27s_complement&quot;&gt;Two&#x27;s complement&lt;&#x2F;a&gt; is the last method discussed (although not the last one there is, see &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Signed_number_representations&quot;&gt;Wikipedia&#x27;s article&lt;&#x2F;a&gt; for at least two more).
This binary representation scheme is, today at least, the most prevalent signed integer representation in hardware.
This encoding is almost the same as one&#x27;s complement, except that once you have calculated the inverted bits of the number, you add one to it.
Two&#x27;s complement range is:
&lt;p style=&quot;text-align: center;&quot;&gt;–(2&lt;sup&gt;(&lt;code&gt;n&lt;&#x2F;code&gt; – 1)&lt;&#x2F;sup&gt;)  
to   2&lt;sup&gt;(&lt;code&gt;n&lt;&#x2F;code&gt; – 1)&lt;&#x2F;sup&gt; – 1&lt;&#x2F;p&gt;
&lt;&#x2F;p&gt;
&lt;p&gt;where &lt;code&gt;n&lt;&#x2F;code&gt; is the number of bits in the representation.
It should be noted that the range is not exactly the same as the one&#x27;s complement: it is larger by one.
This is explained by the fact that in this encoding scheme, there is only one representation of 0, and it is the same as the unsigned 0, &lt;em&gt;i.e.&lt;&#x2F;em&gt; all bits set to 0.
Opposed to the one&#x27;s complement representation, in this scheme, when all the bits are set to 1, the value encoded is not 0, but rather the smallest negative number (&lt;em&gt;i.e.&lt;&#x2F;em&gt; -1).
For 8 bits, the first row of the following table illustrates this:&lt;&#x2F;p&gt;
&lt;table style=&quot;margin-left:auto; margin-right:auto;&quot;&gt;
   &lt;tr&gt;
      &lt;th style=&quot;padding:0px 15px;text-align:center;&quot;&gt;bits&lt;br&gt;&lt;&#x2F;th&gt;
      &lt;th style=&quot;padding:0px 15px;text-align:center;&quot;&gt;two&#x27;s&lt;br&#x2F;&gt;complement&lt;&#x2F;td&gt;
      &lt;th style=&quot;padding:0px 15px;text-align:center;&quot;&gt;unsigned&lt;&#x2F;td&gt;
   &lt;&#x2F;tr&gt;
   &lt;tr&gt;
      &lt;td style=&quot;padding:0px 15px;text-align:center;&quot;&gt;11111111&lt;br&gt;&lt;&#x2F;td&gt;
      &lt;td style=&quot;padding:0px 15px;text-align:center;&quot;&gt;-1&lt;&#x2F;td&gt;
      &lt;td style=&quot;padding:0px 15px;text-align:center;&quot;&gt;255&lt;&#x2F;td&gt;
   &lt;&#x2F;tr&gt;
   &lt;tr&gt;
      &lt;td style=&quot;padding:0px 15px;text-align:center;&quot;&gt;01111111&lt;br&gt;&lt;&#x2F;td&gt;
      &lt;td style=&quot;padding:0px 15px;text-align:center;&quot;&gt;127&lt;&#x2F;td&gt;
      &lt;td style=&quot;padding:0px 15px;text-align:center;&quot;&gt;127&lt;&#x2F;td&gt;
   &lt;&#x2F;tr&gt;
   &lt;tr&gt;
      &lt;td style=&quot;padding:0px 15px;text-align:center;&quot;&gt;10000000&lt;br&gt;&lt;&#x2F;td&gt;
      &lt;td style=&quot;padding:0px 15px;text-align:center;&quot;&gt;-128&lt;&#x2F;td&gt;
      &lt;td style=&quot;padding:0px 15px;text-align:center;&quot;&gt;128&lt;&#x2F;td&gt;
   &lt;&#x2F;tr&gt;
   &lt;tr&gt;
      &lt;td style=&quot;padding:0px 15px;text-align:center;&quot;&gt;10000001&lt;br&gt;&lt;&#x2F;td&gt;
      &lt;td style=&quot;padding:0px 15px;text-align:center;&quot;&gt;-127&lt;&#x2F;td&gt;
      &lt;td style=&quot;padding:0px 15px;text-align:center;&quot;&gt;129&lt;&#x2F;td&gt;
   &lt;&#x2F;tr&gt;
   &lt;tr&gt;
      &lt;td style=&quot;padding:0px 15px;text-align:center;&quot;&gt;11010111&lt;br&gt;&lt;&#x2F;td&gt;
      &lt;td style=&quot;padding:0px 15px;text-align:center;&quot;&gt;-41&lt;&#x2F;td&gt;
      &lt;td style=&quot;padding:0px 15px;text-align:center;&quot;&gt;215&lt;&#x2F;td&gt;
   &lt;&#x2F;tr&gt;
   &lt;tr&gt;
      &lt;td style=&quot;padding:0px 15px;text-align:center;&quot;&gt;11111110&lt;br&gt;&lt;&#x2F;td&gt;
      &lt;td style=&quot;padding:0px 15px;text-align:center;&quot;&gt;-2&lt;&#x2F;td&gt;
      &lt;td style=&quot;padding:0px 15px;text-align:center;&quot;&gt;254&lt;&#x2F;td&gt;
   &lt;&#x2F;tr&gt;
&lt;&#x2F;table&gt;
&lt;p&gt;Practically, when you get to the largest signed (positive) integer you can represent with the number of bits available, if you increment by one, the bit pattern becomes that of the lowest signed (negative) integer you can represent (which is illustrated in the second and third rows of the table above).
After that, increasing the bit pattern by 1 will increase the value by one (fourth row of the table).
Citing &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Two%27s_complement#Why_it_works&quot;&gt;Wikipedia&#x27;s entry on two&#x27;s complement&lt;&#x2F;a&gt;&lt;sup id=&quot;ftntref:3&quot;&gt;&lt;a href=&quot;#ftnt:3&quot;&gt;3&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;:&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;Fundamentally, the system represents negative integers by counting backward and
wrapping around.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;This representation then has the interesting property that when going from unsigned to signed or vice-versa by only reinterpreting the bit pattern as if it were the destination type, the behavior is that of modulo 2&lt;sup&gt;&lt;code&gt;n&lt;&#x2F;code&gt;-1&lt;&#x2F;sup&gt; wrapping (which is the same as the wrapping behavior mandated by the C standard for unsigned integers: wrapping to the value of the highest value plus one).&lt;&#x2F;p&gt;
&lt;p&gt;Another property of this encoding scheme, and probably a more significant advantage compared to the single representation of zero, is that the carry bit for the usual algorithm of arithmetic operations (additions, subtractions) must simply be ignored to give the correct result.
This differs from the one&#x27;s complement encoding scheme, where it has to be added back.
Thus, arithmetic operations are even simpler to implement.
This is probably a big reason why two&#x27;s complement is the dominating binary representation right now.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;Final_thoughts&quot;&gt;Final thoughts&lt;&#x2F;h2&gt;
&lt;p&gt;I never had to think much about the binary representation of the integers I used.
I guess that can be attributed to me never working on the kind of applications where it matters or always working with a single architecture.
Given that I do not, for instance, often do binary file manipulation or networking, I am not sure I will personally use this knowledge very often, but in any case, it is good to know.&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;Notes&quot;&gt;Notes&lt;&#x2F;h2&gt;
&lt;p id=&quot;ftnt:1&quot;&gt;&lt;sup&gt;[1]&lt;&#x2F;sup&gt;&amp;nbsp;The standard talks about the values represented and not the exponent, so that it talks about the series:&lt;&#x2F;p&gt;
&lt;p&gt;   1, 2, 4, 8, 16...&lt;&#x2F;p&gt;
&lt;p&gt;of successive evaluations of the exponents of 2 rather than the successive exponents themselves, which actually start at zero.
This had confused me at first, but &lt;a href=&quot;http:&#x2F;&#x2F;h-deb.clg.qc.ca&#x2F;&quot;&gt;Patrice Roy&lt;&#x2F;a&gt; and &lt;a href=&quot;http:&#x2F;&#x2F;www.aaronballman.com&#x2F;&quot;&gt;Aaron Ballman&lt;&#x2F;a&gt; helped me see that I had misinterpreted the standard.
Thanks to both of them.&amp;nbsp;&lt;a href=&quot;#ftntref:1&quot;&gt;&amp;#8617;&amp;#65038;&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p id=&quot;ftnt:2&quot;&gt;&lt;sup&gt;[2]&lt;&#x2F;sup&gt;&amp;nbsp;In the 2018 Jacksonville meeting of the ISO C++ Committee, a paper has been presented to officially &lt;a href=&quot;http:&#x2F;&#x2F;www.open-std.org&#x2F;jtc1&#x2F;sc22&#x2F;wg21&#x2F;docs&#x2F;papers&#x2F;2018&#x2F;p0907r0.html&quot;&gt;make signed integers two&#x27;s complement&lt;&#x2F;a&gt;.
There is no certainty on the future of this paper, but the idea was also presented to the C standard committee and the discussions in both committee will take place to see if this is something they will pursue.&amp;nbsp;&lt;a href=&quot;#ftntref:2&quot;&gt;&amp;#8617;&amp;#65038;&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p id=&quot;ftnt:3&quot;&gt;&lt;sup&gt;[3]&lt;&#x2F;sup&gt;&amp;nbsp;The sentence was taken from the linked page on April 28 2018.&amp;nbsp;&lt;a href=&quot;#ftntref:3&quot;&gt;&amp;#8617;&amp;#65038;&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
</content>
  </entry>
  <entry xml:lang="en">
    <title>Friends only class</title>
    <author>codeattempts@gmail.com</author>
    <published>2017-11-28T13:30:00</published>
    <updated>2017-11-28T13:30:00</updated>
    <link href="https://ghlecl.github.io/posts/friends_only_class/" type="text/html"/>
    <id>https://ghlecl.github.io/posts/friends_only_class/</id>
    <summary>
   Friends only class
Having read a few blog posts and watched a short presentation on the subject of strong typedefs, I decided to look into their use and implementation.
In at least two implementations I have looked at (namely type_safe and opaque), I have found that mixin classes are used to add functionality to the new type.
For instance:
class my_strong_typedef : public addable, public divisible
{};

Those mixin were implemented as empty classes that only have friend functions</summary>
    <content>&lt;h1 id=&quot;Friends_only_class&quot;&gt;Friends only class&lt;&#x2F;h1&gt;
&lt;p&gt;Having read &lt;a href=&quot;https:&#x2F;&#x2F;arne-mertz.de&#x2F;2016&#x2F;11&#x2F;stronger-types&#x2F;&quot;&gt;a few&lt;&#x2F;a&gt; &lt;a href=&quot;http:&#x2F;&#x2F;www.fluentcpp.com&#x2F;2016&#x2F;12&#x2F;05&#x2F;named-constructors&#x2F;&quot;&gt;blog posts&lt;&#x2F;a&gt; and watched a short &lt;a href=&quot;https:&#x2F;&#x2F;youtube.com&#x2F;watch?v=jLdSjh8oqmE&quot;&gt;presentation&lt;&#x2F;a&gt; on the subject of &lt;a href=&quot;http:&#x2F;&#x2F;foonathan.net&#x2F;blog&#x2F;2016&#x2F;10&#x2F;19&#x2F;strong-typedefs.html&quot;&gt;strong typedefs&lt;&#x2F;a&gt;, I decided to look into their use and implementation.
In at least two implementations I have looked at (namely &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;foonathan&#x2F;type_safe&quot;&gt;type_safe&lt;&#x2F;a&gt; and &lt;a href=&quot;https:&#x2F;&#x2F;sourceforge.net&#x2F;projects&#x2F;opaque-typedef&#x2F;&quot;&gt;opaque&lt;&#x2F;a&gt;), I have found that mixin classes are used to add functionality to the new type.
For instance:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;C++&quot; style=&quot;background-color:#1d1f21;color:#c5c8c6;&quot; class=&quot;language-C++ &quot;&gt;&lt;code class=&quot;language-C++&quot; data-lang=&quot;C++&quot;&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;class &lt;&#x2F;span&gt;&lt;span style=&quot;color:#f0c674;&quot;&gt;my_strong_typedef &lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;public &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5bd68;&quot;&gt;addable&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;public &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5bd68;&quot;&gt;divisible
&lt;&#x2F;span&gt;&lt;span&gt;{};
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Those mixin were implemented as empty classes that only have friend functions in them.
I was wondering what was the use of such constructs.
Turns out, it is an application of the &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Barton%E2%80%93Nackman_trick&quot;&gt;Barton–Nackman trick&lt;&#x2F;a&gt; to allow &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Argument-dependent_name_lookup&quot;&gt;argument dependent name lookup&lt;&#x2F;a&gt; (ADL) to find the function.&lt;&#x2F;p&gt;
&lt;p&gt;When the compiler sees the following expression:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;C++&quot; style=&quot;background-color:#1d1f21;color:#c5c8c6;&quot; class=&quot;language-C++ &quot;&gt;&lt;code class=&quot;language-C++&quot; data-lang=&quot;C++&quot;&gt;&lt;span&gt;lt &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;+&lt;&#x2F;span&gt;&lt;span&gt; rt
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;it must lookup the &lt;code&gt;operator+&lt;&#x2F;code&gt; function to use with the types of &lt;code&gt;lt&lt;&#x2F;code&gt; and &lt;code&gt;rt&lt;&#x2F;code&gt;.
From my understanding, it is equivalent to an unqualified call to the operator, as in:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;C++&quot; style=&quot;background-color:#1d1f21;color:#c5c8c6;&quot; class=&quot;language-C++ &quot;&gt;&lt;code class=&quot;language-C++&quot; data-lang=&quot;C++&quot;&gt;&lt;span&gt;operator&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;+&lt;&#x2F;span&gt;&lt;span&gt;( lt, rt )
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The various &lt;a href=&quot;http:&#x2F;&#x2F;en.cppreference.com&#x2F;w&#x2F;cpp&#x2F;language&#x2F;lookup&quot;&gt;name lookup&lt;&#x2F;a&gt; rules of C++, which are not so simple, are then used to find which function to call and an important aspect in this case is that during ADL:&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;namespace-scoped friend functions (and function templates) that are declared in an associated class are visible through ADL even if they are not visible through ordinary lookup&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;which is a quote from the cppreference website.
Because of that part of the standard, an operator defined as a friend in a class of which your class inherits is found.
With this trick, you can, as other libraries have done, create multiple mixin classes from which your primary class inherits and ADL will find the functions.
The empty classes should mostly (if not completely) be optimized away by the compiler.&lt;&#x2F;p&gt;
</content>
  </entry>
  <entry xml:lang="en">
    <title>Count chars in lines</title>
    <author>codeattempts@gmail.com</author>
    <published>2017-11-22T12:30:00</published>
    <updated>2017-11-22T12:30:00</updated>
    <link href="https://ghlecl.github.io/posts/count_chars_in_n_first_lines/" type="text/html"/>
    <id>https://ghlecl.github.io/posts/count_chars_in_n_first_lines/</id>
    <summary>
   Counting chars in first n lines
I was coding in one of my projects and wanted to make sure that the position I was finding in a file was correct.
In a first attempt, I tried copy-pasting the content of the file up to the position I was searching for into Microsoft Excel™ to find the length of the resulting string.
Turns out a naive copy-paste does not preserve whitespace.
I then thought of writing a small</summary>
    <content>&lt;h1 id=&quot;Counting_chars_in_first_n_lines&quot;&gt;Counting chars in first n lines&lt;&#x2F;h1&gt;
&lt;p&gt;I was coding in one of my projects and wanted to make sure that the position I was finding in a file was correct.
In a first attempt, I tried copy-pasting the content of the file up to the position I was searching for into Microsoft Excel™ to find the length of the resulting string.
Turns out a naive copy-paste does not preserve whitespace.&lt;&#x2F;p&gt;
&lt;p&gt;I then thought of writing a small application to do what I wanted: open a file, read the &lt;code&gt;n&lt;&#x2F;code&gt; first lines and find the total number of characters (bad reflex, I know).
In trying to figure out the command line interface for this, I realized first that it would be a lot of work for something that I might not use often and second, that there might be an easier way on a *Nix system.&lt;&#x2F;p&gt;
&lt;p&gt;This lead me to simply using the applications &lt;a href=&quot;http:&#x2F;&#x2F;man7.org&#x2F;linux&#x2F;man-pages&#x2F;man1&#x2F;head.1.html&quot;&gt;head&lt;&#x2F;a&gt; and &lt;a href=&quot;http:&#x2F;&#x2F;man7.org&#x2F;linux&#x2F;man-pages&#x2F;man1&#x2F;wc.1.html&quot;&gt;wc&lt;&#x2F;a&gt; as follows:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;bash&quot; style=&quot;background-color:#1d1f21;color:#c5c8c6;&quot; class=&quot;language-bash &quot;&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;head&lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt; -n &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;line_count&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;gt; | &lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;wc&lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt; -m
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
</content>
  </entry>
  <entry xml:lang="en">
    <title>Return type overloading</title>
    <author>codeattempts@gmail.com</author>
    <published>2017-10-12</published>
    <updated>2017-10-12</updated>
    <link href="https://ghlecl.github.io/posts/return_type_overload/" type="text/html"/>
    <id>https://ghlecl.github.io/posts/return_type_overload/</id>
    <summary>
   No return type overloading
In C++, return type does not participate in function overload resolution, i.e. it is not possible to overload a function on the return type.
Thus, this is not legal C++:
void to_lower( std::string&amp; strg );
std::string to_lower( std::string&amp; strg );

The compiler will issue an error when it sees the second declaration.1
For instance, the error Clang emits is the following: &quot;error: functions that differ only in their return type cannot be overloaded&quot;.
The detailed reasons</summary>
    <content>&lt;h1 id=&quot;No_return_type_overloading&quot;&gt;No return type overloading&lt;&#x2F;h1&gt;
&lt;p&gt;In C++, return type does not participate in function overload resolution, i.e. it is not possible to overload a function on the return type.
Thus, this is not legal C++:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; style=&quot;background-color:#1d1f21;color:#c5c8c6;&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;void &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;to_lower&lt;&#x2F;span&gt;&lt;span&gt;( std::string&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;amp; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;strg &lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;std::string &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;to_lower&lt;&#x2F;span&gt;&lt;span&gt;( std::string&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;amp; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;strg &lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The compiler will issue an error when it sees the second declaration.&lt;sup id=&quot;ftntref:1&quot;&gt;&lt;a href=&quot;#ftnt:1&quot;&gt;1&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;
For instance, the error Clang emits is the following: &amp;quot;error: functions that differ only in their return type cannot be overloaded&amp;quot;.
The detailed reasons for this rule are irrelevant in the current discussion: it is just a fact.
I believe it is partially due to C++ allowing you to ignore the return value of a function if you so choose.
Thus, even for a function returning an int, you can call it without using or even capturing the return value:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;C++&quot; style=&quot;background-color:#1d1f21;color:#c5c8c6;&quot; class=&quot;language-C++ &quot;&gt;&lt;code class=&quot;language-C++&quot; data-lang=&quot;C++&quot;&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;int &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;fn&lt;&#x2F;span&gt;&lt;span&gt;( &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;int &lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;auto&lt;&#x2F;span&gt;&lt;span&gt; ret_val &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;fn&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;( &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;5 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;)&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;fn&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;( &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;12 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;)&lt;&#x2F;span&gt;&lt;span&gt;; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#969896;&quot;&gt;&#x2F;&#x2F; legal call, simply drops the return value
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;In the example, if &lt;code&gt;fn&lt;&#x2F;code&gt; were overloaded on return type only, how would the second call be disambiguated?
I am far from certain this is the only reason why, but it is convincing enough for me.&lt;&#x2F;p&gt;
&lt;p&gt;Still, I really wanted to be able to have an &amp;quot;in place&amp;quot; and &amp;quot;not in place&amp;quot; version of the &lt;code&gt;to_lower&lt;&#x2F;code&gt; function I wrote.
And, &lt;a href=&quot;https:&#x2F;&#x2F;twitter.com&#x2F;secretGeek&#x2F;status&#x2F;7269997868&quot;&gt;naming things is hard&lt;&#x2F;a&gt;, so I did not want to have to change the name of the function.
Cheating a little bit, I have found a way to &lt;em&gt;simulate&lt;&#x2F;em&gt; function overloading on return type or at least make it possible to have the same name for the two functions and (almost) only a differing return type.&lt;&#x2F;p&gt;
&lt;p&gt;With what I came up with, one of the two overloads becomes a template and must be called explicitly, so no ADL or overload resolution alone can help me and template argument deduction cannot be used either because the function parameter(s) do not depend on the template parameter.
After all, it is illegal to overload on return type in C++ and my technique does not imply changing the ISO C++ standard!&lt;&#x2F;p&gt;
&lt;h3 id=&quot;How_I_cheated&quot;&gt;How I &lt;em&gt;cheated&lt;&#x2F;em&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;All I did is use a template parameter as a tag for one version of the function.
I created an empty struct as a tag and templated one of the versions (the one the tag corresponds to).
Then, when I want that version to be called, I explicitly select the templated version passing the tag as an explicitly specified template argument.
Here is a code sample to illustrate&#x2F;explain better:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;C++&quot; style=&quot;background-color:#1d1f21;color:#c5c8c6;&quot; class=&quot;language-C++ &quot;&gt;&lt;code class=&quot;language-C++&quot; data-lang=&quot;C++&quot;&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;#include &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5bd68;&quot;&gt;&amp;lt;type_traits&amp;gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;#include &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5bd68;&quot;&gt;&amp;lt;string&amp;gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;#include &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5bd68;&quot;&gt;&amp;lt;cstdio&amp;gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;namespace &lt;&#x2F;span&gt;&lt;span&gt;ns
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span&gt;in_place {};
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;template&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;typename&lt;&#x2F;span&gt;&lt;span&gt; Tag &amp;gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;void &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;to_lower&lt;&#x2F;span&gt;&lt;span&gt;( std::string&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;amp; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;strg &lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;static_assert&lt;&#x2F;span&gt;&lt;span&gt;( std::is_same&amp;lt; Tag, in_place &amp;gt;::value,
&lt;&#x2F;span&gt;&lt;span&gt;                     &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5bd68;&quot;&gt;&amp;quot;only in_place is allowed as the template parameter&amp;quot; &lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#969896;&quot;&gt;&#x2F;&#x2F;... implementation here ...
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;std::string &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;to_lower&lt;&#x2F;span&gt;&lt;span&gt;( std::string&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;amp; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;strg &lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#969896;&quot;&gt;&#x2F;&#x2F;... implementation here ...
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;return&lt;&#x2F;span&gt;&lt;span&gt; strg;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;} &lt;&#x2F;span&gt;&lt;span style=&quot;color:#969896;&quot;&gt;&#x2F;&#x2F; namespace ns
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;int &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;main&lt;&#x2F;span&gt;&lt;span&gt;( &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;int &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;argc&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;char&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;* &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;argv&lt;&#x2F;span&gt;&lt;span&gt;[] )
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;using&lt;&#x2F;span&gt;&lt;span&gt; ns::in_place;
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;using&lt;&#x2F;span&gt;&lt;span&gt; ns::to_lower;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;   std::string &lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;to_change&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;( &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5bd68;&quot;&gt;&amp;quot;This STring is Mixed CASe.&amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;)&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;auto&lt;&#x2F;span&gt;&lt;span&gt; new_strg &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;to_lower&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;( to_change )&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;to_lower&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;&amp;lt; in_place &amp;gt;( to_change )&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;printf( &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5bd68;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ced1cf;&quot;&gt;%s&lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;\n&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5bd68;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;, ( to_change &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;==&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt; new_strg &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;? &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5bd68;&quot;&gt;&amp;quot;true&amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5bd68;&quot;&gt;&amp;quot;false&amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;) )&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Users of the function are provided with the tag and can use it to call the &amp;quot;overload&amp;quot; (so to speak, not an actual overload, I know).
Compilers are actually pretty good at eliminating empty classes from the code, even at not too high optimization levels.
So I am confident that the tag should disappear completely from the resulting binary and there should be no runtime downside to this technique.&lt;sup id=&quot;ftntref:2&quot;&gt;&lt;a href=&quot;#ftnt:2&quot;&gt;2&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;
Also, if appropriate, one function can be implemented using the other.
To ensure that types other than the provided tag can&#x27;t be used for the function call, I put a &lt;code&gt;static_assert&lt;&#x2F;code&gt; in the implementation.
Otherwise, any type could be put in there (as in &lt;code&gt;to_lower&amp;lt;int&amp;gt;&lt;&#x2F;code&gt;), which although it would work, would not be as explicit and as clear.
I don&#x27;t know why anyone would want do that, but I forbid it explicitly in my implementation.&lt;&#x2F;p&gt;
&lt;p&gt;What I did is no revolution and nothing fancy, but it does allow me to get the interface I need from my function, namely two functions with the same name differing only in return types... or almost.
I also find it to be expressive: it is clear at the call site that I will be modifying the string that is passed in.
Some might like it, others won&#x27;t!
If you find it useful, good.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;Alternative&quot;&gt;Alternative&lt;&#x2F;h3&gt;
&lt;p&gt;A friend suggested that another possible implementation would be to use variadic templates and call the function with an empty diamond.
I tried that version and it is possible.
I even put in a &lt;code&gt;static_assert&lt;&#x2F;code&gt; to check that the function can&#x27;t be called with a non empty parameter pack.
That being said, I find that it is better to have the empty struct as a tag because it is a bit more explicit which overload actually acts in place (whereas in the empty parameter pack alternative, it is clear which overload is called (the template), but not whether this is the
one working in place).
I suspect either implementation would result in the same binary code.
To me, another argument in favor of keeping the tag is that &lt;a href=&quot;https:&#x2F;&#x2F;arne-mertz.de&#x2F;2016&#x2F;tag-dispatch&#x2F;&quot;&gt;tag dispatching&lt;&#x2F;a&gt; (which my technique is similar to) is familiar to many C++ programmers while seeing a call with the empty diamond is not so common (I think, I might be completely wrong).&lt;&#x2F;p&gt;
&lt;h3 id=&quot;Notes&quot;&gt;Notes&lt;&#x2F;h3&gt;
&lt;p id=&quot;ftnt:1&quot;&gt;&lt;sup&gt;[1]&lt;&#x2F;sup&gt;&amp;nbsp;I know that the second overload, the one returning a new string, could take it&#x27;s parameter by reference or by value (since I&#x27;m probably doing a copy in the implementation anyhow).
That would have complicated the explanation of the overloads (as in that case, both functions would not technically be exactly differing only in return type), so I chose to write my examples that way in the post.&amp;nbsp;&lt;a href=&quot;#ftntref:1&quot;&gt;&amp;#8617;&amp;#65038;&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p id=&quot;ftnt:2&quot;&gt;&lt;sup&gt;[2]&lt;&#x2F;sup&gt;&amp;nbsp;I would have &amp;quot;Godbolted&amp;quot; my code, but I am not that good at reading assembler and when I tried with the std::string, the resulting assembler contains much more than my function and is not that simple to analyse.
I did it with ints, but then, starting at -O2, main becomes almost empty as the compiler can see all the constants and simplify all the way.&amp;nbsp;&lt;a href=&quot;#ftntref:2&quot;&gt;&amp;#8617;&amp;#65038;&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
</content>
  </entry>
  <entry xml:lang="en">
    <title>rvalue references in C++</title>
    <author>codeattempts@gmail.com</author>
    <published>2017-01-10T22:30:00</published>
    <updated>2017-01-10T22:30:00</updated>
    <link href="https://ghlecl.github.io/posts/rvalue_references_in_cxx/" type="text/html"/>
    <id>https://ghlecl.github.io/posts/rvalue_references_in_cxx/</id>
    <summary>
   move, rvalues, forward and C++
Ever since I heard about it, the concept of move semantics has been intriguing and appealing to me.
I confess to liking new C++ things and micro-optimizations way too much... but still, the concept of &quot;moving&quot; memory instead of copying it in order to gain efficiency is at least worth exploring, right?
Anyhow, I chose a function of mine and decided to try and make it handle move semantics properly.
The function</summary>
    <content>&lt;h1 id=&quot;move,_rvalues,_forward_and_C++&quot;&gt;move, rvalues, forward and C++&lt;&#x2F;h1&gt;
&lt;p&gt;Ever since I heard about it, the concept of move semantics has been intriguing and appealing to me.
I confess to liking new C++ things and micro-optimizations way too much... but still, the concept of &amp;quot;moving&amp;quot; memory instead of copying it in order to gain efficiency is at least worth exploring, right?
Anyhow, I chose a function of mine and decided to try and make it handle move semantics properly.
The function I chose is one that I use often enough that I thought it would make a difference.
It is the following template&lt;sup id=&quot;ftntref:1&quot;&gt;&lt;a href=&quot;#ftnt:1&quot;&gt;1&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; style=&quot;background-color:#1d1f21;color:#c5c8c6;&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;template&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;typename&lt;&#x2F;span&gt;&lt;span&gt; T &amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;std::string &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;to_string&lt;&#x2F;span&gt;&lt;span&gt;( T &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;const&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;amp; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;to_convert &lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;   std::stringstream &lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;strm&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;( &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5bd68;&quot;&gt;&amp;quot;&amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;)&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;   strm &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;lt;&amp;lt;&lt;&#x2F;span&gt;&lt;span&gt; to_convert;
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;return&lt;&#x2F;span&gt;&lt;span&gt; strm.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;str&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Now, it turns out that because it is a templated function, move semantics will have to be mixed with forwarding references and that, if you ask me, those things are gibberish if you don&#x27;t understand lvalues and rvalues.
This is what started my adventures into rvalue land.
After going through the process, I now realize that for this particular case, it is not really useful because &lt;a href=&quot;http:&#x2F;&#x2F;en.cppreference.com&#x2F;w&#x2F;cpp&#x2F;io&#x2F;basic_ostream&#x2F;operator_ltlt&quot;&gt;as far as I can tell&lt;&#x2F;a&gt;, &lt;code&gt;std::strinstream::operator&amp;lt;&amp;lt;&lt;&#x2F;code&gt; is not overloaded on rvalue references.
Still, the exercise was enlightening and I now know (or at least think I know) a lot more about rvalues.
The information here is nothing new, probably incomplete and also probably full of inaccuracies when compared to the strict standard C++ language definitions (after all, this is in my own words), but I have found the information useful.
I guess this is a snapshot of my current understanding.
All the better if it helps anybody else.
Now, on to my journey.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;A_new_kind_of_references:_&amp;&amp;&quot;&gt;A new kind of references: &amp;amp;&amp;amp;&lt;&#x2F;h3&gt;
&lt;p&gt;The idea behind move semantics is that when you need the value a variable contains and it is a temporary (or simply about to get out of scope), you could make the memory it owns yours instead of copying the value in your own memory.
This should execute faster then the copying as it is doing less work.
Of course, saving copies will not make much difference is you are copying a single &lt;code&gt;int&lt;&#x2F;code&gt;, but if you are, for instance, copying a &lt;code&gt;std::vector&lt;&#x2F;code&gt; of an image class, stealing the pointer to the images instead of copying the memory should have a large impact on runtime efficiency.
For this to be possible, there has to be a mechanism to detect the temporary nature of a variable and select what to do when a variable is temporary and when a variable is not.
Starting with the 2011 standard, C++ now defines rvalue references, identified by a double ampersand symbol (&lt;code&gt;&amp;amp;&amp;amp;&lt;&#x2F;code&gt;), which will only bind to temporary values.&lt;&#x2F;p&gt;
&lt;p&gt;This gives us a way to determine if a parameter is a temporary value: create an overload (or a single function) which takes an rvalue reference as its input.
Since this reference parameter will only bind to a temporary value, one can assume that the parameter cannot normally be used elsewhere in the program once the function returns.
When this guarantee holds, one can safely steal (or move) the internals of the parameter(s) instead of making a copy(ies), potentially making the function more efficient.
This is the crux of move semantics.
Of course, the devil is in the details, as I have found out.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;Quick_digression:_value_categories&quot;&gt;Quick digression: value categories&lt;&#x2F;h4&gt;
&lt;p&gt;Lvalues and rvalues are &lt;a href=&quot;http:&#x2F;&#x2F;en.cppreference.com&#x2F;w&#x2F;cpp&#x2F;language&#x2F;value_category&quot;&gt;value categories&lt;&#x2F;a&gt;.
Those two categories have been part of C++ since its first standardization in 1998 and were carried over from C (although in C, no rvalues were directly defined and &amp;quot;not lvalue&amp;quot; was deemed sufficient&lt;sup id=&quot;ftntref:2&quot;&gt;&lt;a href=&quot;#ftnt:2&quot;&gt;2&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;.
Those two categories take their name from their original, although now erroneous, definition, which was to think of them as the &amp;quot;left&amp;quot; and &amp;quot;right&amp;quot; operands of an assignment:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; style=&quot;background-color:#1d1f21;color:#c5c8c6;&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;int&lt;&#x2F;span&gt;&lt;span&gt; a &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;7&lt;&#x2F;span&gt;&lt;span&gt;; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#969896;&quot;&gt;&#x2F;&#x2F; a is an lvalue and 7 is an rvalue
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;With that definition, &amp;quot;assignability&amp;quot; appears as the main difference between lvalues and rvalues: if something cannot be assigned to, it is an rvalue.
I honestly do not know if it is the case in C, but I know that is not the case in C++.
Here is an example of an lvalue that is not assignable in C++.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; style=&quot;background-color:#1d1f21;color:#c5c8c6;&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;const int &lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;b&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;{ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;8 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;}&lt;&#x2F;span&gt;&lt;span&gt;; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#969896;&quot;&gt;&#x2F;&#x2F; b is an lvalue
&lt;&#x2F;span&gt;&lt;span&gt;b &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;9&lt;&#x2F;span&gt;&lt;span&gt;; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#969896;&quot;&gt;&#x2F;&#x2F; error, can&amp;#39;t assign to const even though it is an lvalue
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The const variable is still an lvalue, but one cannot assign a new value to it after construction.
So although it is not assignable, it is an lvalue.
It is my understanding that the more interesting property is not &amp;quot;assignability&amp;quot;, but rather &amp;quot;addressability&amp;quot;, i.e. the capacity to refer to a value.
I can take the address of both variables defined in the previous examples and refer to it, but
I cannot take the address of the literals and refer to them later in the program.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; style=&quot;background-color:#1d1f21;color:#c5c8c6;&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;int&lt;&#x2F;span&gt;&lt;span&gt; a;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;int&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt; c &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;= &amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;a; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#969896;&quot;&gt;&#x2F;&#x2F; valid
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;int&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt; d &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;= &amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;8&lt;&#x2F;span&gt;&lt;span&gt;; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#969896;&quot;&gt;&#x2F;&#x2F; invalid, can&amp;#39;t refer to (or take address of) the literal 8
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;So a better rule for rvalues is the following: if I can take the address of a value or expression and reference it later in the program, the value is an lvalue; otherwise, it is an rvalue.&lt;&#x2F;p&gt;
&lt;p&gt;This is not the complete picture of value categories, since five value categories are now defined in C++ (lvalues, glvalues, rvalues, prvalues and xvalues), but it turns out to be an adequate rule of thumb for lvalue&#x2F;rvalue discrimination and that is what matters most for move semantics.
In &lt;a href=&quot;https:&#x2F;&#x2F;isocpp.org&#x2F;blog&#x2F;2012&#x2F;11&#x2F;universal-references-in-c11-scott-meyers&quot;&gt;this&lt;&#x2F;a&gt; blog post on &lt;a href=&quot;http:&#x2F;&#x2F;isocpp.org&quot;&gt;isocpp.org&lt;&#x2F;a&gt;, &lt;a href=&quot;http:&#x2F;&#x2F;scottmeyers.blogspot.ca&#x2F;&quot;&gt;Scott Meyers&lt;&#x2F;a&gt; gives this heuristics to determine the general type (lvalue vs rvalue) of an expression or variable:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;If you can take the address of an expression, the expression is an lvalue.&lt;&#x2F;li&gt;
&lt;li&gt;If the type of an expression is an lvalue reference (e.g., &lt;code&gt;T&amp;amp;&lt;&#x2F;code&gt; or &lt;code&gt;const T&amp;amp;&lt;&#x2F;code&gt;, etc.), that expression is an lvalue.&lt;&#x2F;li&gt;
&lt;li&gt;Otherwise, the expression is an rvalue.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;which is a quote from the linked blog post.
Again, in Scott&#x27;s words:&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;Conceptually (and typically also in fact), rvalues correspond to temporary objects, such as those returned from functions or created through implicit type conversions.
Most literal values (e.g., 10 and 5.3) are also rvalues.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;I think a nice feature of this heuristic is that it helps you remember that the type of an expression is independent of whether the expression is an lvalue or an rvalue. That is, given a type &lt;code&gt;T&lt;&#x2F;code&gt;, you can have lvalues of type &lt;code&gt;T&lt;&#x2F;code&gt; as well as rvalues of type &lt;code&gt;T&lt;&#x2F;code&gt;.
It’s especially important to remember this when dealing with a [function] parameter of rvalue reference type, because the parameter itself is an lvalue.&lt;&#x2F;p&gt;
&lt;p&gt;That last sentence took me a while to fully understand.
It is illustrated by the following example (where the new double ampersand symbol (&lt;code&gt;&amp;amp;&amp;amp;&lt;&#x2F;code&gt;) for rvalue references is used):&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; style=&quot;background-color:#1d1f21;color:#c5c8c6;&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;void &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;foo&lt;&#x2F;span&gt;&lt;span&gt;( MyType&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;amp;&amp;amp; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;param &lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;auto&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt; alias &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;= &amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;param;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#969896;&quot;&gt;&#x2F;&#x2F; Completely legal: param has a memory location
&lt;&#x2F;span&gt;&lt;span&gt;                          &lt;&#x2F;span&gt;&lt;span style=&quot;color:#969896;&quot;&gt;&#x2F;&#x2F; inside the function body.
&lt;&#x2F;span&gt;&lt;span&gt;   Thus, by the heuristic
&lt;&#x2F;span&gt;&lt;span&gt;                          &lt;&#x2F;span&gt;&lt;span style=&quot;color:#969896;&quot;&gt;&#x2F;&#x2F; above, param is an lvalue.
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This fact that the parameter is an lvalue inside the function might seem like a simple detail, but it will turn out to be necessary to explain why &lt;code&gt;std::move&lt;&#x2F;code&gt; and &lt;code&gt;std::forward&lt;&#x2F;code&gt; are necessary later on.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;Overloading_on_rvalue_reference&quot;&gt;Overloading on rvalue reference&lt;&#x2F;h4&gt;
&lt;p&gt;So the idea, as mentioned, is to create an overload on rvalue references.
There is no way of representing rvalues (almost by definition from a certain point of view), so rvalue references are the only option.
The following is a simple example.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; style=&quot;background-color:#1d1f21;color:#c5c8c6;&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;#include &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5bd68;&quot;&gt;&amp;lt;iostream&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;int &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;bar&lt;&#x2F;span&gt;&lt;span&gt;()
&lt;&#x2F;span&gt;&lt;span&gt;{ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;9&lt;&#x2F;span&gt;&lt;span&gt;; }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#969896;&quot;&gt;&#x2F;&#x2F; const lvalue reference overload
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;void &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;foo&lt;&#x2F;span&gt;&lt;span&gt;( &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;int const&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;amp; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;param &lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;{ std::cout &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;lt;&amp;lt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5bd68;&quot;&gt;&amp;quot;foo( int const&amp;amp; param )&amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;lt;&amp;lt;&lt;&#x2F;span&gt;&lt;span&gt; std::endl; }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#969896;&quot;&gt;&#x2F;&#x2F; rvalue reference overload
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;void &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;foo&lt;&#x2F;span&gt;&lt;span&gt;( &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;int&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;amp;&amp;amp; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;param &lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;{ std::cout &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;lt;&amp;lt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5bd68;&quot;&gt;&amp;quot;foo( int&amp;amp;&amp;amp; param )&amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;lt;&amp;lt;&lt;&#x2F;span&gt;&lt;span&gt; std::endl; }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#969896;&quot;&gt;&#x2F;&#x2F; by copy overload, do not define as it will yield
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#969896;&quot;&gt;&#x2F;&#x2F;       error: call to &amp;#39;foo&amp;#39; is ambiguous
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#969896;&quot;&gt;&#x2F;&#x2F; void foo( int param )
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#969896;&quot;&gt;&#x2F;&#x2F; { std::cout &amp;lt;&amp;lt; &amp;quot;foo( int param )&amp;quot; &amp;lt;&amp;lt; std::endl; }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;int &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;main&lt;&#x2F;span&gt;&lt;span&gt;( &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;int &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;argc&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;char&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;* &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;argv&lt;&#x2F;span&gt;&lt;span&gt;[] )
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;int &lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;a&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;{ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;6 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;}&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;int&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;amp; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;b&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;{ a }&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;const int&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;amp; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;c&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;{ b }&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;foo&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;( a )&lt;&#x2F;span&gt;&lt;span&gt;;     &lt;&#x2F;span&gt;&lt;span style=&quot;color:#969896;&quot;&gt;&#x2F;&#x2F; calls first foo
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;foo&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;( b )&lt;&#x2F;span&gt;&lt;span&gt;;     &lt;&#x2F;span&gt;&lt;span style=&quot;color:#969896;&quot;&gt;&#x2F;&#x2F; calls first foo
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;foo&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;( c )&lt;&#x2F;span&gt;&lt;span&gt;;     &lt;&#x2F;span&gt;&lt;span style=&quot;color:#969896;&quot;&gt;&#x2F;&#x2F; calls first foo
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;foo&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;( &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;7 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;)&lt;&#x2F;span&gt;&lt;span&gt;;     &lt;&#x2F;span&gt;&lt;span style=&quot;color:#969896;&quot;&gt;&#x2F;&#x2F; calls second foo
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;foo&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;( &lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;bar&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;() )&lt;&#x2F;span&gt;&lt;span&gt;; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#969896;&quot;&gt;&#x2F;&#x2F; calls second foo
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;In this case, this does not buy you much, but the snippet above is compilable by any C++11 conformant compiler.
This little code should output &lt;code&gt;foo( int const&amp;amp; param )&lt;&#x2F;code&gt; three times and &lt;code&gt;foo( int&amp;amp;&amp;amp; param )&lt;&#x2F;code&gt; twice.
A non compilable but more realistic&#x2F;useful example would be:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; style=&quot;background-color:#1d1f21;color:#c5c8c6;&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;&lt;span&gt;std::vector&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;int&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;foo&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#969896;&quot;&gt;&#x2F;&#x2F; two functions constructing a MyCoolClass object from a vector&amp;lt;int&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;MyCoolClass &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;make_from_std_vec&lt;&#x2F;span&gt;&lt;span&gt;( std::vector&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;int&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;const&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;amp; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;vec &lt;&#x2F;span&gt;&lt;span&gt;); &lt;&#x2F;span&gt;&lt;span style=&quot;color:#969896;&quot;&gt;&#x2F;* overload 1 *&#x2F;
&lt;&#x2F;span&gt;&lt;span&gt;MyCoolClass &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;make_from_std_vec&lt;&#x2F;span&gt;&lt;span&gt;( std::vector&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;int&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;amp;&amp;amp; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;vec &lt;&#x2F;span&gt;&lt;span&gt;);      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#969896;&quot;&gt;&#x2F;* overload 2 *&#x2F;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;std::vector&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;int&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt; the_vec;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#969896;&quot;&gt;&#x2F;* fill the_vec *&#x2F;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;auto&lt;&#x2F;span&gt;&lt;span&gt; obj_1 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;make_from_std_vec&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;( the_vec )&lt;&#x2F;span&gt;&lt;span&gt;;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#969896;&quot;&gt;&#x2F;&#x2F; binds to overload 1
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;auto&lt;&#x2F;span&gt;&lt;span&gt; obj_2 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;make_from_std_vec&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;( &lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;foo&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;() )&lt;&#x2F;span&gt;&lt;span&gt;;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#969896;&quot;&gt;&#x2F;&#x2F; binds to overload 2
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Here, because &lt;code&gt;std::vector&lt;&#x2F;code&gt; has been updated to allow move semantics, the second overload will be able to move the memory instead of copying it into the &lt;code&gt;MyCoolClass&lt;&#x2F;code&gt; object which should save a copy.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;Implementing_:_enters_std::move&quot;&gt;Implementing : enters std::move&lt;&#x2F;h4&gt;
&lt;p&gt;Once you have an overload which selects the rvalues, you have to implement it.
Most (if not all) POD types and STL types have been updated for move semantics, although I am not sure that moving is faster than copying in the case of &lt;code&gt;int&lt;&#x2F;code&gt;, for instance.
That being said, this means that move constructors and move assignment operators are available for &lt;code&gt;std::vector&lt;&#x2F;code&gt;.
If you pass an rvalue to those, they will move.
But that brings us back to the discussion on function parameters inside of the function being lvalues.
That means that the following will not actually move anything and will instead make a copy:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; style=&quot;background-color:#1d1f21;color:#c5c8c6;&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;&lt;span&gt;std::vector&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;int&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;steal_guts_and_do_stuff&lt;&#x2F;span&gt;&lt;span&gt;( std::vector&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;int&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;amp;&amp;amp; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;vec &lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;   std::vector&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;int&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;result&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;( vec )&lt;&#x2F;span&gt;&lt;span&gt;;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#969896;&quot;&gt;&#x2F;&#x2F; INCORRECT, will not move
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#969896;&quot;&gt;&#x2F;* do stuff *&#x2F;
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;return&lt;&#x2F;span&gt;&lt;span&gt; result;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;That is because even though &lt;a href=&quot;http:&#x2F;&#x2F;en.cppreference.com&#x2F;w&#x2F;cpp&#x2F;container&#x2F;vector&#x2F;vector&quot;&gt;there is&lt;&#x2F;a&gt; an overload of the &lt;code&gt;std::vector&lt;&#x2F;code&gt; constructor for rvalues, what you actually passed as a parameter (&lt;code&gt;vec&lt;&#x2F;code&gt;) is &lt;em&gt;&lt;strong&gt;not&lt;&#x2F;strong&gt;&lt;&#x2F;em&gt; an rvalue (that was explained in previous sections).
Thus, the compiler will select the copy constructor instead of the move constructor.
That being said, because you are implementing the rvalue reference overload of your function (in this case, the &lt;code&gt;steal_guts_and_do_stuff&lt;&#x2F;code&gt; function), you know that in the &lt;em&gt;&lt;strong&gt;caller&lt;&#x2F;strong&gt;&lt;&#x2F;em&gt; scope, the parameter is actually an rvalue.
This means if you had a way to cast the parameter to an rvalue inside the function implementation to tell the compiler to select the move constructor for &lt;code&gt;std::vector&lt;&#x2F;code&gt;, then that one would be selected.
This can be done with the new function &lt;code&gt;std::move&lt;&#x2F;code&gt;.
All this function does is &lt;em&gt;&lt;strong&gt;unconditionally&lt;&#x2F;strong&gt;&lt;&#x2F;em&gt; cast its input to an rvalue reference.
The casting is done via the &lt;a href=&quot;http:&#x2F;&#x2F;en.cppreference.com&#x2F;w&#x2F;cpp&#x2F;language&#x2F;reference&quot;&gt;reference&lt;&#x2F;a&gt; &lt;a href=&quot;http:&#x2F;&#x2F;thbecker.net&#x2F;articles&#x2F;rvalue_references&#x2F;section_08.html&quot;&gt;collapsing rules&lt;&#x2F;a&gt;.
Thus, the implementation above should actually be written as:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; style=&quot;background-color:#1d1f21;color:#c5c8c6;&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;&lt;span&gt;std::vector&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;int&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;steal_guts_and_do_stuff&lt;&#x2F;span&gt;&lt;span&gt;( std::vector&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;int&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;amp;&amp;amp; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;vec &lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;   std::vector&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;int&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;result&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;( std::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;move&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;( vec ) )&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#969896;&quot;&gt;&#x2F;* do stuff *&#x2F;
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;return&lt;&#x2F;span&gt;&lt;span&gt; result;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;where you can see that &lt;code&gt;std::move&lt;&#x2F;code&gt; has been used on &lt;code&gt;vec&lt;&#x2F;code&gt;.
That is pretty much it.
Just insure that in your rvalue overload implementations, you use &lt;code&gt;std::move&lt;&#x2F;code&gt; on all the parameters that you want to move from and that you do not reuse those parameters after they have been moved from.
If you want your user defined types to be &amp;quot;movable from&amp;quot;, then define a move constructor and a move assignment operator and then a user will be able to move from your types.
And notice that you do not use &lt;code&gt;std::move&lt;&#x2F;code&gt; on the return statement.
Moving is done when you &lt;em&gt;use&lt;&#x2F;em&gt; the input parameter to cast it to an rvalue forcing the compiler to take the rvalue overload of the function you are calling (in my case, move constructor).
You do not want to move the return.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;And_then_they_were_three:_T&amp;&amp;&quot;&gt;And then they were three: T&amp;amp;&amp;amp;&lt;&#x2F;h3&gt;
&lt;p&gt;As I have previously mentioned, the function that I wanted to convert to move semantics was a template.
There is a catch in this case.
Actually, this function declaration:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; style=&quot;background-color:#1d1f21;color:#c5c8c6;&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;template&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;typename&lt;&#x2F;span&gt;&lt;span&gt; T &amp;gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;void &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;foo&lt;&#x2F;span&gt;&lt;span&gt;( T&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;amp;&amp;amp; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;param &lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;does &lt;strong&gt;&lt;em&gt;not&lt;&#x2F;em&gt;&lt;&#x2F;strong&gt; declare an rvalue reference overload.
The reference here is a forwarding reference&lt;sup id=&quot;ftntref:3&quot;&gt;&lt;a href=&quot;#ftnt:3&quot;&gt;3&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;.
Referencing once again Scott Meyer&#x27;s &lt;a href=&quot;https:&#x2F;&#x2F;isocpp.org&#x2F;blog&#x2F;2012&#x2F;11&#x2F;universal-references-in-c11-scott-meyers&quot;&gt;blog post&lt;&#x2F;a&gt; on &lt;a href=&quot;http:&#x2F;&#x2F;isocpp.org&quot;&gt;isocpp.org&lt;&#x2F;a&gt;, one finds this rule of thumb to determine the if an expression is a forwarding reference:&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;If a variable or parameter is declared to have type &lt;strong&gt;&lt;code&gt;T&amp;amp;&amp;amp;&lt;&#x2F;code&gt;&lt;&#x2F;strong&gt; for some &lt;strong&gt;deduced type&lt;&#x2F;strong&gt; &lt;code&gt;T&lt;&#x2F;code&gt;, that variable or parameter is a &lt;em&gt;universal reference&lt;&#x2F;em&gt;.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;Deduced type mostly means templates and &lt;code&gt;auto&lt;&#x2F;code&gt; (which I won&#x27;t talk about anymore).
What is particular about forwarding references is that they can bind to both lvalues and rvalues, depending on what type (not value) it is initialized with.
In fact, they will bind to lvalues, rvalues, const, non-const, volatile, non-volatile...
This makes them really greedy and has some interesting consequences on the overload set, but that&#x27;s not the subject here.&lt;&#x2F;p&gt;
&lt;p&gt;So now, three types of references have been mentioned: lvalue references, rvalue references and forwarding references.
When implementing a function overload for one of the reference type, inside the function body, one must make sure to understand what should happen.
For an lvalue reference overload, the parameter is an lvalue and should never be moved from.
For an rvalue reference overload, the parameter is always an rvalue, thus temporary, and can always be moved from.
For a forwarding reference, the parameter can be either an lvalue or an rvalue and should be moved from in the latter case, but not the former.
The need to cast in the function body has been previously explained.
I also mentioned that the tool to cast unconditionally to an rvalue reference is &lt;code&gt;std::move&lt;&#x2F;code&gt;.
For forwarding references, the tool to &lt;strong&gt;&lt;em&gt;conditionally&lt;&#x2F;em&gt;&lt;&#x2F;strong&gt; cast to rvalue references is &lt;code&gt;std::forward&lt;&#x2F;code&gt;.
This standard library template will cast an lvalue reference (or something that binds to an lvalue reference) to an lvalue reference and an rvalue reference (or something that binds to an rvalue reference) to an rvalue reference.
The mechanism used for this is reference collapsing and the result is exactly what we need to implement the forwarding reference overload.
The following code snippet illustrates what usually should be done:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; style=&quot;background-color:#1d1f21;color:#c5c8c6;&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;&lt;span&gt;MyClass &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;from_vec&lt;&#x2F;span&gt;&lt;span&gt;( std::vector &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;const&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;amp; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;vec &lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;MyClass&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;{ vec }&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;MyClass &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;from_vec&lt;&#x2F;span&gt;&lt;span&gt;( std::vector&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;amp;&amp;amp; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;vec &lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;MyClass&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;{ std::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;move&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;( vec ) }&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;template&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;typename&lt;&#x2F;span&gt;&lt;span&gt; C &amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;MyClass &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;from_container&lt;&#x2F;span&gt;&lt;span&gt;( C&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;amp;&amp;amp; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;container &lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;MyClass&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;{ std::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;forward&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;&amp;lt; C &amp;gt;( vec ) }&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;It should be noted that for &lt;code&gt;std::forward&lt;&#x2F;code&gt;, template argument deduction &lt;a href=&quot;http:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;7779900&#x2F;why-is-template-argument-deduction-disabled-with-stdforward&quot;&gt;would not produce&lt;&#x2F;a&gt;
&lt;a href=&quot;http:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;28828159&#x2F;usage-of-stdforward-vs-stdmove&quot;&gt;the desired results&lt;&#x2F;a&gt;, so the type has to be repeated in the call to the function.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;The_result&quot;&gt;The result&lt;&#x2F;h3&gt;
&lt;p&gt;So, now, I have everything I need to write my function.
It is a template, so it will use the forwarding references.
This is my new implementation:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; style=&quot;background-color:#1d1f21;color:#c5c8c6;&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;template&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;typename&lt;&#x2F;span&gt;&lt;span&gt; T &amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;std::string &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;to_string&lt;&#x2F;span&gt;&lt;span&gt;( T&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;amp;&amp;amp; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;to_convert &lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;   std::stringstream &lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;strm&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;( &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5bd68;&quot;&gt;&amp;quot;&amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;)&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;   strm &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;lt;&amp;lt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;std::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;forward&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;&amp;lt;T&amp;gt;( to_convert )&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;return&lt;&#x2F;span&gt;&lt;span&gt; strm.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;str&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;If (and as I pointed out in the intro, it is not the case) the &lt;code&gt;stringstream&lt;&#x2F;code&gt; redirect operator (&lt;code&gt;&amp;lt;&amp;lt;&lt;&#x2F;code&gt;) has an rvalue overload which steals the internals of it&#x27;s argument, it will do so for the cases where &lt;code&gt;to_string&lt;&#x2F;code&gt; is called with an rvalue and it will use the regular lvalue reference overload when called with an lvalue.
This is the &amp;quot;optimal&amp;quot; or near optimal behavior for my function.&lt;&#x2F;p&gt;
&lt;p&gt;To get to my implementation, I had first simply stuck a &lt;code&gt;&amp;amp;&amp;amp;&lt;&#x2F;code&gt; symbol to my reference (removing the const, of course) and used &lt;code&gt;std::move&lt;&#x2F;code&gt;.
It failed for reasons that are now apparent from the discussion in the previous sections.
After that, I started to read all of the references I link in these notes (and more) and realized I needed to use &lt;code&gt;std::forward&lt;&#x2F;code&gt;.
I finally realized that for my function, this is useless, but the journey was worth it!&lt;&#x2F;p&gt;
&lt;h3 id=&quot;Notes&quot;&gt;Notes&lt;&#x2F;h3&gt;
&lt;p id=&quot;ftnt:1&quot;&gt;&lt;sup&gt;[1]&lt;&#x2F;sup&gt;&amp;nbsp;Yes, I am sure someone else would do a better job at writing it more &lt;a href=&quot;http:&#x2F;&#x2F;zverovich.net&#x2F;2013&#x2F;09&#x2F;07&#x2F;integer-to-string-conversion-in-cplusplus.html&quot;&gt;generic, faster, better&lt;&#x2F;a&gt;, etc.; not the point!&amp;nbsp;&lt;a href=&quot;#ftntref:1&quot;&gt;&amp;#8617;&amp;#65038;&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p id=&quot;ftnt:2&quot;&gt;&lt;sup&gt;[2]&lt;&#x2F;sup&gt;&amp;nbsp;The C language itself borrowed the concepts from CPL (see &lt;a href=&quot;http:&#x2F;&#x2F;blog.smartbear.com&#x2F;development&#x2F;c11-tutorial-explaining-the-ever-elusive-lvalues-and-rvalues&#x2F;&quot;&gt;this&lt;&#x2F;a&gt; blog post by Danny Kalev).&amp;nbsp;&lt;a href=&quot;#ftntref:2&quot;&gt;&amp;#8617;&amp;#65038;&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p id=&quot;ftnt:3&quot;&gt;&lt;sup&gt;[3]&lt;&#x2F;sup&gt;&amp;nbsp;Scott Meyers used the terminology Universal References both in his articles and his book &lt;a href=&quot;http:&#x2F;&#x2F;shop.oreilly.com&#x2F;product&#x2F;0636920033707.do&quot;&gt;Effective Modern C++&lt;&#x2F;a&gt;, but after discussion with members of the ISO C++ committee and the C++ community, he agreed to include a footnote (in Item 24) to say that since they should almost always be used with &lt;code&gt;std::forward&lt;&#x2F;code&gt;, the name forwarding references is gaining traction.&amp;nbsp;&lt;a href=&quot;#ftntref:3&quot;&gt;&amp;#8617;&amp;#65038;&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p id=&quot;ftnt:4&quot;&gt;&lt;sup&gt;[4]&lt;&#x2F;sup&gt;&amp;nbsp;Unreferenced in the text: &lt;a href=&quot;http:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;36696312&#x2F;why-is-pass-by-value-and-pass-by-rvalue-overload-c-function-call-ambiguous&quot;&gt;ambiguous call&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
</content>
  </entry>
  <entry xml:lang="en">
    <title>Timing pieces of code</title>
    <author>codeattempts@gmail.com</author>
    <published>2016-03-20T19:43:00</published>
    <updated>2016-03-20T19:43:00</updated>
    <link href="https://ghlecl.github.io/posts/cpp_time_it/" type="text/html"/>
    <id>https://ghlecl.github.io/posts/cpp_time_it/</id>
    <summary>
   Execution time measurements
Python's timeit and repeat
I sometimes want to time my code to see which version of a function I wrote runs faster.
I know that you should always profile before you optimize and that micro-benchmarking has lots of caveats (some of which I have myself fallen victim to), but still, sometimes, curiosity gets the best of me and I just have to know.
When I am writing in Python, I use the timeit module</summary>
    <content>&lt;h1 id=&quot;Execution_time_measurements&quot;&gt;Execution time measurements&lt;&#x2F;h1&gt;
&lt;h3 id=&quot;Python&#x27;s_timeit_and_repeat&quot;&gt;Python&#x27;s timeit and repeat&lt;&#x2F;h3&gt;
&lt;p&gt;I sometimes want to time my code to see which version of a function I wrote runs faster.
I know that you should &lt;em&gt;&lt;strong&gt;always&lt;&#x2F;strong&gt;&lt;&#x2F;em&gt; profile before you optimize and that &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Benchmark_%28computing%29#Types_of_benchmarks&quot;&gt;micro-benchmarking&lt;&#x2F;a&gt; has &lt;a href=&quot;http:&#x2F;&#x2F;stackoverflow.com&#x2F;a&#x2F;2842707&quot;&gt;lots of caveats&lt;&#x2F;a&gt; (some of which I have myself fallen victim to), but still, sometimes, curiosity gets the best of me and I just have to know.
When I am writing in Python, I use the &lt;code&gt;timeit&lt;&#x2F;code&gt; &lt;a href=&quot;https:&#x2F;&#x2F;docs.python.org&#x2F;3&#x2F;library&#x2F;timeit.html?highlight=timeit#module-timeit&quot;&gt;module&lt;&#x2F;a&gt; to measure code execution.
This handy module has two main utility functions: &lt;code&gt;timeit&lt;&#x2F;code&gt; and &lt;code&gt;repeat&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;timeit&lt;&#x2F;code&gt; will run a piece of code &lt;code&gt;n&lt;&#x2F;code&gt; times while measuring the execution time of each repetition.
It then gives back the lowest time, which is arguably the time needed to run the code when nothing else on the system is interfering.
Of course, when the code will be run, other things will want CPU time alongside your program and the OS will have to balance it all, but &lt;em&gt;usually&lt;&#x2F;em&gt;, that should not be taken into account when doing micro-benchmarks.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;repeat&lt;&#x2F;code&gt; will again run a piece of code &lt;code&gt;n&lt;&#x2F;code&gt; times, but will repeat that experiment &lt;code&gt;r&lt;&#x2F;code&gt; times, returning a list with the lowest execution time of each repetition of the experiment.
The following snippet shows how to use both of them in code.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;python&quot; style=&quot;background-color:#1d1f21;color:#c5c8c6;&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;from &lt;&#x2F;span&gt;&lt;span&gt;timeit &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;import &lt;&#x2F;span&gt;&lt;span&gt;timeit, repeat
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;n &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;1000
&lt;&#x2F;span&gt;&lt;span&gt;r &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;2
&lt;&#x2F;span&gt;&lt;span&gt;times_repeat &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;repeat&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;( &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5bd68;&quot;&gt;&amp;quot;def Fn( x ): return x**2;myFn( 4 )&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;repeat &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;r, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;number &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;n )
&lt;&#x2F;span&gt;&lt;span&gt;times_timeit &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span&gt;[]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;idx &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;in &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;range( r )&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;times_timeit.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;append&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;( &lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;timeit&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;( &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5bd68;&quot;&gt;&amp;quot;def Fn( x ): return x**2;myFn( 4 )&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;number &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;n ) )
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;There are two other ways to use the &lt;code&gt;timeit&lt;&#x2F;code&gt; module, namely via the command line with the executable module syntax and using an interactive Python shell like &lt;a href=&quot;https:&#x2F;&#x2F;ipython.org&#x2F;&quot;&gt;iPython&lt;&#x2F;a&gt; which has the magic function &lt;code&gt;%timeit&lt;&#x2F;code&gt;.
I won&#x27;t cover those subjects here.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;Trying_it_out_in_C++:_time_it&quot;&gt;Trying it out in C++: time_it&lt;&#x2F;h3&gt;
&lt;p&gt;The thing is, I don&#x27;t always do things in Python and I wanted to have a function similar to &lt;code&gt;timeit&lt;&#x2F;code&gt; which would allow me to measure the execution time of a function or piece of code in C++.
It turns out that with C++14 (don&#x27;t know if C++11 is sufficient, but C++17&#x2F;C++1z will make it easier I think), it is possible to get close to it.
When I got the idea, I started to think about the &lt;a href=&quot;http:&#x2F;&#x2F;www.open-std.org&#x2F;jtc1&#x2F;sc22&#x2F;wg21&#x2F;docs&#x2F;papers&#x2F;2014&#x2F;n4169.html&quot;&gt;proposed&lt;&#x2F;a&gt; &lt;code&gt;std::invoke&lt;&#x2F;code&gt; function that should (or has?) make it into the next standard.
This function template takes a function, it&#x27;s arguments and invokes it.
This is pretty close to what I need.
Coupling the facilities of &lt;code&gt;std::chrono&lt;&#x2F;code&gt; with that function could actually get me pretty close to what I want.
Because some compilers do not yet have an implementation of &lt;code&gt;std::invoke&lt;&#x2F;code&gt;, I had to first find one or write one.
I decided to use the implementation found on &lt;a href=&quot;http:&#x2F;&#x2F;en.cppreference.com&#x2F;w&#x2F;cpp&#x2F;utility&#x2F;functional&#x2F;invoke&quot;&gt;cppreference.com&lt;&#x2F;a&gt;.
But let&#x27;s pretend that std::invoke is available.
Then, one can write the function template &lt;code&gt;time_it&lt;&#x2F;code&gt;&lt;sup id=&quot;ftntref:1&quot;&gt;&lt;a href=&quot;#ftnt:1&quot;&gt;1&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt; using &lt;code&gt;std::invoke&lt;&#x2F;code&gt; and &lt;code&gt;std::chrono&lt;&#x2F;code&gt;.
This is the resulting function for those who do not want to read the steps I went through:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;cpp&quot; style=&quot;background-color:#1d1f21;color:#c5c8c6;&quot; class=&quot;language-cpp &quot;&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;template&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;unsigned int&lt;&#x2F;span&gt;&lt;span&gt; repeat_invoke &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;1000&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;unsigned int&lt;&#x2F;span&gt;&lt;span&gt; repeat_meas &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;3&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;typename&lt;&#x2F;span&gt;&lt;span&gt; F, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;typename&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;...&lt;&#x2F;span&gt;&lt;span&gt; ArgTypes
&lt;&#x2F;span&gt;&lt;span&gt;        &amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;std::array&amp;lt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;double&lt;&#x2F;span&gt;&lt;span&gt;, repeat_meas &amp;gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;time_it&lt;&#x2F;span&gt;&lt;span&gt;( F&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;amp;&amp;amp; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;f&lt;&#x2F;span&gt;&lt;span&gt;, ArgTypes&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;amp;&amp;amp;... &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;args &lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;using&lt;&#x2F;span&gt;&lt;span&gt; std::chrono::high_resolution_clock;
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;using&lt;&#x2F;span&gt;&lt;span&gt; std::chrono::duration_cast;
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;using&lt;&#x2F;span&gt;&lt;span&gt; std::numeric_limits;
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;using&lt;&#x2F;span&gt;&lt;span&gt; std::chrono::nanoseconds;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;static_assert&lt;&#x2F;span&gt;&lt;span&gt;( repeat_invoke &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5bd68;&quot;&gt;&amp;quot;time_it: The number of times the code experiment is \
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5bd68;&quot;&gt;                                          repeated has to be at least 1.&amp;quot; &lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;static_assert&lt;&#x2F;span&gt;&lt;span&gt;( repeat_meas &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5bd68;&quot;&gt;&amp;quot;time_it: The number of times the code is run has to \
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5bd68;&quot;&gt;                                                          be at least 1.&amp;quot; &lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;double&lt;&#x2F;span&gt;&lt;span&gt; max_dbl &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; numeric_limits&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;double&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;max&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;()&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;double&lt;&#x2F;span&gt;&lt;span&gt; cur_min &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; max_dbl;
&lt;&#x2F;span&gt;&lt;span&gt;   std::array&amp;lt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;double&lt;&#x2F;span&gt;&lt;span&gt;, repeat_meas &amp;gt; shortest_times;
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;for&lt;&#x2F;span&gt;&lt;span&gt;( &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;unsigned int &lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;meas_idx&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;( &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;0 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;)&lt;&#x2F;span&gt;&lt;span&gt;; meas_idx &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;!=&lt;&#x2F;span&gt;&lt;span&gt; repeat_meas; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;++&lt;&#x2F;span&gt;&lt;span&gt;meas_idx )
&lt;&#x2F;span&gt;&lt;span&gt;   {
&lt;&#x2F;span&gt;&lt;span&gt;      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;for&lt;&#x2F;span&gt;&lt;span&gt;( &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;unsigned int &lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;invoke_idx&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;( &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;0 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;)&lt;&#x2F;span&gt;&lt;span&gt;; invoke_idx &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;!=&lt;&#x2F;span&gt;&lt;span&gt; repeat_invoke; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;++&lt;&#x2F;span&gt;&lt;span&gt;invoke_idx )
&lt;&#x2F;span&gt;&lt;span&gt;      {
&lt;&#x2F;span&gt;&lt;span&gt;         &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;auto&lt;&#x2F;span&gt;&lt;span&gt; start &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;high_resolution_clock::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;now&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;()&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;         &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;std::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;invoke&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;( std::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;forward&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;&amp;lt;F&amp;gt;(f), std::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;forward&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;&amp;lt;ArgTypes&amp;gt;(args)&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;... &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;)&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;         &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;auto&lt;&#x2F;span&gt;&lt;span&gt; elapsed &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;duration_cast&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;&amp;lt; nanoseconds &amp;gt;(
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;                        high_resolution_clock::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;now&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;() &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;-&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt; start )&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;count&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;         &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;if&lt;&#x2F;span&gt;&lt;span&gt;( elapsed &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span&gt; cur_min ) { cur_min &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; elapsed; }
&lt;&#x2F;span&gt;&lt;span&gt;      }
&lt;&#x2F;span&gt;&lt;span&gt;      shortest_times[meas_idx] &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; cur_min;
&lt;&#x2F;span&gt;&lt;span&gt;      cur_min &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; max_dbl;
&lt;&#x2F;span&gt;&lt;span&gt;   }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;return&lt;&#x2F;span&gt;&lt;span&gt; shortest_times;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;I skipped the includes in this code snippet.
I am not pretending this code is exception safe, thread safe or any other kind of safe there is.
I am not suggesting anybody else should use it.
It&#x27;s simply something I find useful.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;How_I_got_there&quot;&gt;How I got there&lt;&#x2F;h3&gt;
&lt;p&gt;Basically, aside from the boiler plate stuff, the function is one that takes another function and its parameters as input, and then outputs the minimum time taken to execute the code.
The initial declaration could be written as follows:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;cpp&quot; style=&quot;background-color:#1d1f21;color:#c5c8c6;&quot; class=&quot;language-cpp &quot;&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;template&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;typename&lt;&#x2F;span&gt;&lt;span&gt; F, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;typename&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;...&lt;&#x2F;span&gt;&lt;span&gt; ArgTypes &amp;gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;double &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;time_it&lt;&#x2F;span&gt;&lt;span&gt;( F&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;amp;&amp;amp; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;f&lt;&#x2F;span&gt;&lt;span&gt;, ArgTypes&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;amp;&amp;amp;... &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;args &lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This definition uses variadic templates.
You can find information on variadic templates on &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Variadic_template&quot;&gt;various&lt;&#x2F;a&gt; &lt;a href=&quot;http:&#x2F;&#x2F;en.cppreference.com&#x2F;w&#x2F;cpp&#x2F;language&#x2F;parameter_pack&quot;&gt;sites&lt;&#x2F;a&gt;.
The problem I had with that first iteration is that I could not specify the number of repetitions or the number of times I wanted to run the timing experiment (equivalent to the &lt;code&gt;n&lt;&#x2F;code&gt; and &lt;code&gt;r&lt;&#x2F;code&gt; parameters of Python&#x27;s &lt;code&gt;timeit&lt;&#x2F;code&gt;).
I had to find a way to do that which would allow for default values as well, since I did not want to specify those arguments every time I call the function.
To be able to use default values in C++, the defaulted parameters have to be last (no keyword arguments in C++ land).
That presented a problem because I also have to have a parameter pack.
So to work around that, I introduced two defaulted template arguments like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;cpp&quot; style=&quot;background-color:#1d1f21;color:#c5c8c6;&quot; class=&quot;language-cpp &quot;&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;template&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;unsigned int&lt;&#x2F;span&gt;&lt;span&gt; repeat_invoke &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;1000&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;unsigned int&lt;&#x2F;span&gt;&lt;span&gt; repeat_meas &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;3&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;typename&lt;&#x2F;span&gt;&lt;span&gt; F,
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;typename&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;...&lt;&#x2F;span&gt;&lt;span&gt; ArgTypes
&lt;&#x2F;span&gt;&lt;span&gt;        &amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;std::array&amp;lt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;double&lt;&#x2F;span&gt;&lt;span&gt;, repeat_meas &amp;gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;time_it&lt;&#x2F;span&gt;&lt;span&gt;( F&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;amp;&amp;amp; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;f&lt;&#x2F;span&gt;&lt;span&gt;, ArgTypes&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;amp;&amp;amp;... &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;args &lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Sorry for the reformatting of the template declaration.
I must admit I struggle to have a consistent formatting for templates.
I find nothing is completely satisfying.
I should probably just use &lt;a href=&quot;http:&#x2F;&#x2F;clang.llvm.org&#x2F;docs&#x2F;ClangFormat.html&quot;&gt;Clang Format&lt;&#x2F;a&gt;.
Anyhow, back to my function.
The addition of the two template arguments allowed me to change the return type to an array and I now have the functionality I want: I can specify, albeit as template parameters, the number of repetitions and the number of invocations at the call site.
All that was left to do was write the timing code, since the function invocation itself is simply:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;cpp&quot; style=&quot;background-color:#1d1f21;color:#c5c8c6;&quot; class=&quot;language-cpp &quot;&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span&gt;std::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;invoke&lt;&#x2F;span&gt;&lt;span&gt;( std::forward&amp;lt;F&amp;gt;(f), std::forward&amp;lt;ArgTypes&amp;gt;(args)&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;... &lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The use of &lt;code&gt;std::forward&lt;&#x2F;code&gt; in the code here is for efficiency.
The timing code is based on &lt;code&gt;std::chrono::high_resolution_clock&lt;&#x2F;code&gt;.
I chose to simply record the time before the invocation with &lt;code&gt;std::chrono::high_resolution_clock::now()&lt;&#x2F;code&gt; and do the same after.
The difference is the elapsed time.
The choice of the clock could be discussed.
The most important thing is for the clock to be steady.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;Example_&#x2F;_test&quot;&gt;Example &#x2F; test&lt;&#x2F;h3&gt;
&lt;p&gt;I have written a function which will make the current thread sleep for ten milliseconds.
Then, I have used my new &lt;code&gt;time_it&lt;&#x2F;code&gt; function to time the execution of the defined function.
The code is reproduced here and actually serves as a usage example.
There are also two calls with a lambda function, one taking arguments.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;cpp&quot; style=&quot;background-color:#1d1f21;color:#c5c8c6;&quot; class=&quot;language-cpp &quot;&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;void &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;my_fn&lt;&#x2F;span&gt;&lt;span&gt;()
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;using namespace&lt;&#x2F;span&gt;&lt;span&gt; std::chrono_literals;
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;std::this_thread::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;sleep_for&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;( &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;10&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;ms &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;)&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;int &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;main&lt;&#x2F;span&gt;&lt;span&gt;( &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;int &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;argc&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;char&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;* &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;argv&lt;&#x2F;span&gt;&lt;span&gt;[] )
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#969896;&quot;&gt;&#x2F;&#x2F; get times
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;auto&lt;&#x2F;span&gt;&lt;span&gt; test_val_0 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;time_it&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;( my_fn )&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;auto&lt;&#x2F;span&gt;&lt;span&gt; test_val_1 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;time_it&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;&amp;lt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;100&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;6 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;&amp;gt;( my_fn )&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;auto&lt;&#x2F;span&gt;&lt;span&gt; test_val_2 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;time_it&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;&amp;lt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;500 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;&amp;gt;( my_fn )&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;auto&lt;&#x2F;span&gt;&lt;span&gt; test_val_3 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;time_it&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;&amp;lt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;1000&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;2 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;&amp;gt;( my_fn )&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;auto&lt;&#x2F;span&gt;&lt;span&gt; test_val_4 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;time_it&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;&amp;lt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;1000&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;8 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;&amp;gt;( [](){
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;using namespace&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt; std::chrono_literals;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;            std::this_thread::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;sleep_for&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;( &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;5&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;ms &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;);
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;         } )&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;auto&lt;&#x2F;span&gt;&lt;span&gt; test_val_5 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;time_it&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;&amp;lt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;1000&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;3 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;&amp;gt;( []( &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;int&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt; lt, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;int&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt; rt ){
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;return&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt; lt &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;-&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt; rt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;         }, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;5&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;7 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt;)&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#969896;&quot;&gt;&#x2F;&#x2F; output results
&lt;&#x2F;span&gt;&lt;span&gt;   std::cout &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;lt;&amp;lt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5bd68;&quot;&gt;&amp;quot;exp 0: [ &amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;lt;&amp;lt;&lt;&#x2F;span&gt;&lt;span&gt; test_val_0[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;] &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&#x2F; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;1000000.0
&lt;&#x2F;span&gt;&lt;span&gt;             &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;lt;&amp;lt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5bd68;&quot;&gt;&amp;quot;, &amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;lt;&amp;lt;&lt;&#x2F;span&gt;&lt;span&gt;  test_val_0[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;] &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&#x2F; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;1000000.0
&lt;&#x2F;span&gt;&lt;span&gt;             &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;lt;&amp;lt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5bd68;&quot;&gt;&amp;quot;, &amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;lt;&amp;lt;&lt;&#x2F;span&gt;&lt;span&gt;  test_val_0[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;] &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&#x2F; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;1000000.0 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;lt;&amp;lt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5bd68;&quot;&gt;&amp;quot; ]&lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;\n&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5bd68;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;   std::cout &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;lt;&amp;lt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5bd68;&quot;&gt;&amp;quot;exp 1: [ &amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;lt;&amp;lt;&lt;&#x2F;span&gt;&lt;span&gt; test_val_1[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;] &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&#x2F; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;1000000.0
&lt;&#x2F;span&gt;&lt;span&gt;             &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;lt;&amp;lt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5bd68;&quot;&gt;&amp;quot;, &amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;lt;&amp;lt;&lt;&#x2F;span&gt;&lt;span&gt;  test_val_1[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;] &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&#x2F; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;1000000.0
&lt;&#x2F;span&gt;&lt;span&gt;             &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;lt;&amp;lt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5bd68;&quot;&gt;&amp;quot;, &amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;lt;&amp;lt;&lt;&#x2F;span&gt;&lt;span&gt;  test_val_1[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;] &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&#x2F; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;1000000.0
&lt;&#x2F;span&gt;&lt;span&gt;             &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;lt;&amp;lt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5bd68;&quot;&gt;&amp;quot;, &amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;lt;&amp;lt;&lt;&#x2F;span&gt;&lt;span&gt;  test_val_1[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;3&lt;&#x2F;span&gt;&lt;span&gt;] &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&#x2F; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;1000000.0
&lt;&#x2F;span&gt;&lt;span&gt;             &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;lt;&amp;lt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5bd68;&quot;&gt;&amp;quot;, &amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;lt;&amp;lt;&lt;&#x2F;span&gt;&lt;span&gt;  test_val_1[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;4&lt;&#x2F;span&gt;&lt;span&gt;] &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&#x2F; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;1000000.0
&lt;&#x2F;span&gt;&lt;span&gt;             &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;lt;&amp;lt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5bd68;&quot;&gt;&amp;quot;, &amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;lt;&amp;lt;&lt;&#x2F;span&gt;&lt;span&gt;  test_val_1[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;5&lt;&#x2F;span&gt;&lt;span&gt;] &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&#x2F; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;1000000.0 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;lt;&amp;lt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5bd68;&quot;&gt;&amp;quot; ]&lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;\n&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5bd68;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;   std::cout &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;lt;&amp;lt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5bd68;&quot;&gt;&amp;quot;exp 2: [ &amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;lt;&amp;lt;&lt;&#x2F;span&gt;&lt;span&gt; test_val_2[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;] &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&#x2F; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;1000000.0
&lt;&#x2F;span&gt;&lt;span&gt;             &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;lt;&amp;lt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5bd68;&quot;&gt;&amp;quot;, &amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;lt;&amp;lt;&lt;&#x2F;span&gt;&lt;span&gt;  test_val_2[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;] &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&#x2F; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;1000000.0
&lt;&#x2F;span&gt;&lt;span&gt;             &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;lt;&amp;lt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5bd68;&quot;&gt;&amp;quot;, &amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;lt;&amp;lt;&lt;&#x2F;span&gt;&lt;span&gt;  test_val_2[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;] &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&#x2F; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;1000000.0 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;lt;&amp;lt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5bd68;&quot;&gt;&amp;quot; ]&lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;\n&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5bd68;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;   std::cout &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;lt;&amp;lt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5bd68;&quot;&gt;&amp;quot;exp 3: [ &amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;lt;&amp;lt;&lt;&#x2F;span&gt;&lt;span&gt; test_val_3[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;] &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&#x2F; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;1000000.0
&lt;&#x2F;span&gt;&lt;span&gt;             &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;lt;&amp;lt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5bd68;&quot;&gt;&amp;quot;, &amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;lt;&amp;lt;&lt;&#x2F;span&gt;&lt;span&gt;  test_val_3[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;] &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&#x2F; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;1000000.0 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;lt;&amp;lt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5bd68;&quot;&gt;&amp;quot; ]&lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;\n&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5bd68;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;   std::cout &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;lt;&amp;lt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5bd68;&quot;&gt;&amp;quot;exp 4: [ &amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;lt;&amp;lt;&lt;&#x2F;span&gt;&lt;span&gt; test_val_4[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;] &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&#x2F; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;1000000.0
&lt;&#x2F;span&gt;&lt;span&gt;             &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;lt;&amp;lt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5bd68;&quot;&gt;&amp;quot;, &amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;lt;&amp;lt;&lt;&#x2F;span&gt;&lt;span&gt;  test_val_4[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;] &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&#x2F; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;1000000.0
&lt;&#x2F;span&gt;&lt;span&gt;             &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;lt;&amp;lt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5bd68;&quot;&gt;&amp;quot;, &amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;lt;&amp;lt;&lt;&#x2F;span&gt;&lt;span&gt;  test_val_4[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;] &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&#x2F; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;1000000.0
&lt;&#x2F;span&gt;&lt;span&gt;             &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;lt;&amp;lt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5bd68;&quot;&gt;&amp;quot;, &amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;lt;&amp;lt;&lt;&#x2F;span&gt;&lt;span&gt;  test_val_4[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;3&lt;&#x2F;span&gt;&lt;span&gt;] &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&#x2F; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;1000000.0
&lt;&#x2F;span&gt;&lt;span&gt;             &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;lt;&amp;lt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5bd68;&quot;&gt;&amp;quot;, &amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;lt;&amp;lt;&lt;&#x2F;span&gt;&lt;span&gt;  test_val_4[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;4&lt;&#x2F;span&gt;&lt;span&gt;] &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&#x2F; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;1000000.0
&lt;&#x2F;span&gt;&lt;span&gt;             &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;lt;&amp;lt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5bd68;&quot;&gt;&amp;quot;, &amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;lt;&amp;lt;&lt;&#x2F;span&gt;&lt;span&gt;  test_val_4[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;5&lt;&#x2F;span&gt;&lt;span&gt;] &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&#x2F; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;1000000.0
&lt;&#x2F;span&gt;&lt;span&gt;             &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;lt;&amp;lt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5bd68;&quot;&gt;&amp;quot;, &amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;lt;&amp;lt;&lt;&#x2F;span&gt;&lt;span&gt;  test_val_4[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;6&lt;&#x2F;span&gt;&lt;span&gt;] &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&#x2F; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;1000000.0
&lt;&#x2F;span&gt;&lt;span&gt;             &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;lt;&amp;lt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5bd68;&quot;&gt;&amp;quot;, &amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;lt;&amp;lt;&lt;&#x2F;span&gt;&lt;span&gt;  test_val_4[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;7&lt;&#x2F;span&gt;&lt;span&gt;] &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&#x2F; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;1000000.0 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;lt;&amp;lt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5bd68;&quot;&gt;&amp;quot; ]&lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;\n&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5bd68;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;   std::cout &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;lt;&amp;lt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5bd68;&quot;&gt;&amp;quot;exp 5: [ &amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;lt;&amp;lt;&lt;&#x2F;span&gt;&lt;span&gt; test_val_5[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span&gt;             &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;lt;&amp;lt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5bd68;&quot;&gt;&amp;quot;, &amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;lt;&amp;lt;&lt;&#x2F;span&gt;&lt;span&gt;  test_val_5[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span&gt;             &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;lt;&amp;lt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5bd68;&quot;&gt;&amp;quot;, &amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;lt;&amp;lt;&lt;&#x2F;span&gt;&lt;span&gt;  test_val_5[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;] &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8abeb7;&quot;&gt;&amp;lt;&amp;lt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5bd68;&quot;&gt;&amp;quot; ]&lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;\n&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5bd68;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span style=&quot;color:#de935f;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;and the output on my machine is:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;bash&quot; style=&quot;background-color:#1d1f21;color:#c5c8c6;&quot; class=&quot;language-bash &quot;&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;exp&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt; 0: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt; 10.0203, 10.0184, 10.0266 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;exp&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt; 1: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt; 10.0465, 10.0373, 10.0241, 10.0198, 10.0214, 10.0243 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;exp&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt; 2: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt; 10.0152, 10.0176, 10.0305 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;exp&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt; 3: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt; 10.02, 10.0174 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;exp&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt; 4: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt; 5.01679, 5.01788, 5.01327, 5.01883, 5.02777, 5.02198, 5.01831, 5.01463 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;exp&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt; 5: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a2be;&quot;&gt; 55, 55, 55 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b294bb;&quot;&gt;]
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;which, for the four first cases, is slightly more than 10ms and is what was expected.
The expected value for the experiment labeled 4 is slightly higher than 5 ms and for the last lambda, it should be in the nanoseconds range, which it is.
Of course, the constant value is suspicious and probably means the actual value is actually lower, but the &lt;code&gt;time_it&lt;&#x2F;code&gt; overhead and the clock precision is so that nothing below the 55ns value can be measured on my machine.
I have not determined the error bar on the time measurement.
This is a complex subject and much more work would be needed to test for that.
One other thing I have not tried in this example is the timing of a member function, but it should work.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;What_is_impossible&quot;&gt;What is impossible&lt;&#x2F;h3&gt;
&lt;p&gt;There are things I have found are not possible with the function as it stands.
One of them is the inability to pass &lt;code&gt;time_it&lt;&#x2F;code&gt; a template function as an argument without specifying the template arguments of the passed in (or timed) function.
I might be wrong, but I have not found a way to do that.
Explicit argument passing is tedious and so &lt;code&gt;time_it&lt;&#x2F;code&gt; might not be very useful in those cases.&lt;&#x2F;p&gt;
&lt;p&gt;One other capability Python&#x27;s &lt;code&gt;timeit&lt;&#x2F;code&gt; has that this one does not is the ability to accept setup code which is executed before the experiment is run.
I am not sure how useful that would be in the context of C++.
Of course, I can&#x27;t imagine what others would use &lt;code&gt;time_it&lt;&#x2F;code&gt; for, so it might be useful even though I can&#x27;t see it, but I am not writing the STL!
It&#x27;s just that in my view, since C++ is compiled and not interpreted, &lt;code&gt;time_it&lt;&#x2F;code&gt; will still require a main function and an executable to run, unlike Python&#x27;s &lt;code&gt;timeit&lt;&#x2F;code&gt; which can be run on the fly from the command line to test something out.
To my mind, the setup code can then be written in the main function to no real cost compared to having it done in the &lt;code&gt;time_it&lt;&#x2F;code&gt; function.
That being said, I believe it would be possible to accept a setup function by making the input of &lt;code&gt;time_it&lt;&#x2F;code&gt; two tuples of function and arguments, the first being the function to test and the second being the setup function.
I am just not 100% certain that it would be useful and I cannot say for sure that it can be done because I have not tried implementing it.
In my opinion, it would make calling the function without setup code much uglier.
Maybe an overload taking two tuples and the current version could live together and that would allow the functionality at &amp;quot;no cost&amp;quot;.&lt;&#x2F;p&gt;
&lt;p&gt;Anyhow, those are my thoughts on the matter for now.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;Notes&quot;&gt;Notes&lt;&#x2F;h3&gt;
&lt;p id=&quot;ftnt:1&quot;&gt;&lt;sup&gt;[1]&lt;&#x2F;sup&gt;&amp;nbsp;I chose the name with an underscore to differentiate the function from its Python counterpart since my version does not do &lt;em&gt;exactly&lt;&#x2F;em&gt; all the stuff the python version can!&amp;nbsp;&lt;a href=&quot;#ftntref:1&quot;&gt;&amp;#8617;&amp;#65038;&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
</content>
  </entry>
  <entry xml:lang="en">
    <title>Static Site</title>
    <author>codeattempts@gmail.com</author>
    <published>2015-12-29T17:32:00</published>
    <updated>2015-12-29T17:32:00</updated>
    <link href="https://ghlecl.github.io/posts/static_site/" type="text/html"/>
    <id>https://ghlecl.github.io/posts/static_site/</id>
    <summary>
   Hugo
In a previous entry, I described how I got to using GitHub Pages.
That was one of the (if not the) first question I had to figure out when I decided to write my notes in an Internet format (ok, blog, but I don't see myself as a blogger).
The second thing I had to figure out was what to use as a writing tool.
I could simply write static HTML by hand and leave it</summary>
    <content>&lt;h1 id=&quot;Hugo&quot;&gt;Hugo&lt;&#x2F;h1&gt;
&lt;p&gt;In a &lt;a href=&quot;https:&#x2F;&#x2F;ghlecl.github.io&#x2F;posts&#x2F;github_pages&#x2F;&quot;&gt;previous&lt;&#x2F;a&gt; entry, I described how I got to using &lt;a href=&quot;https:&#x2F;&#x2F;pages.github.com&#x2F;&quot;&gt;GitHub Pages&lt;&#x2F;a&gt;.
That was one of the (if not the) first question I had to figure out when I decided to write my notes in an Internet format (ok, blog, but I don&#x27;t see myself as a blogger).
The second thing I had to figure out was what to use as a writing tool.
I could simply write static HTML by hand and leave it at that (actually, if you stumbled upon this website before I posted my first few posts, I left a Hello World page up for a few weeks&#x2F;months while figuring all this out!).
I am trying to set the bar a little higher than that for myself.&lt;&#x2F;p&gt;
&lt;p&gt;For work, I have been playing with &lt;a href=&quot;https:&#x2F;&#x2F;www.djangoproject.com&quot;&gt;Django&lt;&#x2F;a&gt; and at some point, I thought I could write something in Django or use a Django CMS, but since GitHub Pages only serve static content, I had to abandon that plan.
I could have done static HTML with some CSS framework like &lt;a href=&quot;http:&#x2F;&#x2F;getbootstrap.com&quot;&gt;Bootstrap&lt;&#x2F;a&gt; or &lt;a href=&quot;http:&#x2F;&#x2F;foundation.zurb.com&quot;&gt;Foundation&lt;&#x2F;a&gt;.
Actually, that is how I started to write all of this, but then, the same friend of mine that pointed me in the direction of GitHub Pages, also reminded me that they suggest a workflow with &lt;a href=&quot;http:&#x2F;&#x2F;jekyllrb.com&quot;&gt;Jekyll&lt;&#x2F;a&gt;.
Trying to get information about that, I learned that Jekyll is what is called a static site generator and that there are quite a few &lt;a href=&quot;https:&#x2F;&#x2F;www.staticgen.com&#x2F;&quot;&gt;alternatives&lt;&#x2F;a&gt; out there.
Looking at a few of the alternatives, I decided to go with &lt;a href=&quot;https:&#x2F;&#x2F;gohugo.io&#x2F;&quot;&gt;Hugo&lt;&#x2F;a&gt; (no pun intended), originally written by &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;spf13&quot;&gt;Steve Francia&lt;&#x2F;a&gt;.
I can&#x27;t claim to have researched the subject extensively, but Hugo seemed like it was configurable enough for my needs&#x2F;tastes, fast enough and easy enough.&lt;&#x2F;p&gt;
&lt;p&gt;Basically, the idea of a static site generator is to &amp;quot;build&amp;quot; a website telling a build system (I like to think of it as a compiler) how to construct each individual page using templates.
Then, all you do is generate new (mostly) unformatted content and ask the generator to rebuild the site.
This will update everything and include the new content.
As it constructs these pages, the build system will make a list of the entries and collect bits and pieces of informations which it will make available to you via a templating language (Hugo being written in &lt;a href=&quot;https:&#x2F;&#x2F;golang.org&#x2F;&quot;&gt;Go&lt;&#x2F;a&gt;, it uses Go&#x27;s templating language).
You will be able to access that information more or less easily depending on the templating language and insert it in your templates.
For instance, to create a page listing all the posts of the site, you could, in the template, loop through the list of posts and add each of them in a &lt;code&gt;&amp;lt;ul&amp;gt;&lt;&#x2F;code&gt; element.
As another example, you can get the title of the post in the template so that when designing the page, you can style that title as you please.
For instance:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;html&quot; style=&quot;background-color:#1d1f21;color:#c5c8c6;&quot; class=&quot;language-html &quot;&gt;&lt;code class=&quot;language-html&quot; data-lang=&quot;html&quot;&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;&amp;lt;h2 style=&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5bd68;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;bad idea, use CSS !&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b5bd68;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;&amp;gt;&lt;&#x2F;span&gt;&lt;span&gt; $.Page.Title &lt;&#x2F;span&gt;&lt;span style=&quot;color:#cc6666;&quot;&gt;&amp;lt;&#x2F;h2&amp;gt;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;I am not suggesting it is a good practice to style that way (as mentioned in the example), but it illustrates my point about the variables.
In the templates, you can also include JavaScript or any other kind of valid HTML you want.
You can therefore use a front-end CSS framework like &lt;a href=&quot;http:&#x2F;&#x2F;zurb.com&#x2F;&quot;&gt;Zurb&lt;&#x2F;a&gt; Foundation or &lt;a href=&quot;https:&#x2F;&#x2F;twitter.com&#x2F;&quot;&gt;Twitter&lt;&#x2F;a&gt; Bootstrap.&lt;&#x2F;p&gt;
&lt;p&gt;Alright, this is how I got to Hugo.
I will stop here and start a new post on my setup.
The next post will mark my first post that will actually be what I want for this little site: notes for me on how I did things.
It really is necessary.
Since writing the previous post, I have not done anything involving Hugo and already, I can&#x27;t really remember the organization of all of this.
Hopefully, taking notes will help.&lt;&#x2F;p&gt;
</content>
  </entry>
  <entry xml:lang="en">
    <title>GitHub Pages</title>
    <author>codeattempts@gmail.com</author>
    <published>2015-11-23T21:05:00</published>
    <updated>2015-11-23T21:05:00</updated>
    <link href="https://ghlecl.github.io/posts/github_pages/" type="text/html"/>
    <id>https://ghlecl.github.io/posts/github_pages/</id>
    <summary>
   GitHub Pages
This is one of my first posts.
I have been toying with the idea of this blog for quite some time now.
A flaw of mine: too much searching for the best solution, not enough implementing.
I end up doing things too late.
Anyhow, I digress.
One of the relevant questions when thinking of writing a blog is of course where to publish and what tool(s) to use.
At some point, I was thinking of hosting on an</summary>
    <content>&lt;h1 id=&quot;GitHub_Pages&quot;&gt;GitHub Pages&lt;&#x2F;h1&gt;
&lt;p&gt;This is one of my first posts.
I have been toying with the idea of this blog for quite some time now.
A flaw of mine: too much searching for the best solution, not enough implementing.
I end up doing things too late.
Anyhow, I digress.&lt;&#x2F;p&gt;
&lt;p&gt;One of the relevant questions when thinking of writing a blog is of course where to publish and what tool(s) to use.
At some point, I was thinking of hosting on an old computer of mine.
Played with the different servers (compiled &lt;a href=&quot;https:&#x2F;&#x2F;httpd.apache.org&quot;&gt;Apache&lt;&#x2F;a&gt;, &lt;a href=&quot;https:&#x2F;&#x2F;www.lighttpd.net&quot;&gt;lighttpd&lt;&#x2F;a&gt; and &lt;a href=&quot;https:&#x2F;&#x2F;www.nginx.com&quot;&gt;Nginx&lt;&#x2F;a&gt;).
Then, I realized all the time involved in maintaining my own server and changed my mind.
I did not want to deal with the security updates and the log checking (or the program checking the logs...).
Not that I am naïve enough to think my content is worth hacking, but using my machine on a bot net or whatnot might be.&lt;&#x2F;p&gt;
&lt;p&gt;After that, I started looking into shared hosting.
That could have worked, I even paid for a few months, but did nothing productive.
Was still learning everything and for some reason (a friend of mine would say control issues, but who knows really !), I did not want to go with &lt;a href=&quot;https:&#x2F;&#x2F;wordpress.com&#x2F;&quot;&gt;WordPress&lt;&#x2F;a&gt;,
&lt;a href=&quot;https:&#x2F;&#x2F;www.joomla.org&#x2F;&quot;&gt;Joomla&lt;&#x2F;a&gt; or another content management system.
That seemed like overkill for my needs and yes, I like to control things on my computer a little too much for my own good and I did not feel I could get control over those behemoths in a reasonable timeframe.
Most of the shared hosting I looked into (probably not exhaustive) seemed pre-configured for the CMS like systems, but not for other things and I found myself again trying to configure Apache on the shared host.&lt;&#x2F;p&gt;
&lt;p&gt;I gave up for a while.
I was busy with other things; but lately, I have been coming back to the idea of this blog.
Hence my looking into all those things again.
That&#x27;s when a very good friend of mine suggested I look into &lt;a href=&quot;https:&#x2F;&#x2F;pages.github.com&#x2F;&quot;&gt;GitHub Pages&lt;&#x2F;a&gt;.
The idea is very interesting and if someone else is reading this, it means I actually went through with this.
I personally have two basic needs for a server: 1) writing a blog (and maybe a private section as a journal) and 2) hosting private projects on Git.
With GitHub Pages, I can actually easily create the blog and if I pay for a GitHub account, I believe I should be able to do the private journal and the Git hosting as well.
The monthly cost will be roughly the same as a hosted plan and I will have almost zero if not zero administration to do.&lt;&#x2F;p&gt;
&lt;p&gt;So that&#x27;s how I came to GitHub pages!  I am sure that since I am a novice at the Internet (well creating content other then on my Facebook account), there are some assumptions I have made that are wrong and my solution might be sub-optimal, but it works for me.&lt;&#x2F;p&gt;
&lt;p&gt;Now, let&#x27;s see if I can make a habit of writing.&lt;&#x2F;p&gt;
</content>
  </entry>
  <entry xml:lang="en">
    <title>About me</title>
    <author>codeattempts@gmail.com</author>
    <published>2015-09-01T00:00:00</published>
    <updated>2015-09-01T00:00:00</updated>
    <link href="https://ghlecl.github.io/about/" type="text/html"/>
    <id>https://ghlecl.github.io/about/</id>
    <summary>
   Hi.
I'm Ghys, a French Canadian living in the province of Québec, Canada.
I make a living as a medical physicist.
I like trying to get computers to do the actual data crunching for me.
I am a hobbyist programmer and this blog is mostly a way for me to write down notes and lessons about my code attempts.
I also write about random stuff.
Feel free to read or skip whatever you want!
</summary>
    <content>&lt;p&gt;Hi.
I&#x27;m Ghys, a French Canadian living in the province of Québec, Canada.
I make a living as a medical physicist.
I like trying to get computers to do the actual data crunching for me.
I am a hobbyist programmer and this blog is mostly a way for me to write down notes and lessons about my code attempts.
I also write about random stuff.
Feel free to read or skip whatever you want!&lt;&#x2F;p&gt;
</content>
  </entry>
</feed>
