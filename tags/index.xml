<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>@ghleclâ€™s Code Attempts - Code Attempts</title>
    <link>https://ghlecl.github.io/https://ghlecl.github.io/</link>
    <description>All entries in Code Attempts on Code Attempts</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    
    <lastBuildDate>Thu, 13 Sep 2018 00:00:00 +0000</lastBuildDate>
    <atom:link href="/" rel="self" type="application/rss+xml" />
    
      
      <item>
        <title>Invoking a callable in C&#43;&#43;</title>
        <link>https://ghlecl.github.io/posts/cpp_invoke/</link>
        <pubDate>Thu, 13 Sep 2018 00:00:00 +0000</pubDate>
        <author>codeattempts@gmail.com - Ghyslain Leclerc</author>
        <guid>https://ghlecl.github.io/posts/cpp_invoke/</guid>
        <description>

&lt;h1 id=&#34;invoking-a-callable-in-c&#34;&gt;Invoking a callable in C++&lt;/h1&gt;

&lt;p&gt;This is my exploration of the &lt;a href=&#34;https://en.cppreference.com/w/cpp/utility/functional/invoke&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;std::invoke&lt;/code&gt;&lt;/a&gt; utility of C++17.
I started with something &lt;em&gt;vaguely&lt;/em&gt; related (which I am discussing here) and
ended up reading the standard library implementation of &lt;code&gt;std::invoke&lt;/code&gt; (and that
of Google&amp;rsquo;s &lt;a href=&#34;https://abseil.io/&#34; target=&#34;_blank&#34;&gt;Abseil&lt;/a&gt; library).  The funny thing is that in
the end, I decided I did not really need any of it for my original motivation,
but I did gain some knowledge along the way, so worth the time!&lt;/p&gt;

&lt;h2 id=&#34;my-original-motivation&#34;&gt;My original motivation&lt;/h2&gt;

&lt;p&gt;Even though &lt;a href=&#34;https://herbsutter.com/2011/10/07/why-no-container-based-algorithms&#34; target=&#34;_blank&#34;&gt;there are reasons&lt;/a&gt;
not to have container based algorithms in the C++ standard library (upcoming
ranges being one more reason), in my code, I find my main use case for the
algorithms is still to work on the whole container.  Because of that, I was
looking into ways to get whole container overloads for the algorithms.  In that
endeavor, I stumbled upon &lt;a href=&#34;https://ideone.com/aruf06&#34; target=&#34;_blank&#34;&gt;this&lt;/a&gt; solution.  In the
usage examples at the bottom of the code, one finds two usage syntaxes:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;apply_on( bobs, for_each, std::mem_fn( &amp;amp;Bob::stuff) );
for_each_on( bobs, std::mem_fn( &amp;amp;Bob::stuff ) );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;where the &lt;code&gt;for_each_on&lt;/code&gt; is obviously not in the &lt;code&gt;std&lt;/code&gt; namespace.  This is very
close to what I am looking for, which is a function with the name &lt;code&gt;for_each&lt;/code&gt;
that will simply forward its call to the &lt;code&gt;std::for_each&lt;/code&gt;, but will work on the
whole container rather than asking for two iterators.  Something that would look
like that:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;for_each( bobs, &amp;amp;Bob::stuff );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;where this &lt;code&gt;for_each&lt;/code&gt; is not the one in namespace &lt;code&gt;std&lt;/code&gt; (but shares its name
with it as opposed to the &lt;code&gt;for_each_on&lt;/code&gt; function in the solution I found online).&lt;/p&gt;

&lt;p&gt;In adapting/inserting this solution to my code, I realized that the custom
&lt;code&gt;apply_on&lt;/code&gt; function I found online is pretty much a particular case of C++17&amp;rsquo;s
&lt;a href=&#34;https://en.cppreference.com/w/cpp/utility/functional/invoke&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;std::invoke&lt;/code&gt;&lt;/a&gt;.
Since I am not interested in directly using the &lt;code&gt;apply_on&lt;/code&gt; function as shown in
the examples of the online solution, I thought I should just adapt it to use
&lt;code&gt;std::invoke&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Unfortunately, at work, not all the external libraries that our projects depend
on have transitioned to C++17.  Therefore, to use &lt;code&gt;std::invoke&lt;/code&gt;, I needed a
working C++11 implementation (which would of course then not be in the &lt;code&gt;std&lt;/code&gt;
namespace, but I digress). Turns out it is not that hard to find &lt;a href=&#34;https://github.com/tomaszkam/proposals/tree/master/invoke&#34; target=&#34;_blank&#34;&gt;a&lt;/a&gt;
&lt;a href=&#34;https://github.com/Rapptz/Gears/blob/master/gears/functional/invoke.hpp&#34; target=&#34;_blank&#34;&gt;C++11&lt;/a&gt;
&lt;a href=&#34;https://github.com/abseil/abseil-cpp/blob/master/absl/base/internal/invoke.h&#34; target=&#34;_blank&#34;&gt;implementation&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;That said, before using any of them, I wanted to make sure I understand the
concepts so that I can provide support if necessary.  Thus, I set out to read
and understand those implementations.  In the process, I came up with my own,
which I am discussing here.  I do not pretend this implementation is superior or
even on par with the others I have seen (and certainly not with the standard
library implementations out there), but from the tests I have made (comparing
with Clang&amp;rsquo;s implementation on a C++17 compiler I have access to), it seems to
be as capable (probably did not think of every conceivable test).  It might,
however, be very slow to compile and suboptimal.&lt;/p&gt;

&lt;h2 id=&#34;syntax-es-of-a-call-in-c&#34;&gt;Syntax(es) of a &amp;ldquo;call&amp;rdquo; in C++&lt;/h2&gt;

&lt;p&gt;Before I embarked on this journey, I had never needed to make function calls
through function pointers or member pointers.  I have had the luxury/luck of
working only on newer projects that did not involve that many callbacks.  Lambdas
have mostly always been available to me, so I was not familiar with the various
call syntaxes of function pointers, member pointers and the like.  Since I could
use lambdas, when I needed to call some member function on all the elements of a
vector, for instance, I just created a lambda doing exactly that and never
considered using a pointer to the member.  Thus, my first hurdle was
understanding the problem space of calling something in C++.&lt;/p&gt;

&lt;p&gt;Although the section on the magical &lt;code&gt;INVOKE&lt;/code&gt; entity&lt;sup&gt;[1]&lt;/sup&gt; in the C++ 17
standard (which is section &lt;em&gt;23.14.3&amp;nbsp;Requirements&amp;nbsp;([&lt;em&gt;func.require&lt;/em&gt;])&lt;/em&gt;)
has seven bullet points, when looking at the bigger picture, I think it is a
useful approximation to summarize by saying there are three call syntaxes in C++:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;function call syntax&lt;/li&gt;
&lt;li&gt;member function pointer call syntax&lt;/li&gt;
&lt;li&gt;member object pointer call syntax&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;where member object is roughly standardese for data member. Translated in pseudo
code, the three syntaxes above look like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;invocable( arguments );           // function syntax
object.*invocable( arguments );   // member function pointer syntax
object.*invocable;                // member object pointer syntax
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The first syntax can be applied to any invocable that is not a member, be it a
regular function, a function pointer, a lambda or a &lt;code&gt;struct&lt;/code&gt; defining a call
operator (&lt;code&gt;operator()&lt;/code&gt;).  The two others are used when dealing with pointers to
member.  Whether one is dealing with a pointer to member function or to member
object, the standard allows using said pointer to call &amp;ldquo;into&amp;rdquo; an object of a
related type either directly, through a &lt;code&gt;std::reference_wrapper&lt;/code&gt; or through a
pointer.  In other words, there is a clause in the standard for each of the
following calls (again in pseudo code):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;(object.*invocable)( arguments )         // object
(wrapper.get().*invocable)( arguments )  // std::reference_wrapper
(*pointer.*invocable)( arguments )       // pointer to object

object.*invocable           // object
wrapper.get().*invocable    // std::reference_wrapper
*pointer.*invocable         // pointer to object
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that the parentheses in the first three lines are necessary because the
function call operator (i.e. &lt;code&gt;operator()&lt;/code&gt;) has lower
&lt;a href=&#34;https://en.cppreference.com/w/cpp/language/operator_precedence&#34; target=&#34;_blank&#34;&gt;precedence&lt;/a&gt;
than the pointer-to-member operator (i.e. &lt;code&gt;operator.*&lt;/code&gt;).  If the parentheses
were not there, i.e. if the first line were written
&lt;code&gt;object.*invocable( arguments )&lt;/code&gt; instead of the current syntax, then the order
of operations would be &lt;code&gt;invocable( arguments )&lt;/code&gt; before &lt;code&gt;object.*invocable&lt;/code&gt;, and
that would error out: the compiler would rightfully complain that the type of
&lt;code&gt;invocable&lt;/code&gt; is not a callable because it would not access the member before
trying to call it.&lt;/p&gt;

&lt;p&gt;Adding the general function call syntax to the list above, one gets a total of
seven call syntaxes, one per bullet point of the standard.  In the end, a
conforming implementation of &lt;code&gt;std::invoke&lt;/code&gt; must provide this single function
template which will, based on the type of its parameters and arguments, use the
correct call syntax for the situation.  Getting there is not as easy as it seems
(underestimating implementation difficulty is a recurring theme for me&amp;hellip;).  In
all the C++11 implementations I have seen, it involves at least
&lt;a href=&#34;https://en.cppreference.com/w/cpp/language/sfinae&#34; target=&#34;_blank&#34;&gt;SFINAE&lt;/a&gt; and
&lt;a href=&#34;https://en.cppreference.com/w/cpp/language/function_template
#Function_template_overloading&#34; target=&#34;_blank&#34;&gt;function template partial ordering&lt;/a&gt;.
In C++17, using &lt;a href=&#34;https://en.cppreference.com/w/cpp/language/if#Constexpr_If&#34; target=&#34;_blank&#34;&gt;constexpr if&lt;/a&gt;, it is possible
to have a simpler implementation (see
&lt;a href=&#34;https://en.cppreference.com/w/&#34; target=&#34;_blank&#34;&gt;cppreference.com&lt;/a&gt; &lt;a href=&#34;https://en.cppreference.com/w/cpp/utility/functional/invoke
#Possible_implementation&#34; target=&#34;_blank&#34;&gt;possible implementation&lt;/a&gt;),
but, as mentioned, that was not a possibility for me.  Before reading on (if you
are still interested), I would suggest reading up on SFINAE (specifically the
&lt;a href=&#34;https://en.cppreference.com/w/cpp/types/enable_if&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;std::enable_if&lt;/code&gt;&lt;/a&gt;
technique/idiom), and maybe a little on function template partial ordering.  I
do not explain the former at all, while I do say a little bit on the latter as I
have discovered it while understanding the implementations of &lt;code&gt;invoke&lt;/code&gt; and this
blog serves a bit as my note-taking!&lt;/p&gt;

&lt;h2 id=&#34;c-17-s-std-invoke&#34;&gt;C++17&amp;rsquo;s &lt;code&gt;std::invoke&lt;/code&gt;&lt;/h2&gt;

&lt;h3 id=&#34;the-naÃ¯ve-starting-point&#34;&gt;The naÃ¯ve starting point&lt;/h3&gt;

&lt;p&gt;Considering only the function call syntax, the function template needed can be
as simple as:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;template&amp;lt; typename Invocable, typename... Args &amp;gt;
auto invoke( Invocable invocable, Args... args )
   -&amp;gt; decltype( invocable( args... ) ) {
   return invocable( args... );
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Although it will work for the function call syntax, this implementation is naÃ¯ve,
not taking into account argument passing efficiency (perfect forwarding) or
&lt;code&gt;noexcept&lt;/code&gt; specification.  It will also obviously fail for any other syntax in
the list presented in the previous section.  We need to have other
specializations or overloads which will handle the other call syntaxes.  Since
it is a function template and not a class/struct template, it is not possible to
partially specialize it.  I do not think it is possible to use full
specialization to create the overload set needed, but I might be wrong.  That
said, it is however possible to overload it and select the appropriate overload
via SFINAE or function template partial ordering, which is what I have seen in
most implementation, and what is explored next.&lt;/p&gt;

&lt;h3 id=&#34;member-pointers&#34;&gt;Member pointers&lt;/h3&gt;

&lt;p&gt;As written above, the &lt;code&gt;invoke&lt;/code&gt; function will not work for member pointers.
Different approaches can be taken to deal with this problem and allow the
function to be called with other member pointers.  One way is to write an
overload of the function which will not take just any invocable as an argument,
but only member pointers.  This overload will still need to be a template to
accommodate member pointers of any type and some mechanism is needed to insure
that the template is selected only when called with a member pointer.  One way
to achieve this is through &lt;a href=&#34;https://en.cppreference.com/w/cpp/language/function_template#Function_template
_overloading&#34; target=&#34;_blank&#34;&gt;function template partial ordering&lt;/a&gt;, which is what most implementations that I have seen have used.
Since I have been influenced by those implementations, I did the same.  There
could have been alternatives, for instance SFINAE.&lt;sup&gt;[2]&lt;/sup&gt;  That said, I
went with partial ordering.  This concept relies on template parameters and
function arguments being such that one function is considered more specialized
than the other.  The algorithm for partial ordering is well explained in
&lt;a href=&#34;https://stackoverflow.com/a/17008568&#34; target=&#34;_blank&#34;&gt;this StackOverflow answer&lt;/a&gt;.  As stated in
the answer, a comment of the original question gives a pretty good description
of the concept:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Partial ordering basically checks in the parameters of two templates, if the
parameter of one is more restrictive than the corresponding parameter of the
other. If you have &lt;code&gt;f(T)&lt;/code&gt; and &lt;code&gt;f(bar&amp;lt;T&amp;gt;)&lt;/code&gt; (with &lt;code&gt;T&lt;/code&gt; as a template parameter),
then the first overload can take all possible arguments of the second
overload, but the second overload can&amp;rsquo;t take all possible arguments from the
first overload - only those of the &lt;code&gt;bar&amp;lt;T&amp;gt;&lt;/code&gt; form.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Putting aside perfect forwarding and the &lt;code&gt;noexcept&lt;/code&gt; specification for now
(we&amp;rsquo;ll come back to them in the end), an overload of the function template which
uses function template partial ordering can be written like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;template&amp;lt; typename MemPtr, typename Obj, typename Arg1, typename... Args &amp;gt;
auto invoke( MemPtr Obj::* invocable, Arg1 arg1, Args... args )
   -&amp;gt; decltype( (arg1.*invocable)( args... ) ) {
   return (arg1.*invocable)( args... );
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The template parameters are the member pointer type (&lt;code&gt;MemPtr&lt;/code&gt;), the type pointed
into by the member pointer (&lt;code&gt;Obj&lt;/code&gt;), the object type the pointer is called on
(&lt;code&gt;Arg1&lt;/code&gt;&lt;sup&gt;[3]&lt;/sup&gt;) and the subsequent argument types (&lt;code&gt;Args...&lt;/code&gt;), if any.
For plain function pointers, this deduction will fail because the first function
argument will not be a match, and the original overload will be selected.  For
member pointers, the substitution will succeed and this overload will be
considered more specialized, and it will be selected as intended.  Note again
the parentheses around the &lt;code&gt;arg1.*invocable&lt;/code&gt; both in the &lt;code&gt;decltype&lt;/code&gt; and in the
template body.  As mentioned in the previous section, those are mandatory.&lt;/p&gt;

&lt;p&gt;Although this template does work, in its current form, it will be selected
whenever &lt;code&gt;invoke&lt;/code&gt; is called with a member pointer as its first argument,
even if the object you want to invoke the pointer on (the second argument to
&lt;code&gt;invoke&lt;/code&gt; which has type &lt;code&gt;Arg1&lt;/code&gt;) is unrelated to the type the pointer points
into (type &lt;code&gt;Obj&lt;/code&gt;).  This is a problem because for arbitrary unrelated types,
using the function pointer from one type on the other will fail to compile.
To prevent this overload from being selected when the types are unrelated,
SFINAE can be used.  To do this, a defaulted template parameter is added after
the parameter pack and defaulted to &lt;code&gt;enable_if_t&lt;/code&gt;&lt;sup&gt;[4]&lt;/sup&gt; with a predicate
to filter out the cases that should not match. In this case, the predicate is
&lt;code&gt;std::is_base_of&amp;lt; Obj, Arg1 &amp;gt;&lt;/code&gt; and the solution looks like this:
this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;template&amp;lt;
   typename MemPtr,
   typename Obj,
   typename Arg1,
   typename... Args,
   typename = enable_if_t&amp;lt; std::is_base_of&amp;lt; Obj, Arg1 &amp;gt;::value &amp;gt;
&amp;gt;
auto invoke( MemPtr Obj::* invocable, Arg1 arg1, Args... args )
   -&amp;gt; decltype( (arg1.*invocable)( args... ) ) {
   return (arg1.*invocable)( args... );
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;where we can bikeshed my formatting some other time! ðŸ™‚  With this in place,
this overload will not be selected when there is no inheritance (or identity)
relationship between the member pointer object type (&lt;code&gt;Obj&lt;/code&gt;) and the invoked-on
object type (&lt;code&gt;Arg1&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;Alright, this overload is a step in the right direction, but it still cannot be
used with member &lt;em&gt;object&lt;/em&gt; pointers.  That is because the call syntax is wrong:
there must not be an argument list after the invocable.  If we want to have
member object pointers working, there has to be a third overload with the
appropriate call syntax.  If there is a third overload, there needs to be a way
to select it when needed, and one cannot rely only on the function template
partial ordering, since this will distinguish between callables and member
pointers, but not between different member pointers, since they have the same
syntax in the function argument list.  For this, we must rely once more on
SFINAE and the standard library type traits, adding one more defaulted
template parameter after the parameter pack for one of the overloads:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;template&amp;lt;
   typename MemPtr,
   typename Obj,
   typename Arg1,
   typename... Args,
   typename = enable_if_t&amp;lt; std::is_base_of&amp;lt; Obj, Arg1 &amp;gt;::value &amp;gt;,
   typename = enable_if_t&amp;lt; std::is_member_function_pointer&amp;lt; MemPtr Obj::* &amp;gt;::value &amp;gt;
&amp;gt;
auto invoke( MemPtr Obj::* invocable, Arg1 arg1, Args... args )
   -&amp;gt; decltype( (arg1.*invocable)( args... ) ) {
   return (arg1.*invocable)( args... );
}

template&amp;lt;
   typename MemPtr,
   typename Obj,
   typename Arg1,
   typename = enable_if_t&amp;lt; std::is_base_of&amp;lt; Obj, Arg1 &amp;gt;::value &amp;gt;
&amp;gt;
auto invoke( MemPtr Obj::* invocable, Arg1 arg1 )
   -&amp;gt; decltype( arg1.*invocable ) {
   return arg1.*invocable;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It should be noted that using the predicate &lt;code&gt;std::is_member_object_pointer&lt;/code&gt; on
the last overload instead would have also worked.  Now, the overload set of
the three &lt;code&gt;invoke&lt;/code&gt; functions defined above will be callable on anything that has
the free function syntax, the member function pointer syntax or the member
object (a.k.a. data member) pointer syntax, if the latter two are used directly
with an object of the appropriate type (i.e. a type the member pointer points
into or a type derived from it).  This constitutes only three of the seven
syntaxes mandated by the standard.  None of the overloads will work if the
object to call the member pointer on (&lt;code&gt;arg1&lt;/code&gt;) is a &lt;code&gt;std::reference_wrapper&lt;/code&gt; of
such an object or a pointer to such an object.  Still some distance to go.&lt;/p&gt;

&lt;h3 id=&#34;invoked-on-object-type&#34;&gt;Invoked-on object type&lt;/h3&gt;

&lt;p&gt;If you have felt like this is getting verbose already, you are not going to like
the rest of this blog post.  Basically, for each of the two last overloads,
three variants are needed (the one already defined and two more):&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;one that can be called with an object of the type the member pointer points
 into (or a type derived from it),&lt;/li&gt;
&lt;li&gt;one that can be called with a &lt;code&gt;std::reference_wrapper&lt;/code&gt; to an object of the
 type the member pointer points into (or a type derived from it),&lt;/li&gt;
&lt;li&gt;or one that can be called on a pointer to an object of the type the member
 pointer points into (or a type derived from it).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Expressed in a more concrete way, considering the &lt;code&gt;invoke&lt;/code&gt; overloads as defined
above and using the argument types in their declarations, the previous text
means that if &lt;code&gt;Arg1&lt;/code&gt; is of the type &lt;code&gt;Obj&lt;/code&gt; or a type derived from it, &lt;code&gt;invoke&lt;/code&gt;
should be able to call the member pointer with&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;an object of type &lt;code&gt;Arg1&lt;/code&gt;,&lt;/li&gt;
&lt;li&gt;an object of type &lt;code&gt;std::reference_wrapper&amp;lt; Arg1 &amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;or an object or type &lt;code&gt;*Arg1&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;As mentioned, the first case (i.e. object) is already written.  Let us tackle
the last two.&lt;/p&gt;

&lt;h4 id=&#34;std-reference-wrapper&#34;&gt;&lt;code&gt;std::reference_wrapper&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;To handle the second case (i.e. &lt;code&gt;std::reference_wrapper&lt;/code&gt;, one has to write a
template working on member pointers which will be selected only when the second
argument is a &lt;code&gt;std::reference_wrapper&lt;/code&gt; to an object of an appropriate type, and
SFINAE away otherwise.  Again, function template partial ordering is used to
distinguish between function call syntax and member pointer syntax.  The new
challenge is to find a way for the overload to be selected only when the
second argument&amp;rsquo;s type is a &lt;code&gt;std::reference_wrapper&lt;/code&gt;.  This kind of requirement
has been solved with &lt;code&gt;enable_if_t&lt;/code&gt; in the previous sections and the same
technique can be applied here: add a defaulted template parameter after the
parameter pack and default it to &lt;code&gt;enable_if_t&lt;/code&gt; with an appropriate predicate.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;template&amp;lt;
   typename MemPtr,
   typename Obj,
   typename Arg1,
   typename... Args,
   typename = enable_if_t&amp;lt; is_reference_wrapper&amp;lt; Arg1 &amp;gt;::value &amp;gt;,
   typename = enable_if_t&amp;lt; std::is_member_function_pointer&amp;lt; MemPtr Obj::* &amp;gt;::value &amp;gt;
&amp;gt;
auto invoke( MemPtr Obj::* invocable, Arg1 arg1, Args... args )
   -&amp;gt; decltype( (arg1.get().*invocable)( args... ) ) {
   return (arg1.get().*invocable)( args... );
}

template&amp;lt;
   typename MemPtr,
   typename Obj,
   typename Arg1,
   typename = enable_if_t&amp;lt; is_reference_wrapper&amp;lt; Arg1 &amp;gt;::value &amp;gt;
&amp;gt;
auto invoke( MemPtr Obj::* invocable, Arg1 arg1 )
   -&amp;gt; decltype( arg1.get().*invocable ) {
   return arg1.get().*invocable;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Unfortunately, there is no type trait in the standard library to determine if a
type is a &lt;code&gt;std::reference_wrapper&lt;/code&gt;.  Such a type trait can be written like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;template &amp;lt;class T&amp;gt;
struct is_reference_wrapper : std::false_type {};

template &amp;lt;class U&amp;gt;
struct is_reference_wrapper&amp;lt; std::reference_wrapper&amp;lt; U &amp;gt; &amp;gt; : std::true_type {};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;which would probably be put in a &lt;code&gt;detail&lt;/code&gt; namespace as this does not need to be
used by user code.  With this type trait and the definition above, the calls
where the invoked-on object type is &lt;code&gt;std::reference_wrapper&lt;/code&gt; work.&lt;/p&gt;

&lt;h4 id=&#34;pointer-to-object&#34;&gt;Pointer to object&lt;/h4&gt;

&lt;p&gt;One would think the last case is handled the same way simply by replacing the
type trait used in the &lt;code&gt;enable_if_t&lt;/code&gt; by the
&lt;a href=&#34;https://en.cppreference.com/w/cpp/types/is_pointer&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;std::is_pointer&lt;/code&gt;&lt;/a&gt;
type trait of the standard library, but in most implementations I have seen, it
is not the case.  I believe the reason is that testing with &lt;code&gt;std::is_pointer&lt;/code&gt;
will yield &lt;code&gt;false&lt;/code&gt; for smart pointers even if the invoked-on pointer syntax
should actually work for them.&lt;sup&gt;[5]&lt;/sup&gt;  One could test for every smart
pointer in the standard library inside the predicate of the &lt;code&gt;enable_if_t&lt;/code&gt;, but
that would needlessly prevent user defined smart pointers to be used, and the
standard library implementer (or the one implementing &lt;code&gt;invoke&lt;/code&gt;) cannot reliably
test for every user defined smart pointer.  Thus, the implementations usually
check that they are neither in the first nor in the second cases (i.e. neither
directly on an appropriately typed object nor on a &lt;code&gt;std::reference_wrapper&lt;/code&gt; to
one such object), and direct any other invoked-on object type to the last case.
This can be done once more using defaulted template parameters after the
parameter pack in combination with SFINAE, much like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;template&amp;lt;
   typename MemPtr,
   typename Obj,
   typename Arg1,
   typename... Args,
   typename = enable_if_t&amp;lt; !std::is_base_of&amp;lt; Obj, Arg1 &amp;gt;::value &amp;gt;,
   typename = enable_if_t&amp;lt; !is_reference_wrapper&amp;lt; Arg1 &amp;gt;::value &amp;gt;,
   typename = enable_if_t&amp;lt; std::is_member_function_pointer&amp;lt; MemPtr Obj::* &amp;gt;::value &amp;gt;
&amp;gt;
auto invoke( MemPtr Obj::* invocable, Arg1 arg1, Args... args )
   -&amp;gt; decltype( (*arg1.*invocable)( args... ) ) {
   return (*arg1.*invocable)( args... );
}

template&amp;lt;
   typename MemPtr,
   typename Obj,
   typename Arg1,
   typename = enable_if_t&amp;lt; !std::is_base_of&amp;lt; Obj, Arg1 &amp;gt;::value &amp;gt;,
   typename = enable_if_t&amp;lt; !is_reference_wrapper&amp;lt; Arg1 &amp;gt;::value &amp;gt;
&amp;gt;
auto invoke( MemPtr Obj::* invocable, Arg1 arg1 )
   -&amp;gt; decltype( *arg1.*invocable ) {
   return *arg1.*invocable;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;where the first condition of &lt;code&gt;!std::is_base_of&amp;lt; Obj, Arg1 &amp;gt;::value&lt;/code&gt; ensures this
is not the direct object case, and the second condition is the opposite of the
one used in the &lt;code&gt;std::reference_wrapper&lt;/code&gt; case (thus insuring it is not selected
in that case).&lt;/p&gt;

&lt;p&gt;This is the last of the syntaxes to cover, and so this is a working
implementation of &lt;code&gt;invoke&lt;/code&gt; which covers all cases mandated by the standard.
That said, some things can be made better.  If you are interested, read on.&lt;/p&gt;

&lt;h3 id=&#34;perfect-forwarding&#34;&gt;Perfect forwarding&lt;/h3&gt;

&lt;p&gt;In order to be more efficient and prevent argument copies, perfect forwarding
should be introduced into the mix.  To get perfect forwarding, one must use
&lt;del&gt;universal&lt;/del&gt;&lt;sup&gt;[6]&lt;/sup&gt; forwarding references, and use &lt;code&gt;std::forward&lt;/code&gt; on the
arguments inside the implementation.  In what follows, the function call syntax
and the member function pointer syntax are explored, both with a direct object
case.  All other cases (i.e. member object call syntax and other invoke-on
object types) can be modified to use perfect forwarding the same way, so in the
name of brevity, they are not explicitly covered here.&lt;/p&gt;

&lt;p&gt;Adding forwarding reference to the function argument list (i.e. &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;) and using
&lt;code&gt;std::forward&lt;/code&gt; in the implementation, the &lt;code&gt;invoke&lt;/code&gt; template for the two
situations covered can introduce perfect forwarding by being modified like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;template&amp;lt; typename Invocable, typename... Args &amp;gt;
auto invoke( Invocable&amp;amp;&amp;amp; invocable, Args&amp;amp;&amp;amp;... args )
   -&amp;gt; decltype(
         std::forward&amp;lt;Invocable&amp;gt;(invocable)( std::forward&amp;lt;Args&amp;gt;(args)... )
   )
{
   return std::forward&amp;lt;Invocable&amp;gt;(invocable)( std::forward&amp;lt;Args&amp;gt;(args)... );
}

template&amp;lt;
   typename MemPtr,
   typename Obj,
   typename Arg1,
   typename... Args,
   typename = enable_if_t&amp;lt; std::is_base_of&amp;lt; Obj, decay_t&amp;lt; Arg1 &amp;gt; &amp;gt;::value &amp;gt;,
   typename = enable_if_t&amp;lt; std::is_member_function_pointer&amp;lt; MemPtr Obj::* &amp;gt;::value &amp;gt;
&amp;gt;
auto invoke( MemPtr Obj::*&amp;amp;&amp;amp; invocable, Arg1&amp;amp;&amp;amp; arg1, Args&amp;amp;&amp;amp;... args )
   -&amp;gt; decltype(
         (std::forward&amp;lt; Arg1 &amp;gt;(arg1).*std::forward&amp;lt; MemPtr Obj::* &amp;gt;(invocable))
                                             ( std::forward&amp;lt; Args &amp;gt;(args)... )
   )
{
   return (std::forward&amp;lt; Arg1 &amp;gt;(arg1).*std::forward&amp;lt; MemPtr Obj::* &amp;gt;(invocable))
                                             ( std::forward&amp;lt; Args &amp;gt;(args)... );
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Honestly, the main difficulty becomes formatting and indentation: I find nothing
is satisfactory.  I should probably just let
&lt;a href=&#34;https://clang.llvm.org/docs/ClangFormat.html&#34; target=&#34;_blank&#34;&gt;ClangFormat&lt;/a&gt; do it for me.  In
any case, there are two things worth noticing.  The first is the position of
the &lt;code&gt;...&lt;/code&gt; when forwarding the parameter pack.  If you are familiar with calling
functions parameter packs, it is not surprising, but if you&amp;rsquo;ve never dealt with
this kind of things, it can trip you at first.  The second is the use of
&lt;code&gt;decay_t&lt;/code&gt;&lt;sup&gt;[4]&lt;/sup&gt; in the &lt;code&gt;std::is_base_of&lt;/code&gt; SFINAE condition in the second
overload.  This is now necessary because the type &lt;code&gt;Arg1&lt;/code&gt; can now be deduced to
be a reference and the predicate will be &lt;code&gt;false&lt;/code&gt; in that case if you do not
remove the reference modifier to the type.  Essentially:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;std::is_base_of&amp;lt; Arg1, Arg1&amp;amp;            &amp;gt;::value == false
std::is_base_of&amp;lt; Arg1, decay_t&amp;lt; Arg1&amp;amp; &amp;gt; &amp;gt;::value == true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Other than those two little difficulties, there is nothing very surprising about
the modifications to the original function if you are already familiar with
perfect forwarding.  If you are not, go read up on it (I have a
&lt;a href=&#34;https://ghlecl.github.io/posts/learning_rvalues/&#34; target=&#34;_blank&#34;&gt;past blog post&lt;/a&gt; about rvalues and perfect
forwarding).&lt;/p&gt;

&lt;h3 id=&#34;noexcept-specification&#34;&gt;noexcept specification&lt;/h3&gt;

&lt;p&gt;One final thing that I looked into is getting the &lt;code&gt;noexcept&lt;/code&gt; specifier correct
using the &lt;code&gt;noexcept&lt;/code&gt; operator.  Here is what it looks like for the same cases
perfect forwarding was explored with:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;template&amp;lt; typename Invocable, typename... Args &amp;gt;
auto invoke( Invocable&amp;amp;&amp;amp; invocable, Args&amp;amp;&amp;amp;... args )
   noexcept(
      noexcept(
         std::forward&amp;lt;Invocable&amp;gt;(invocable)( std::forward&amp;lt;Args&amp;gt;(args)... )
      )
   )
   -&amp;gt; decltype(
         std::forward&amp;lt;Invocable&amp;gt;(invocable)( std::forward&amp;lt;Args&amp;gt;(args)... )
   )
{
   return std::forward&amp;lt;Invocable&amp;gt;(invocable)( std::forward&amp;lt;Args&amp;gt;(args)... );
}

template&amp;lt;
   typename MemPtr,
   typename Obj,
   typename Arg1,
   typename... Args,
   typename = enable_if_t&amp;lt; std::is_base_of&amp;lt; Obj, decay_t&amp;lt;Arg1&amp;gt; &amp;gt;::value &amp;gt;,
   typename = enable_if_t&amp;lt; std::is_member_function_pointer&amp;lt; MemPtr Obj::* &amp;gt;::value &amp;gt;
&amp;gt;
auto invoke( MemPtr Obj::*&amp;amp;&amp;amp; invocable, Arg1&amp;amp;&amp;amp; arg1, Args&amp;amp;&amp;amp;... args )
   noexcept(
      noexcept(
         (std::forward&amp;lt; Arg1 &amp;gt;(arg1).*std::forward&amp;lt; MemPtr Obj::* &amp;gt;(invocable))
                                             ( std::forward&amp;lt; Args &amp;gt;(args)... )
      )
   )
   -&amp;gt; decltype(
         (std::forward&amp;lt; Arg1 &amp;gt;(arg1).*std::forward&amp;lt; MemPtr Obj::* &amp;gt;(invocable))
                                             ( std::forward&amp;lt; Args &amp;gt;(args)... )
   )
{
   return (std::forward&amp;lt; Arg1 &amp;gt;(arg1).*std::forward&amp;lt; MemPtr Obj::* &amp;gt;(invocable))
                                             ( std::forward&amp;lt; Args &amp;gt;(args)... );
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and now the indentation is really screwed up.  Another annoying thing that the
reader might notice is that you basically have to write the implementation of
the function thrice (see &lt;a href=&#34;https://twitter.com/supahvee1234&#34; target=&#34;_blank&#34;&gt;Vittorio Romeo&lt;/a&gt;&amp;rsquo;s
&lt;a href=&#34;https://www.youtube.com/watch?v=I3T4lePH-yA&#34; target=&#34;_blank&#34;&gt;lightning talk about that&lt;/a&gt;).
Not all that DRY, but hey!&lt;/p&gt;

&lt;h2 id=&#34;beyond-std-invoke&#34;&gt;Beyond &lt;code&gt;std::invoke&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;I am sure there are other things that could be improved in this implementation
of &lt;code&gt;invoke&lt;/code&gt;.  For instance, from Vittorio&amp;rsquo;s talk, I realized that my
implementation is not &lt;code&gt;constexpr&lt;/code&gt; friendly.  That said, while it might not be a
conforming implementation, it is a working one, and it is a more general version
of the &lt;code&gt;apply_on&lt;/code&gt; template in my motivating use case (which, as I said, was
&lt;em&gt;vaguely&lt;/em&gt; related).  Writing this implementation made me learn a lot.&lt;/p&gt;

&lt;p&gt;Generic function calling in C++ is a large subject where inspiration could come
from other languages as well.  For instance, at C++Now 2018,
&lt;a href=&#34;https://twitter.com/CppSage&#34; target=&#34;_blank&#34;&gt;Matt Calabrese&lt;/a&gt; presented a library
(&lt;a href=&#34;https://www.youtube.com/watch?v=pKVCB_Bzalk&#34; target=&#34;_blank&#34;&gt;Argot&lt;/a&gt;) he is working on
which seeks to provide better language ergonomics for invoking &lt;em&gt;things&lt;/em&gt;, any
&lt;em&gt;callable&lt;/em&gt;.  Already, in 2016, he was making a &lt;a href=&#34;http://open-std.org/JTC1/SC22/WG21/docs/papers/2016/p0376r0.html&#34; target=&#34;_blank&#34;&gt;proposal&lt;/a&gt;
to the standards committee about unifying &lt;code&gt;std::invoke&lt;/code&gt;, &lt;code&gt;std::apply&lt;/code&gt;, and
&lt;code&gt;std::visit&lt;/code&gt;, and then 2017, again at C++ Now, he was giving a talk about the
beginnings of a similar library (if not the same library) called &lt;a href=&#34;https://www.youtube.com/watch?v=Fjw7NjndQ50&amp;amp;list=PLTXJhw4sOAviW1OdRgPlxU5m5GU2UzJiJ&#34; target=&#34;_blank&#34;&gt;Call&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;In this work, he not only explores how to provide a more uniform way to invoke
things, but he also explores, amongst other things, argument unpacking from
tuples much like in Python.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Python&#34;&gt;# Function taking 4 arguments and printing them
def fn(a, b, c, d):
   print( a, b, c, d )
 

my_list = [ 1, 2, 3, 4 ] 
# Unpacking list into four arguments
fn( *my_list )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;From his 2018 C++ Now talk, I gather he is not ready to submit such an addition
to the language and/or the standard library at this point, but I find his ideas
interesting and will try to stay informed (although I am far from that level of
C++).&lt;/p&gt;

&lt;p&gt;Anyhow, I hope this post was of some interest.  As Jon Kalb would say:
safe coding!&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;acknowledgments&#34;&gt;Acknowledgments&lt;/h2&gt;

&lt;p&gt;I would like to thank &lt;a href=&#34;https://twitter.com/sephdebusser&#34; target=&#34;_blank&#34;&gt;Seph De Busser&lt;/a&gt;
for taking the time to read this post before I published it and reassuring me
that the mistakes in there were not too bad.  ðŸ™‚&lt;/p&gt;

&lt;h2 id=&#34;notes&#34;&gt;Notes&lt;/h2&gt;

&lt;p&gt;&lt;sup&gt;[1]&lt;/sup&gt; I think &lt;code&gt;INVOKE&lt;/code&gt; is not strictly the same as &lt;code&gt;std::invoke&lt;/code&gt;, although
I find this confusing.  As far as I can tell, &lt;code&gt;INVOKE&lt;/code&gt; was in the standard before
&lt;code&gt;std::invoke&lt;/code&gt; and represents the idea of calling something.  &lt;code&gt;std::invoke&lt;/code&gt; is
just the library implementation of this idea.  I could not find an appropriate
name for such an entity.&lt;/p&gt;

&lt;p&gt;&lt;sup&gt;[2]&lt;/sup&gt; For SFINAE, it would be easy to add a third defaulted template
parameter after the parameter pack in the original definition of the previous
section.  Something like:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;template&amp;lt;
   typename Invocable,
   typename... Args,
   typename = enable_if_t&amp;lt; !std::is_member_pointer&amp;lt; decay_t&amp;lt; Invocable &amp;gt; &amp;gt;::value &amp;gt;
&amp;gt;
auto invoke( Invocable invocable, Args... args )
   -&amp;gt; decltype( invocable( args... ) ) {
   return invocable( args... );
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I would have put it in this overload instead of putting the opposite
verification in every other overload.  If you are wondering why the &lt;code&gt;decay_t&lt;/code&gt; is
used, see the main text.&lt;/p&gt;

&lt;p&gt;&lt;sup&gt;[3]&lt;/sup&gt; In the following function template declaration:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;template&amp;lt; typename MemPtr, typename Obj, typename Arg1, typename... Args &amp;gt;
auto invoke( MemPtr Obj::* invocable, Arg1 arg1, Args... args );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;the type the pointer points into (&lt;code&gt;Obj&lt;/code&gt;) and the type of the object
the pointer will be invoked on (&lt;code&gt;Arg1&lt;/code&gt;) are not necessarily the same, since a
derived object could be used with &lt;code&gt;invoke&lt;/code&gt;.  Thus, they must be different
template parameters to allow the compiler to deduce different types.&lt;/p&gt;

&lt;p&gt;&lt;sup&gt;[4]&lt;/sup&gt; One might have noticed that I said I was limiting myself to
C++11, but I use the C++14 &lt;code&gt;enable_if_t&lt;/code&gt; and &lt;code&gt;decay_t&lt;/code&gt; helpers of
&lt;code&gt;std::enable_if&lt;/code&gt; and &lt;code&gt;std::decay&lt;/code&gt;.  Those helpers are so useful that I usually
define and use them even in C++11.  The &lt;code&gt;_v&lt;/code&gt; helpers cannot be defined in
C++11, but the &lt;code&gt;_t&lt;/code&gt; helpers work perfectly.  The two of interest in this code
can be defined like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;template&amp;lt; bool B, typename T = void &amp;gt;
using enable_if_t = typename std::enable_if&amp;lt; B, T &amp;gt;::type;

template&amp;lt; typename T &amp;gt;
using decay_t = typename std::decay_t&amp;lt; T &amp;gt;::type;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;sup&gt;[5]&lt;/sup&gt; Provided you use the right semantics, e.g. you &lt;code&gt;std::move&lt;/code&gt; the
&lt;code&gt;std::unique_ptr&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;sup&gt;[6]&lt;/sup&gt; I still prefer the previous term&amp;hellip; sigh.&lt;/p&gt;
</description>
      </item>
      
    
      
      <item>
        <title>Python&#39;s range in C&#43;&#43;</title>
        <link>https://ghlecl.github.io/posts/range_function/</link>
        <pubDate>Sun, 05 Aug 2018 00:00:00 +0000</pubDate>
        <author>codeattempts@gmail.com - Ghyslain Leclerc</author>
        <guid>https://ghlecl.github.io/posts/range_function/</guid>
        <description>

&lt;h1 id=&#34;exploring-loops-python-s-range-in-c&#34;&gt;Exploring loops: Python&amp;rsquo;s range in C++&lt;/h1&gt;

&lt;p&gt;In spite of what Sean Parent would like (i.e. &lt;a href=&#34;https://channel9.msdn.com/Events/GoingNative/2013/Cpp-Seasoning&#34; target=&#34;_blank&#34;&gt;no raw loops&lt;/a&gt; ;-) ), loops
are a common control flow in programming.  So common that most languages have
more than one &lt;a href=&#34;https://en.wikipedia.org/wiki/Control_flow#Loops&#34; target=&#34;_blank&#34;&gt;loop&lt;/a&gt; syntax:
&lt;a href=&#34;https://en.wikipedia.org/wiki/For_loop&#34; target=&#34;_blank&#34;&gt;for loop&lt;/a&gt;,
&lt;a href=&#34;https://en.wikipedia.org/wiki/While_loop&#34; target=&#34;_blank&#34;&gt;while loop&lt;/a&gt;,
&lt;a href=&#34;https://en.wikipedia.org/wiki/Do_while_loop&#34; target=&#34;_blank&#34;&gt;do while loop&lt;/a&gt;&amp;hellip;  Given their
prevalence, loops might seem uninteresting, but when I decided to look into
creating a &lt;code&gt;range&lt;/code&gt; function&lt;sup&gt;[1]&lt;/sup&gt; for C++ which would behave like Python&amp;rsquo;s
&lt;code&gt;range&lt;/code&gt; object, I learned a thing or two and decided to write them down.&lt;/p&gt;

&lt;p&gt;For the impatient, the code I came up with is available on
&lt;a href=&#34;https://github.com/ghlecl/range_fn&#34; target=&#34;_blank&#34;&gt;Github&lt;/a&gt;.  It was inspired by
&lt;a href=&#34;https://www.justsoftwaresolutions.co.uk/cplusplus/
generating_sequences.html&#34; target=&#34;_blank&#34;&gt;Anthony William&amp;rsquo;s post&lt;/a&gt; on the subject.  I will put the same disclaimer here
that Anthony put in his post:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&amp;hellip;hopefully people will find this instructive, if not useful.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;As he points out, there are more complete alternatives (e.g. the
&lt;a href=&#34;https://www.boost.org/doc/libs/1_67_0/libs/range/doc/html/index.html&#34; target=&#34;_blank&#34;&gt;Boost range library&lt;/a&gt;)
with a probably higher quality of implementation (at the price of bringing the
whole of Boost into your project if you do not already depend on it).&lt;sup&gt;[2]&lt;/sup&gt;&lt;/p&gt;

&lt;p&gt;This turned out to be quite a longer blog entry than I anticipated.  Consider
yourself warned!&lt;/p&gt;

&lt;h2 id=&#34;iterating-over-containers&#34;&gt;Iterating over containers&lt;/h2&gt;

&lt;p&gt;Out of the C++11 (and beyond) features, &lt;a href=&#34;http://en.cppreference.com/w/cpp/language/range-for&#34; target=&#34;_blank&#34;&gt;range-based for loop&lt;/a&gt; is a favorite of mine.
Prior to that being available, if you wanted to iterate over every element of a
container, the alternatives were rather verbose.  Amongst others, there is the
C style for loop using the &lt;a href=&#34;http://en.cppreference.com/w/cpp/iterator&#34; target=&#34;_blank&#34;&gt;iterators&lt;/a&gt;
that can be retrieved by the &lt;code&gt;begin()&lt;/code&gt; and &lt;code&gt;end()&lt;/code&gt; functions of the STL
containers:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;std::list&amp;lt;double&amp;gt; lst;  // ... fill list somehow ...

typedef std::list&amp;lt;double&amp;gt;::iterator lst_iter;
for( lst_iter beg = lst.begin(), end = lst.end(); beg != end; ++beg ) {
   double cur = *beg;
   // use cur (or use *beg directly everywhere)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;or the &lt;a href=&#34;http://en.cppreference.com/w/cpp/algorithm/for_each&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;for_each&lt;/code&gt;&lt;/a&gt;
algorithm to which one provides a function object to apply to every element of
the container:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;std::list&amp;lt;double&amp;gt; lst;  // ... fill list somehow ...

struct my_op {
   void operator()( double item ) {
      // use item
   }
};
std::for_each( lst.begin(), lst.end(), my_op() );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Those work, but they have a few drawbacks, amongst which you can find being
verbose &lt;del&gt;and 2) not working with built-in arrays&lt;/del&gt;&lt;sup&gt;[3]&lt;/sup&gt;.
Compare that to other languages where the syntax for iterating over a container
is more concise and more universally applied, like Python for instance:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;a = [ 0, 1, 2, 3, 4 ]
for x in a:
   #use x
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and you can see a difference, at a minimum in verbosity.  With range-based for
loops, C++ closes the gap.  The syntax, introduced in C++11, is terser and works
with both containers and built-in arrays (which is what I show in the example
below).  Here is what it looks like, which is much closer to the Python for
loop:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int ints[] = { 0, 1, 2, 3, 4 };
for( int x : ints ) {
   // use x
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;On top of the afore mentioned properties, and probably even more importantly,
this construct is much more expressive: it clearly says that you want to use
every element of the container.  C++ being what it is, of course, the syntax
gives you more control than in Python (at the expense of more complexity some
would argue): you can specify if you want a copy of each object in the container,
a reference to them, or a const reference to them.  Thus, all the following
declarations (iterating over the same range as the previous example) would be
valid:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;for( int x : lst ) { /* body */ }        // copy
for( int&amp;amp; x : lst ) { /* body */ }       // reference
for( int const&amp;amp; x : lst ) { /* body */ } // const reference
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That is to say that in C++, you can express that you want to iterate over all
the items &lt;em&gt;and&lt;/em&gt; whether you intend to modify them or not.&lt;/p&gt;

&lt;p&gt;One condition to keep in mind is that in the constructs above, the loop variable
type (&lt;code&gt;int&lt;/code&gt; in the example above) must be initializable from the type in the
container/array you want to iterate over.  This can lead to some errors:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int ints[] = { 0, 1, 2, 3, 4 };
for( long x : ints ) {
   // OK, a long can be initialized from an int
}
for( long&amp;amp; x : ints ) {
   // Won&#39;t compile: long&amp;amp; can&#39;t be &amp;quot;initialized from&amp;quot;/&amp;quot;bind to&amp;quot; an int
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That said, unless you really need to specify the type, it is usually recommended
that you use
&lt;a href=&#34;http://en.cppreference.com/w/cpp/language/auto&#34; target=&#34;_blank&#34;&gt;C++11&amp;rsquo;s auto specifier&lt;/a&gt; to
get type deduction on the loop variable.  That would look like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int ints[] = { 0, 1, 2, 3, 4 };
for( auto x : ints ) {
   // use x
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;which eschews the problems of type mismatch mentioned above.  Even with this
type deduction, the type decoration can be used so that all those syntaxes are
correct and should (usually) have the expected behavior:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;for( auto x : lst ) { /* body */ }        // copy
for( auto&amp;amp; x : lst ) { /* body */ }       // reference
for( auto const&amp;amp; x : lst ) { /* body */ } // const reference
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;which can have the advantage that if you change the type in the container, you do
not have to change the type in the loop.  There are some more caveats, especially
related to lifetime of temporary objects and accessibility, but the information
here is enough in most cases.  If you want more information on type deduction in
range-based for loops, see &lt;a href=&#34;https://blog.petrzemek.net/2016/08/17/auto-type-deduction-in-range-based-for-loops/&#34; target=&#34;_blank&#34;&gt;this article&lt;/a&gt;
by Petr Zemek.&lt;/p&gt;

&lt;p&gt;One limitation of the C++ syntax compared to Python&amp;rsquo;s is that there is no way to
limit the iteration to a sub-range of the container.  For this, you still need
to use the previous constructs.  C++11 made it easier to use these constructs
with &lt;a href=&#34;http://en.cppreference.com/w/cpp/language/auto&#34; target=&#34;_blank&#34;&gt;auto type deduction&lt;/a&gt;, but
allowing iteration over a portion of the container is still missed, if you ask
me, because if it were available, it would mean the same syntax could be used for
any iteration over a container.  In future versions of the standard, ranges
(which are a completely different concept from the function I am writing in what
follows&amp;hellip; naming things is hard) or view/span types might provide a better
alternative, but for now nothing is provided in the standard to iterate over a
subrange.&lt;/p&gt;

&lt;h2 id=&#34;iterating-over-indices&#34;&gt;Iterating over indices&lt;/h2&gt;

&lt;p&gt;Containers (unfortunately or not, depending who you ask), are not the only thing
we need to loop over.  Iterating over indices can be necessary, and for that,
Python has an easy way of creating a temporary &amp;ldquo;container&amp;rdquo; that will represent a
range of integers.  Using this container, the same syntax that was used to iterate
over lists can easily be applied to index iteration:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;a = [ 0, 1, 2, 3, 4 ]
for x in a:
   # use x

for x in range( 5 ):
   # use x
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As mentioned, the &lt;a href=&#34;https://docs.python.org/3/library/stdtypes.html?highlight=range#range&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;range&lt;/code&gt;&lt;/a&gt; object
created using this syntax will generate the sequence of integers for the loop.
This object can be initialized with a single &lt;code&gt;stop&lt;/code&gt; value (as shown), but can
also be declared with a &lt;code&gt;start&lt;/code&gt;/&lt;code&gt;stop&lt;/code&gt; pair or a &lt;code&gt;start&lt;/code&gt;/&lt;code&gt;stop&lt;/code&gt;/&lt;code&gt;step&lt;/code&gt; triplet.
It will go from &lt;code&gt;start&lt;/code&gt; to &lt;code&gt;stop&lt;/code&gt; (with &lt;code&gt;stop&lt;/code&gt; being exclusive, i.e. the interval
is&lt;code&gt;[start, stop[&lt;/code&gt;) in steps of &lt;code&gt;step&lt;/code&gt;.  The default value of &lt;code&gt;start&lt;/code&gt;
is zero and the default value of &lt;code&gt;step&lt;/code&gt; is one, which is why you can use the
variations with a single parameter or a &lt;code&gt;start&lt;/code&gt;/&lt;code&gt;stop&lt;/code&gt; pair (which are not
strictly speaking overloads, since Python does not allow that).  The parameter
&lt;code&gt;step&lt;/code&gt; can be negative.  The &lt;code&gt;start&lt;/code&gt; value must be smaller than &lt;code&gt;stop&lt;/code&gt; when
&lt;code&gt;step&lt;/code&gt; is positive and greater than &lt;code&gt;stop&lt;/code&gt; when &lt;code&gt;step&lt;/code&gt; is negative.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;range( 10 )          // iterates from 0 to 9
range( 8, 32 )       // iterates from 8 to 31
range( 10, 5, -2 )   // iterates from 10 to 5 in steps of 2
range( 10, 5, 2 )    // does nothing
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In C++, neither the language nor its standard library provides such a facility.
Thus, to iterate over numbers, one falls back to the C style for loop:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int ints[] = { 0, 1, 2, 3, 4 };
for( auto x : ints ) {
   // use x
}

for( int x{0}; x &amp;lt; 5; ++x ) {
   // use x
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is not actually so bad, but I like the consistency and expressiveness of
Python&amp;rsquo;s &lt;code&gt;range&lt;/code&gt; object.  In the end, although those reasons might not be the
strongest arguments, they still drove me to think about (over-engineer maybe ;-) )
a construct similar to Python&amp;rsquo;s range in C++.  Admittedly, I was also simply a
bit curious.  So, I set out to try and see if I could make a function or an
object which could work with the range-based for loop much like Python&amp;rsquo;s &lt;code&gt;range&lt;/code&gt;
object.&lt;/p&gt;

&lt;h2 id=&#34;the-initial-design-goals&#34;&gt;The initial &amp;ldquo;design goals&amp;rdquo;&lt;/h2&gt;

&lt;p&gt;Initially, I really wanted the behavior of Python&amp;rsquo;s &lt;code&gt;range&lt;/code&gt; object.  I did not
want to have to specify the type to iterate over (i.e. &lt;code&gt;short&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;long&lt;/code&gt;,
&lt;code&gt;unsigned&lt;/code&gt;&amp;hellip;).  I wanted to be able to go in both directions, i.e. increment
or decrement the counter.  I wanted to be able to specify the step size.
Basically, I wanted to be able to write loops over indices like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;for( auto idx : range( 6 ) ) { /* body */ }
for( auto idx : range( 2, 7 ) ) { /* body */ }
for( auto idx : range( 38, 13, -3 ) ) { /* body */ }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I also wanted it to be as close to the raw C style loop efficiency as possible,
or the same even.  If there were a large performance penalty, this would probably
be a show stopper: C++&amp;rsquo;s &amp;ldquo;&lt;em&gt;zero-cost abstractions&lt;/em&gt;&amp;rdquo; mantra.  Actually, I would
argue that usually, in C++, even in non performance critical code, a cost in
performance has to be greatly outweighed by a gain in expressiveness for a
feature/proposal to even be considered, for better or worse.&lt;/p&gt;

&lt;p&gt;So, with the following short list of goals:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Python &lt;code&gt;range&lt;/code&gt; behavior,

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;start&lt;/code&gt; / &lt;code&gt;stop&lt;/code&gt; / &lt;code&gt;step&lt;/code&gt;,&lt;/li&gt;
&lt;li&gt;increment/decrement,&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;no explicit type specification,&lt;/li&gt;
&lt;li&gt;no runtime overhead,&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I set out to build a function (or object) in C++.  In order to do that, I first
had to understand the range-based for loop&lt;sup&gt;[4]&lt;/sup&gt;.&lt;/p&gt;

&lt;h2 id=&#34;writing-the-code&#34;&gt;Writing the code&lt;/h2&gt;

&lt;h3 id=&#34;understanding-range-based-for&#34;&gt;Understanding range-based for&lt;/h3&gt;

&lt;p&gt;As defined by the C++17 standard in section&amp;nbsp;&lt;strong&gt;9.5.4&amp;nbsp;The range-based
for statement ([&lt;em&gt;stmt.ranged&lt;/em&gt;])&lt;/strong&gt;, there are three main components to the
range-based for construct:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;a range declaration,&lt;/li&gt;
&lt;li&gt;a range initializer,&lt;/li&gt;
&lt;li&gt;a loop statement.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;At its simplest, this is expressed like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;for( for_range_declaration : for_range_initializer ) {
   loop_statement
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;for_range_declaration&lt;/code&gt; serves to create the variable that will be used in
the loop.  The &lt;code&gt;for_range_initializer&lt;/code&gt; is what is executed to get the range (can
be as simple as what I would call &amp;ldquo;identity&amp;rdquo;, i.e. a range can directly be passed
in).  The &lt;code&gt;loop_statement&lt;/code&gt; is essentially the body of the for loop as with any C
style for loop.  The code above will be used by the compiler to generate
something similar to the regular iterator loop shown in the
&lt;a href=&#34;#iterating-over-containers&#34; target=&#34;_blank&#34;&gt;first section&lt;/a&gt;.  The code looks like
this&lt;sup&gt;[5]&lt;/sup&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;auto&amp;amp;&amp;amp; rng = for_range_initializer;
auto beg = begin( rng );
auto end = end( rng );
for( ; beg != end; beg++ ) {
   for_range_declaration = *beg;
   loop_statement
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;where the &lt;code&gt;begin&lt;/code&gt; and &lt;code&gt;end&lt;/code&gt; functions are not necessarily free functions, and
can be the equivalent member functions of most STL containers.  Actually, if
either a &lt;code&gt;begin&lt;/code&gt; or an &lt;code&gt;end&lt;/code&gt; member function are found in the range object, the
pair of member functions is preferred as specified in the standard.  This
unfortunately means that if an unrelated function exists in the class, but has
one of those names, the class cannot be used in the range-based for statement
even if an appropriate free functions pair is provided. This is true regardless
of the access specifier of the function (i.e. a private function with such a
name will still prevent the range-based for, even if a valid, non member pair of
&lt;code&gt;begin&lt;/code&gt;/&lt;code&gt;end&lt;/code&gt; functions exists).  I believe this might be changed in the future,
but for the C++11 to C++17 versions of the standard, range based for is defined
this way.&lt;/p&gt;

&lt;p&gt;With the definition above in mind, the requirements to use a range-based for loop
can then be summarized as having two related types: first, a range like type that
has both a &lt;code&gt;begin&lt;/code&gt; and an &lt;code&gt;end&lt;/code&gt; function (either member, or discoverable through
ADL, i.e. in a related namespace) and second, an iterator like type which can be
compared for inequality, incremented and dereferenced, i.e. implements the
&lt;code&gt;operator!=&lt;/code&gt;, &lt;code&gt;operator++&lt;/code&gt;, and &lt;code&gt;operator*&lt;/code&gt; functions.  The &lt;code&gt;begin&lt;/code&gt; and &lt;code&gt;end&lt;/code&gt;
functions of the range like type must return objects of the iterator type.  If
those criteria are met, then the range-based for loop construct is usable with
the range like type.  The requirements can be summed up in code like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;struct range_iterator {
   range_iterator operator++();
   bool operator!=( range_iterator const&amp;amp; other );
   range_value_type operator*();
}

struct range {
   range_iterator begin();
   range_iterator end();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;where &lt;code&gt;range_value_type&lt;/code&gt; is the type of the data pointed to by the iterator and
contained in the range to iterate over.  Implementing those two types should be
enough and so that is what I set out to do.&lt;/p&gt;

&lt;h3 id=&#34;thinking-of-a-design&#34;&gt;Thinking of a design&lt;/h3&gt;

&lt;p&gt;I first looked at Anthony William&amp;rsquo;s code to see how it could be done.  I suggest
you take a look at the code (&lt;a href=&#34;https://www.justsoftwaresolutions.co.uk/files/numeric_range.cpp&#34; target=&#34;_blank&#34;&gt;download link&lt;/a&gt;) to see the
approach he has taken.  I wanted to try and make my own implementation, taking a
different path. In my first attempt, I ended up having to write multiple versions
of some of the classes in order to customize the behavior for various types.
For instance, comparing floats with &lt;code&gt;operator==&lt;/code&gt; is hardly ever what you want
(because of floating point errors), but doing so works perfectly with integral
types. Even with templates, I did not arrive at a customizable design that
satisfied me.  Having to repeat myself was not so bad, but I wanted to see if I
could avoid breaking the DRY principle.  As I said, a good dose of curiosity. :-)&lt;/p&gt;

&lt;p&gt;So I needed to change the behavior depending on what type I iterate over.  There
are a few alternatives to achieve such behavior in C++.  I wanted an alternative
that would be compile time based with no runtime overhead.  I felt it was
necessary to get the efficiency I was aiming for.  This meant and abstract base
class with virtual functions was not in my solution set.  I decided to explore
solutions which allowed me to specify the behavior of the class: some kind of
&amp;ldquo;functionality injection&amp;rdquo;.  At first, I though of using &lt;a href=&#34;http://en.cppreference.com/w/cpp/utility/functional/function&#34; target=&#34;_blank&#34;&gt;std::function&lt;/a&gt; to
hold the &amp;ldquo;pointers&amp;rdquo; to the functions to call.  That way, I could specify what to
use for the three iterator operators when constructing them.  The downside of
this, from my perspective, is that this will introduce type erasure (and
possibly/usually accompanying heap allocations) and indirection, which, if I
understand properly, is harder or impossible to optimize for the compiler.  I
was worried this would not give me the performance I wanted.  In thinking and
searching for alternatives, I remembered &lt;a href=&#34;https://www.fluentcpp.com/2017/05/23/strong-types-inheriting-functionalities-from
-underlying/&#34; target=&#34;_blank&#34;&gt;this&lt;/a&gt; blog post on inheriting functionalities.  This made me think the
same technique applied in the blog post &lt;a href=&#34;https://en.wikipedia.org/wiki/Curiously_recurring_template_pattern&#34; target=&#34;_blank&#34;&gt;CRTP&lt;/a&gt; might be the
solution I was looking for (did I mention over-engineering?).&lt;/p&gt;

&lt;h3 id=&#34;writing-some-code&#34;&gt;Writing some code&lt;/h3&gt;

&lt;p&gt;Essentially, there are three functionalities that the iterator has to have and so
I created three new types that the iterator would inherit from to &amp;ldquo;consume&amp;rdquo; the
functionality.  Applying the CRTP pattern, I parametrized those new types so that
they would take the iterator class as a template parameter, and I made the
iterator class derive from those types.  The implementation ended up as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;enum class Direction : uint_fast8_t {
   ascending,
   descending
};
constexpr auto Ascending = Direction::ascending;
constexpr auto Descending = Direction::descending;

template&amp;lt; typename Iterator, typename Reference &amp;gt;
struct Dereference
{
   auto operator*() -&amp;gt; Reference {
      return static_cast&amp;lt;Iterator&amp;amp;&amp;gt;(*this).cur_val_;
   }
};

template&amp;lt; typename Iterator &amp;gt;
struct Increment
{
   auto operator++() -&amp;gt; Iterator&amp;amp; {
      auto&amp;amp; self = static_cast&amp;lt;Iterator&amp;amp;&amp;gt;(*this);
      ( self.direction_ == Ascending ) ? ++(self.cur_val_): --(self.cur_val_);
      return static_cast&amp;lt;Iterator&amp;amp;&amp;gt;(*this);
   }
};

template&amp;lt; typename Iterator &amp;gt;
struct EqualityComparisons
{
   bool operator==( Iterator const&amp;amp; rhs ) const {
      return static_cast&amp;lt;Iterator const&amp;amp;&amp;gt;(*this).cur_val_ == rhs.cur_val_;
   }
   bool operator!=( Iterator const&amp;amp; rhs ) const {
      return !(*this == rhs);
   }
};


template&amp;lt; typename T &amp;gt;
struct range_iterator :
      Dereference&amp;lt; range_iterator&amp;lt;T&amp;gt;, T&amp;amp; &amp;gt;,
      Increment&amp;lt; range_iterator&amp;lt;T&amp;gt; &amp;gt;,
      EqualityComparisons&amp;lt; range_iterator&amp;lt;T&amp;gt; &amp;gt;
{
   using value_type = T;
   using reference = T&amp;amp;;
   using iterator_category = std::input_iterator_tag;
   using pointer = T*;
   using difference_type = void;

   range_iterator( T val, Direction dir ) :
                  direction_{ dir }, cur_val_{ val } {
   }
private:
   Direction direction_;
   T cur_val_;

   friend Dereference&amp;lt; range_iterator&amp;lt;T&amp;gt;, T&amp;amp; &amp;gt;;
   friend Increment&amp;lt; range_iterator&amp;lt;T&amp;gt; &amp;gt;;
   friend EqualityComparisons&amp;lt; range_iterator&amp;lt;T&amp;gt; &amp;gt;;
};


template&amp;lt; typename Iterator &amp;gt;
struct Range
{
   private:
      using value_type = typename Iterator::value_type;
   public:
      Range( value_type start, value_type stop ) :
         direction_{ (start &amp;lt; stop) ? Ascending : Descending },
                                          cur_val_{ start }, end_{ stop } {
      }
      auto begin() -&amp;gt; Iterator {
         return Iterator{ cur_val_, direction_ };
      }
      auto end() -&amp;gt; Iterator {
         return Iterator{ end_, direction_ };
      }

   private:
      Direction direction_;
      value_type cur_val_;
      value_type end_;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A few things worth mentioning.  I have had to make the &amp;ldquo;operation&amp;rdquo; classes friends
of the iterator class to give them access to the iterator private data.  If I
were designing something for the purpose of having client code specialize and
extend the behavior, this break in encapsulation might be more of a concern and
I might have to go for a different design, since the friend route seems to be the
&lt;a href=&#34;https://stackoverflow.com/questions/8523762/crtp-with-protected-derived-member?rq=1&#34; target=&#34;_blank&#34;&gt;only viable alternative&lt;/a&gt;
to give the base class access to the derived class data.  But for my current use,
it is not something I am worried with.  I also had to explicitly specify the
reference type in the &lt;code&gt;Dereference&lt;/code&gt; operation.  This is because at the
instantiation time of the &lt;code&gt;Dereference&lt;/code&gt; template in the inheritance list of the
&lt;code&gt;range_iterator&lt;/code&gt;, the latter is still an incomplete type and so its &lt;code&gt;typedef&lt;/code&gt;s
cannot be used.  Also, for brevity in this blog post, everything is in the global
namespace, which is not at all good practice, but in the actual code, I put
everything in a &lt;code&gt;estd&lt;/code&gt; namespace (for &lt;strong&gt;e&lt;/strong&gt;xtended &lt;strong&gt;std&lt;/strong&gt;).  The indentation is
also slightly modified for the purpose of the blog post.&lt;/p&gt;

&lt;p&gt;In any case, with this code (and the appropriate &lt;code&gt;#include&lt;/code&gt;s, again omitted for
space), one can iterate over numbers using a range-based for loop like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;for( auto idx : Range&amp;lt; range_iterator&amp;lt;int&amp;gt; &amp;gt;( 0, 8 ) ) {
   // use idx
}

for( auto idx : Range&amp;lt; range_iterator&amp;lt;int&amp;gt; &amp;gt;( 7, -1 ) ) {
   // use idx
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Verbose, shows implementation details, but a start.  This is the beginning of
the interface I set out to have.  It allows specifying &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;stop&lt;/code&gt; (but
not the &lt;code&gt;step&lt;/code&gt; yet).  It still requires an explicit type specification, which I
would like to get rid of.  It will detect whether you want to go in the
increasing of decreasing direction, so increment and decrement are covered.
Some might argue the detection is undesired behavior (Python&amp;rsquo;s &lt;code&gt;range&lt;/code&gt; will not
do this and a &lt;code&gt;step&lt;/code&gt; of&amp;nbsp;-1 must be explicitly specified to decrement).  It
is debatable I guess, but this is the interface I went with.&lt;/p&gt;

&lt;p&gt;As it stands, in the code above, the implementation will accept floating point
types and character types.  This is not allowed by Python&amp;rsquo;s &lt;code&gt;range&lt;/code&gt; object
(although using the &lt;a href=&#34;http://www.numpy.org/&#34; target=&#34;_blank&#34;&gt;Numpy&lt;/a&gt; &lt;a href=&#34;https://docs.scipy.org/doc/numpy/reference/generated/numpy.linspace.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;linspace&lt;/code&gt;&lt;/a&gt;
function, one can get a floating point range).  Unfortunately, the current
implementation of the comparison operator is defined in terms of the underlying
type&amp;rsquo;s &lt;code&gt;operator==&lt;/code&gt;.  As previously mentioned, comparing floats using this
operator is not ideal (and might actually never be true in some cases, which
would create an infinite loop).  This has been one of the first reasons I have
had for specializing in my earlier designs (which are not presented here), and
so I will explore it soon, but before I get to that, I will look at performance
to see if my design is good enough for me to pursue further.&lt;/p&gt;

&lt;h3 id=&#34;evaluating-the-performance-i&#34;&gt;Evaluating the performance I&lt;/h3&gt;

&lt;p&gt;Instead of benchmarking the code in the traditional sense of measuring execution
time (&lt;a href=&#34;https://www.youtube.com/watch?v=zWxSZcpeS8Q&#34; target=&#34;_blank&#34;&gt;which is complicated&lt;/a&gt;), I
decided to look at the assembly generated in Code Explorer (i.e. I godbolted my
code !) and see if there was any difference between this looping construct and a
traditional C style for loop.  My hypothesis is that if the same assembly is
generated, then the performance will be the same. I know that
&lt;a href=&#34;https://channel9.msdn.com/events/Build/2013/4-329?term=The%20Elephant%20in%20the%20CPU&#34; target=&#34;_blank&#34;&gt;fewer instructions is not a guarantee of better performance&lt;/a&gt;,
but I think it is safe to assume that if the assembly is the same, then the
performance will be the same.&lt;/p&gt;


&lt;figure&gt;
    &lt;a href=&#34;https://tinyurl.com/ycc42hkx&#34; target=&#34;_blank&#34;&gt;
        &lt;img src=&#34;compiler_explorer.png&#34; alt=&#34;https://tinyurl.com/ycc42hkx&#34; /&gt;
    &lt;/a&gt;
    
&lt;/figure&gt;


&lt;p&gt;In the above figure, the leftmost editor/compiler pane pair illustrates the C
style for loop assembly.  The central pane shows the assembly for the version of
the range code as it is in the previous section, and, because compiler explorer
provides a version of the Boost libraries, the same loop using &lt;code&gt;boost::irange&lt;/code&gt;
is displayed in the rightmost pane.  The assembly generated is exactly the same
even at a low optimization level (&lt;code&gt;O1&lt;/code&gt;).  This means GCC is able to completely
see through the abstractions and produce the same output whether this range
construct or a hand coded C style for loop is used.  When I saw that, I though
it was excellent news, and decided to test with two other commonly used
compliers: Clang and MSVC&lt;sup&gt;[6]&lt;/sup&gt;.&lt;/p&gt;

&lt;p&gt;Using Clang, I first got disappointing results: a higher optimization level (&lt;code&gt;O2&lt;/code&gt;)
was necessary to obtain the same result.  Thinking about why that was, I decided
to test if it was related to inlining.  Rewriting the code to use
&lt;code&gt;__attribute__((always_inline))&lt;/code&gt; to suggest more aggressive inlining to the
compiler, I was able to get Clang to emit the same assembly as a hand written
loop at the lower level (&lt;code&gt;O1&lt;/code&gt;).  Great.&lt;/p&gt;

&lt;p&gt;I then tried with MSVC.  No matter the optimization level or the inlining hints
used, for this compiler, there seems to remain a small difference in the assembly
generated when using the &lt;code&gt;Range&lt;/code&gt; code presented here compared to that generated
when using the C style for loop.  This is shown in the following figure:

&lt;figure&gt;
    
        &lt;img src=&#34;msvc.png&#34; /&gt;
    
    
&lt;/figure&gt;
&lt;/p&gt;

&lt;p&gt;The loops are structured differently. In the assembly of the hand written loop,
there is a single conditional jump instruction back to the beginning of the loop
if the loop exit condition is not met, but no other jump instruction.  When the
exit condition is met, the program simply continues with the next instruction,
thereby exiting the loop.  On the other hand, the assembly generated by the
&lt;code&gt;Range&lt;/code&gt; construct contains two jumps: one back to the beginning of the loop when
the loop exit condition is not met, and one out of the loop when the condition is
met. The number of comparison instructions (&lt;code&gt;cmp&lt;/code&gt;) is the same though and that
should be the most significant performance factor.  I imagine for a very short
loop (i.e. low number of iterations), the extra jump &lt;em&gt;could&lt;/em&gt; be a significant
overhead, but for a long loop, I doubt it.  I guess actual profiling would be
needed.&lt;/p&gt;

&lt;p&gt;Anyhow, at least in that first attempt, performance did not seem to be a big
issue (although compile times will go up if that is your metric).  This was
encouraging to me and motivated me to keep exploring this design.&lt;/p&gt;

&lt;h3 id=&#34;dealing-with-the-type-specification&#34;&gt;Dealing with the type specification&lt;/h3&gt;

&lt;p&gt;The next &lt;a href=&#34;#the-initial-design-goals&#34; target=&#34;_blank&#34;&gt;design goal&lt;/a&gt; I will be
talking about is the explicit type specification, or rather removing the need
for it. The &lt;code&gt;Range&lt;/code&gt; object is a class template, and prior to C++17, there is no
&lt;a href=&#34;http://en.cppreference.com/w/cpp/language/class_template_argument_deduction&#34; target=&#34;_blank&#34;&gt;template parameter argument deduction for class templates&lt;/a&gt;.
This means using it directly as in the example above will not allow me to achieve
the &amp;ldquo;no type specification&amp;rdquo; goal that I set out for.  However, function templates
in C++ always did have &lt;a href=&#34;http://en.cppreference.com/w/cpp/language/template_argument_deduction&#34; target=&#34;_blank&#34;&gt;template argument deduction&lt;/a&gt; and so
they could provide a nicer interface.  Given that the range expression in the
range-based for loop does not need to be an object, but can be a function
returning an object, it is possible to use a set of function template overloads
instead of a &lt;code&gt;Range&lt;/code&gt; directly.  With those, the types could be deduced.  Such
an overload set can be written as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;template&amp;lt; typename T &amp;gt;
auto range( T start, T stop ) -&amp;gt; Range&amp;lt; range_iterator&amp;lt;T&amp;gt; &amp;gt; {
   return Range&amp;lt; range_iterator&amp;lt;T&amp;gt; &amp;gt;{ start, stop };
}

template&amp;lt; typename T &amp;gt;
auto range( T stop ) -&amp;gt; Range&amp;lt; range_iterator&amp;lt;T&amp;gt; &amp;gt; {
   return range( T{0}, stop );
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;which can be used without a type specification like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;for( auto i : range( 8 ) ) {
   // use i
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;which is now very close to the Python version:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;for x in range( 8 ):
   # use i
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I have tested this on compiler explorer and it produces the same executable as
the previous version.  So far so good.&lt;/p&gt;

&lt;h3 id=&#34;correctly-handling-floating-point-ranges&#34;&gt;Correctly handling floating point ranges&lt;/h3&gt;

&lt;p&gt;This was not part of the initial
&lt;a href=&#34;#the-initial-design-goals&#34; target=&#34;_blank&#34;&gt;design goals&lt;/a&gt;, but dealing with this
issue actually helps with the last remaining design goal, so I dealt with it.  In
the current version, the main problem with floating point ranges is the
comparison operator.  As it stands, the rest of the code would function properly,
but the comparison of &lt;code&gt;begin&lt;/code&gt; and &lt;code&gt;end&lt;/code&gt; is broken, since it might never yield
false and result in an infinite loop (which has happened in testing I should say!).
Said another way, &lt;code&gt;begin&lt;/code&gt; might never compare equal to &lt;code&gt;end&lt;/code&gt; with the current
definition of comparison.&lt;/p&gt;

&lt;p&gt;Changing the definition of the &lt;code&gt;operator==&lt;/code&gt; to the following unorthodox one would
give the proper behavior for floating points:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;bool operator==( Iterator const&amp;amp; rhs ) const {
   return ( static_cast&amp;lt;Iterator&amp;amp;&amp;gt;(*this).direction_ == Ascending ) ?
            ( static_cast&amp;lt;Iterator&amp;amp;&amp;gt;(*this).cur_val_ &amp;gt;= rhs.cur_val_ ) :
               ( static_cast&amp;lt;Iterator&amp;amp;&amp;gt;(*this).cur_val_ &amp;lt;= rhs.cur_val_ );
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With this definition, for an ascending direction, two iterators are considered
equal if the value of the left hand side one is equal &lt;em&gt;or larger&lt;/em&gt; than that of
the right hand side one.  In the range-based for loop, the right hand side
iterator in the comparison is always &lt;code&gt;end()&lt;/code&gt;, so for those loops, the comparison
as defined above means any iterator with a value of end or more (ascending) are
considered equal.  Thus, as soon as the loop iterator&amp;rsquo;s value reaches, or gets
past, that of the end iterator, both iterators are considered equal and the loop
stops.  This is the desired behavior for the loop, but it is an unusual
definition for the iterator &lt;em&gt;if&lt;/em&gt; you think of the iterator as the value it holds.&lt;/p&gt;

&lt;p&gt;Having an operator with an unusual meaning is generally considered bad practice,
and for good reasons.  With the previous definition, the result of comparing two
iterators can depend on the order of the parameters:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;range_iterator&amp;lt;double&amp;gt; a( 42.0, Ascending );
range_iterator&amp;lt;double&amp;gt; b( 48.5, Ascending );
assert( a == b );                    // will fire,     42.0 &amp;gt;= 48.5 -&amp;gt; false
assert( b == a );                    // will not fire, 48.5 &amp;gt;= 42.0 -&amp;gt; true
assert( ( a == b ) != ( b == a )  ); // will not fire, false != true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;which is surprising.  Operators having unusual or inconsistent behavior can be
confusing (the &lt;a href=&#34;https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md&#34; target=&#34;_blank&#34;&gt;C++ Core Guidelines&lt;/a&gt;
discuss this in their overload section (C.over), more specifically subsections
C.160 and C.167).  The problem I am faced with here is that the range-based for
loop cannot be customized to use something other than &lt;code&gt;operator!=&lt;/code&gt; to compare the
two iterators.  So whatever behavior I want my iterator to have, it must be in
the comparison operator.&lt;/p&gt;

&lt;p&gt;That said, for the case at hand, these iterators are part of the implementation
of the &lt;code&gt;range&lt;/code&gt; function, which is the only part of the library that is considered
public.  The only use of the comparison operator should therefore be the one in
the range-based for, where the only comparison is between the &lt;code&gt;begin&lt;/code&gt; and &lt;code&gt;end&lt;/code&gt;
iterator pair, which will have the correct behavior.  The iterators are not meant
to be used directly and I think the implementation is thus reasonable.  That is
debatable for sure, but in any case, in the actual implementation, the function
above is defined in the &lt;code&gt;EqualityComparisons&lt;/code&gt; class and some template
metaprogramming ensures that it applies only to floating point types.&lt;/p&gt;

&lt;p&gt;I should warn though that using floating points as a loop counter, either
manually or using the &lt;code&gt;range&lt;/code&gt; functions here, is not as simple as it seems at
first: floating point maths and comparisons are hard and floating point error
will be present with the naive loop.  Since the construct proposed here aims
only at replacing the naive loop, nothing fancy is done to compensate floating
point errors in loops involving floating points, and so I thought a reminder was
in order.&lt;/p&gt;

&lt;h3 id=&#34;allowing-non-unit-steps&#34;&gt;Allowing non unit steps&lt;/h3&gt;

&lt;p&gt;The last goal in my initial list is the non unit step.  For now, I can select
&lt;code&gt;start&lt;/code&gt; and &lt;code&gt;stop&lt;/code&gt;, I allow increment and decrement, I do not need to specify the
type, and the performance penalty (with some optimizations enabled) is almost
null on the compilers I tested.  The final goal is to allow non unit steps.
In order to do that, I have to:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;store the &lt;code&gt;step&lt;/code&gt; in the iterator;&lt;/li&gt;
&lt;li&gt;adjust the &lt;code&gt;operator++&lt;/code&gt; to advance of &lt;code&gt;step&lt;/code&gt; units instead of 1;&lt;/li&gt;
&lt;li&gt;adjust the &lt;code&gt;operator==&lt;/code&gt; for integral types;&lt;/li&gt;
&lt;li&gt;add an overload to the &lt;code&gt;range&lt;/code&gt; function which takes 3 arguments.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The third item was the easiest to deal with.  The change became necessary, since
if the step size is not an &lt;em&gt;exact&lt;/em&gt; divisor of the distance between &lt;code&gt;start&lt;/code&gt; and
&lt;code&gt;stop&lt;/code&gt;, the original definition of &lt;code&gt;operator==&lt;/code&gt; will never stop the loop, because
the loop iterator value will never be exactly the end iterator value, even
for integral types.  It turns out that using the same definition of the equality
operator as was used to deal with floating point iterators, the problem is solved.
Now, when the value of the loop iterator is above the end iterator value, the
loop stops, as desired.&lt;/p&gt;

&lt;p&gt;Going back to the first item, the decision I made was to add a template parameter
to the &lt;code&gt;range_iterator&lt;/code&gt; class which will be of a new enum type &lt;code&gt;Length&lt;/code&gt; which
tells me whether the &lt;code&gt;range_iterator&lt;/code&gt; will have unit length steps or any other
length.  Then, I create a specialization for the case where the length is unit
and one for when the length is other.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;enum class Length : uint_fast8_t {
   unit,
   other
};

constexpr auto Unit = Length::unit;
constexpr auto Other = Length::other;

template&amp;lt; typename T, Length length &amp;gt;
struct range_iterator;

template&amp;lt; typename T &amp;gt;
struct range_iterator&amp;lt; T, Unit &amp;gt; :
         Dereference&amp;lt; range_iterator&amp;lt;T&amp;gt;, T&amp;amp; &amp;gt;,
         Increment&amp;lt; range_iterator&amp;lt;T&amp;gt; &amp;gt;,
         EqualityComparisons&amp;lt; range_iterator&amp;lt;T&amp;gt; &amp;gt;
{
   /* implementation here for Unit length */
private:
   Direction direction_;
   T cur_val_;
}


template&amp;lt; typename T &amp;gt;
struct range_iterator&amp;lt; T, Other &amp;gt; :
         Dereference&amp;lt; range_iterator&amp;lt;T&amp;gt;, T&amp;amp; &amp;gt;,
         Increment&amp;lt; range_iterator&amp;lt;T&amp;gt; &amp;gt;,
         EqualityComparisons&amp;lt; range_iterator&amp;lt;T&amp;gt; &amp;gt;
{
   /* implementation here for Other length */
private:
   Direction direction_;
   T cur_val_;
   T step_;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the case where the length is not one, the &lt;code&gt;step&lt;/code&gt; is kept as a data member and
available to the operators.&lt;/p&gt;

&lt;p&gt;Changing the &lt;code&gt;operator++&lt;/code&gt; was not much more complicated than the change to the
comparison operator.  The &lt;code&gt;Increment&lt;/code&gt; type is now templated on the length, and,
using SFINAE, a different implementation of the &lt;code&gt;operator++&lt;/code&gt; is used depending on
whether the &lt;code&gt;length&lt;/code&gt; argument is &lt;code&gt;Unit&lt;/code&gt; or &lt;code&gt;Other&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;auto operator++() -&amp;gt; Iterator&amp;lt; T, length &amp;gt; {
   static_cast&amp;lt;Iterator&amp;lt; T, length &amp;gt;&amp;amp;&amp;gt;(*this).cur_val_ +=
                           static_cast&amp;lt;Iterator&amp;lt; T, length &amp;gt;&amp;amp;&amp;gt;(*this).step_;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The only remaining task is to add an overload of the &lt;code&gt;range&lt;/code&gt; function.  This
overload will take one more parameter (the &lt;code&gt;step&lt;/code&gt;) and return a range parametrized
with a different iterator type.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;template&amp;lt; typename T, typename U &amp;gt;
auto range( T start, T stop, U step ) -&amp;gt; detail::range&amp;lt; T &amp;gt; {
   return detail::range&amp;lt; T &amp;gt;{ start, stop, step };
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It should be noted that the &lt;code&gt;start&lt;/code&gt;/&lt;code&gt;stop&lt;/code&gt; and the &lt;code&gt;step&lt;/code&gt; parameters can have
different types.  This is necessary for someone to be able to call the function
like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;for( auto i : range( 13u, 0u, -3 ) ) {}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If all three parameters were of the same type, then the user would have to
manually convert one way or the other, which is not a nice interface.  What is
done in the implementation is a cast inside the constructor of the &lt;code&gt;Range&lt;/code&gt; object
to the iterator type.  Unfortunately, this opens the door to quite a few
conversion problems.  If you go from signed to unsigned, the behavior is correct
and portable.  If you go from unsigned to signed, the behavior is implementation
defined, but should mostly work.&lt;/p&gt;

&lt;p&gt;Anyhow, with all of this in place, all my goals are achieved!&lt;/p&gt;

&lt;h2 id=&#34;mixed-types-logic-checking&#34;&gt;Mixed types, logic checking&amp;hellip;&lt;/h2&gt;

&lt;p&gt;As I said, the code above is close to the one I ended up with, but not exactly
the same.  You can go on &lt;a href=&#34;https://github.com/ghlecl/range_fn&#34; target=&#34;_blank&#34;&gt;Github&lt;/a&gt; to find my
range function implementation.  There are more things one could do with it (or
do differently).&lt;/p&gt;

&lt;p&gt;One thing that could be done is allow for mixed types to be used for specifying
the bounds and not only the step (see previous section).  That is actually what
prompted my two previous posts about
&lt;a href=&#34;https://ghlecl.github.io/posts/integer_representations/&#34; target=&#34;_blank&#34;&gt;integer representations&lt;/a&gt; and
&lt;a href=&#34;https://ghlecl.github.io/posts/usual_conversions/&#34; target=&#34;_blank&#34;&gt;usual conversions in arithmetic&lt;/a&gt;.  I am not
illustrating the code here, since it would make this already long post even
longer, but it can be done.  It does bring up some interesting questions though
such as which type to return when two types are used.  I am still uncertain what
a good answer is.  As far as I can tell, Boost range has decided to simply not
allow that.  This is not unreasonable.  That said, the use case I see for
allowing mixed types bounds specification is the following:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;std::vector&amp;lt; int &amp;gt; v{ 0, 2, 4, 6, 8, 10, 12 };
for( auto idx : range( 3, v.size() ) ) {
   // do something with the items 3 to size of vector v
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Since the standard library has made the choice of having &lt;code&gt;size&lt;/code&gt; of containers be
unsigned, without mixed bound types, this would not work without asking the user
to write &lt;code&gt;3u&lt;/code&gt; as the first index or cast the &lt;code&gt;.size()&lt;/code&gt; call result.&lt;/p&gt;

&lt;p&gt;Another thing, you will see in the code is some consistency checks.  For instance,
if &lt;code&gt;start&lt;/code&gt; &amp;gt; &lt;code&gt;stop&lt;/code&gt; while &lt;code&gt;step&lt;/code&gt; &amp;gt; 0, there is likely a problem (unless you
allow overflowing loops, which could be done).&lt;/p&gt;

&lt;p&gt;There are some parts of the code which, with hindsight, seem superfluous.  For
instance, there is no difference in the dereferencing behavior in any of the code
here, so it would be simpler to leave it in the &lt;code&gt;range_iterator&lt;/code&gt; implementation.
It would not be DRY (repeated in two classes), but the complexity introduced
might not be worth it.  As with any code, I think it can be &lt;del&gt;bikeshedded&lt;/del&gt;
debated forever.&amp;nbsp;&amp;nbsp;:-)&lt;/p&gt;

&lt;p&gt;Anyhow, I hope you have enjoyed reading this post.  Writing it certainly made me
clarify the concepts involved in range-based for loops in C++ and yielded a
construct I can use to loop over indices with a nice pythonish syntax.  It is
what I initially wanted, so for me at least, mission accomplished!&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;acknowledments&#34;&gt;Acknowledments&lt;/h2&gt;

&lt;p&gt;I would like to thank &lt;a href=&#34;https://www.twitter.com/Gab_AL_&#34; target=&#34;_blank&#34;&gt;Gabriel Aubut-Lussier&lt;/a&gt;
for taking the time to read this post before I published it and making
constructive comments on the content.  The writing is better for it.&lt;/p&gt;

&lt;h2 id=&#34;notes&#34;&gt;Notes&lt;/h2&gt;

&lt;p&gt;&lt;sup&gt;[1]&lt;/sup&gt; The work here will probably be made completely useless by the
&lt;a href=&#34;http://open-std.org/JTC1/SC22/WG21/docs/papers/2017/n4685.pdf&#34; target=&#34;_blank&#34;&gt;range proposal&lt;/a&gt;
when it gets in the standard.  On top of that, such a function already exists in
&lt;a href=&#34;https://www.boost.org/doc/libs/1_67_0/libs/range/doc/html/range/reference/ranges/irange.html&#34; target=&#34;_blank&#34;&gt;Boost&lt;/a&gt;.
The links were valid at the time of writing.  The link to the range proposal is
actually to a draft version of the proposal, which might differ from what actually
ends up in the standard.&lt;/p&gt;

&lt;p&gt;&lt;sup&gt;[2]&lt;/sup&gt; Link pointed to most recent release on the date of writing.
Might not work on future dates.&lt;/p&gt;

&lt;p&gt;&lt;sup&gt;[3]&lt;/sup&gt;Edit 2018-08-16: Turns out even in C++98, it works for built-in
arrays, albeit not with the &lt;code&gt;std::begin()&lt;/code&gt; and &lt;code&gt;std::end()&lt;/code&gt; free functions given
they were introduced in C++11.  You can simply pass the array &amp;ldquo;bounds&amp;rdquo; (i.e. the
array variable and the array variable plus the length) to the standard algorithm
(tested with std::sort) and it works.  You learn every day!&lt;/p&gt;

&lt;p&gt;&lt;sup&gt;[4]&lt;/sup&gt; At first, like most I would think, I actually first asked a search
engine and that is how I found &lt;a href=&#34;https://www.justsoftwaresolutions.co.uk/cplusplus/generating_sequences.html&#34; target=&#34;_blank&#34;&gt;Anthony&amp;rsquo;s post&lt;/a&gt;
on the subject.  This was a great starting point.&lt;/p&gt;

&lt;p&gt;&lt;sup&gt;[5]&lt;/sup&gt; Adapted from the C++17 standard draft.&lt;/p&gt;

&lt;p&gt;&lt;sup&gt;[6]&lt;/sup&gt; In the course of writing this article, I realized that a version
of the Intel compiler was also available on Compiler Explorer and thus decided
to look at the assembly generated with this compiler.  It turns out it takes
optimization level 3 for the code to give the same result as the hand-coded loop
with this compiler.  Depending on whether or not you can use this optimization
level, the performance of the &lt;code&gt;Range&lt;/code&gt; presented here might not be very good with
this compiler.&lt;/p&gt;
</description>
      </item>
      
    
      
      <item>
        <title>Mixed types arithmetic in C&#43;&#43;</title>
        <link>https://ghlecl.github.io/posts/usual_conversions/</link>
        <pubDate>Sat, 19 May 2018 00:00:00 +0000</pubDate>
        <author>codeattempts@gmail.com - Ghyslain Leclerc</author>
        <guid>https://ghlecl.github.io/posts/usual_conversions/</guid>
        <description>

&lt;h1 id=&#34;arithmetic-on-mixed-fundamental-types-in-c&#34;&gt;Arithmetic on mixed fundamental types in C++&lt;/h1&gt;

&lt;p&gt;For a weekend project of mine, I have had to think about mixed type arithmetic
on fundamental types in C++.  In the process, I made sense of a few fundamental
things (no &lt;em&gt;pun&lt;/em&gt; intended ;-)&amp;nbsp;) and I have decided to write them down.
Hopefully, writing about it will allow me to both clarify my thoughts and
remember the information!&lt;/p&gt;

&lt;h2 id=&#34;arithmetic-conversions&#34;&gt;Arithmetic conversions&lt;/h2&gt;

&lt;p&gt;Applying binary operators to different types might seem trivial in C++, because
it mostly just works.  If you write the following code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;float flt{15.f};
long lng_a{30L};
long lng_b = lng_a + flt;
assert( lng_b == 45 );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and then run it, the value of &lt;code&gt;lng_b&lt;/code&gt; will be 45.  No surprises&amp;hellip;  Except
when you stop to think about what happened in the background and how many rules
were involved in the computation.&lt;sup&gt;[1]&lt;/sup&gt;&lt;/p&gt;

&lt;p&gt;Naively (as seems to often be the case for me&amp;hellip;), because of the performance
reputation of C++, I assumed that the addition expression above mapped to an
assembly language instruction&lt;sup&gt;[2]&lt;/sup&gt; to add two registers.  Then, I
started thinking more seriously about the problem, and even though I am anything
but an expert in assembly, it brought me to this question: is there an opcode to
add an &lt;code&gt;int&lt;/code&gt; to a &lt;code&gt;float&lt;/code&gt;?  Are there mixed type instructions for the CPUs?  With
modern hardware, &lt;a href=&#34;https://queue.acm.org/detail.cfm?id=3212479&#34; target=&#34;_blank&#34;&gt;it is not as simple as we think anymore&lt;/a&gt;, but as far as I could find out, in
most hardware, &lt;a href=&#34;https://stackoverflow.com/a/42184775&#34; target=&#34;_blank&#34;&gt;there&lt;/a&gt;
&lt;a href=&#34;https://stackoverflow.com/a/28011249&#34; target=&#34;_blank&#34;&gt;is not&lt;/a&gt;.  This means that at the hardware
level, both datum have to have the same representation to allow the operation,
which is not completely unreasonable.  Thus, even for the simple expression in
the code above, conversions are needed to select a common type to apply the
operation on.&lt;/p&gt;

&lt;p&gt;The C++ language standard explicitly states which conversions will take place
(inherited from&amp;nbsp;C) allowing one to take control and override the behavior
manually using a cast if preferred. This could be needed if, for instance, the
default conversion introduces loss of precision on a given platform or if a
specific wrapping behavior is required.&lt;/p&gt;

&lt;p&gt;One should note that the type selected for the operation by the conversion rules
will be the type of both operands &lt;strong&gt;&lt;em&gt;and&lt;/em&gt;&lt;/strong&gt; of the return value.  This means that
a supplementary conversion might happen if the type in which the result of the
operation is put is not that which would have been selected by the usual
conversions (as is the case in the example above).  Something to keep in mind.&lt;/p&gt;

&lt;h2 id=&#34;usual-arithmetic-conversions&#34;&gt;Usual arithmetic conversions&lt;/h2&gt;

&lt;p&gt;The conversion rules applied before binary operations on fundamental types are
called the &lt;em&gt;usual arithmetic conversions&lt;/em&gt; and can be found in
section&amp;nbsp;&lt;strong&gt;8&amp;nbsp;Expressions&lt;/strong&gt; of the C++ standard document&lt;sup&gt;[3]&lt;/sup&gt;.
For those like me who do not easily read &amp;ldquo;standardese&amp;rdquo;, information on the
subject with some explanations can be
&lt;a href=&#34;https://docs.microsoft.com/en-us/cpp/cpp/standard-conversions&#34; target=&#34;_blank&#34;&gt;found&lt;/a&gt;
&lt;a href=&#34;https://wiki.sei.cmu.edu/confluence/display/c/INT02-C.+Understand+integer+conversion+rules&#34; target=&#34;_blank&#34;&gt;in&lt;/a&gt;
&lt;a href=&#34;http://en.cppreference.com/w/cpp/language/implicit_conversion&#34; target=&#34;_blank&#34;&gt;other&lt;/a&gt;
&lt;a href=&#34;https://www.ibm.com/support/knowledgecenter/en/SSQ2R2_9.0.0/com.ibm.tpf
.toolkit.compilers.doc/ref/langref_os390/cbclr21011.htm&#34; target=&#34;_blank&#34;&gt;places&lt;/a&gt;.  That said,
I have had to read some of the standard&amp;rsquo;s sections relating to the topic and I
have found them not too hard to read.  Might be a sign that I am slowly getting
assimilated&amp;hellip;&lt;/p&gt;

&lt;p&gt;In the discussion that follows, I will consider an operation &lt;code&gt;op&lt;/code&gt; on two
operands &lt;code&gt;t1&lt;/code&gt; and &lt;code&gt;t2&lt;/code&gt; respectively of types &lt;code&gt;T1&lt;/code&gt; and &lt;code&gt;T2&lt;/code&gt;.  This can be
conceptually represented as:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;T1 t1;
T2 t2;
t1 op t2;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the discussion, I will consider the following cases:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;T1&lt;/code&gt; and &lt;code&gt;T2&lt;/code&gt; are the same type (yes, conversions &lt;em&gt;can&lt;/em&gt; happen&amp;hellip;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;T1&lt;/code&gt; is floating point and &lt;code&gt;T2&lt;/code&gt; is integral (or vice versa)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;T1&lt;/code&gt; and &lt;code&gt;T2&lt;/code&gt; are both floating point, but different types&lt;/li&gt;
&lt;li&gt;&lt;code&gt;T1&lt;/code&gt; and &lt;code&gt;T2&lt;/code&gt; are both integral, but different types&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;These are almost all the situations covered in paragraph&amp;nbsp;11 of section&amp;nbsp;8
of the standard (but the last point is actually split in several sub-sections).
The only case I am not considering is when one of the type (or both) is a scoped
enumeration (i.e. an &lt;code&gt;enum class&lt;/code&gt;), because that had nothing to do with my
project and I simply did not think about it as much.&lt;/p&gt;

&lt;h2 id=&#34;same-type&#34;&gt;Same type&lt;/h2&gt;

&lt;p&gt;Even if the types are not actually mixed, I had to consider the case where both
operands are of the same type, i.e., &lt;code&gt;T1 == T2&lt;/code&gt;.  Intuitively, nothing should
happen in this case, but it turns out that it is a false assumption.  Because
arithmetic operators in C++ do not accept any type smaller than &lt;code&gt;int&lt;/code&gt;,
&lt;a href=&#34;http://en.cppreference.com/w/cpp/language/implicit_conversion#
Integral_promotion&#34; target=&#34;_blank&#34;&gt;integral promotion&lt;/a&gt; will take place before the operation. This is described in
section&amp;nbsp;&lt;strong&gt;7.6&amp;nbsp;Integral promotions&lt;/strong&gt; of the standard and can be roughly
summarized as: any type smaller than &lt;code&gt;int&lt;/code&gt; will be converted to &lt;code&gt;int&lt;/code&gt; or
&lt;code&gt;unsigned int&lt;/code&gt;.  For instance, the following relation holds:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;short a{0};
short b{1};
static_assert( is_same_v&amp;lt; int, decltype( a + b ) &amp;gt; );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Other than that, nothing else happens in terms of conversions.  As the name
suggests, this applies only for integral types.  I would assume that is because
the smallest floating point type is at least as large as an &lt;code&gt;int&lt;/code&gt;, but I don&amp;rsquo;t
think that is guaranteed.&lt;/p&gt;

&lt;h2 id=&#34;mixed-integral-and-floating-point-types&#34;&gt;Mixed integral and floating point types&lt;/h2&gt;

&lt;p&gt;Now, to look at mixed type arithmetic, the simplest case to start with is that
of integral and floating point mixed operations, i.e. either &lt;code&gt;T1&lt;/code&gt; or &lt;code&gt;T2&lt;/code&gt; is a
floating point and the other is integral.  In this case, the standard simply
mandates that the integer value be converted to the floating point type:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int + float =&amp;gt; (float)int + float
unsigned long long - float =&amp;gt; (float)unsigned long long - float
long double + unsigned =&amp;gt; long double + (long double)unsigned
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The casts illustrated here are at least what &lt;em&gt;conceptually happens&lt;/em&gt; if not what
&lt;em&gt;actually happens&lt;/em&gt;, but, as far as I can tell, it is what actually happens.  The
type selected in this situation is not too surprising when you think about it.
At least for IEEE floating points, the range of the smallest floating point type
(&lt;code&gt;float&lt;/code&gt;: 3.4&amp;times;10&lt;sup&gt;38&lt;/sup&gt;) is much larger than that of the largest
integer type (&lt;code&gt;unsigned long long&lt;/code&gt;: 1.84&amp;times;10&lt;sup&gt;19&lt;/sup&gt;).  Thus, neglecting
the issue of not being able to represent the value exactly if the mantissa of the
floating point type cannot hold the value of the integer type, the floating point
type will accommodate the integer type.  On top of that, the fractional part of
the floating point would necessarily be lost (either by rounding, truncating or
any other choice) if the conversion would be in the other direction.&lt;/p&gt;

&lt;p&gt;So again, because of those two points, the standard here makes sense (at least
to me!).&lt;/p&gt;

&lt;h2 id=&#34;mixed-floating-points&#34;&gt;Mixed floating points&lt;/h2&gt;

&lt;p&gt;Next on the scale of simplicity is the case where both arguments are of a
(different) floating point type.  In this case, the rule is simple: the smaller
type is cast to the larger type before the operation.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;double / float =&amp;gt; double / (double)float
long double + double =&amp;gt; long double + (long double)double
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This makes sense.  The value in the smaller sized variable will fit in the
larger one, so no change in value.&lt;/p&gt;

&lt;h2 id=&#34;mixed-integrals&#34;&gt;Mixed integrals&lt;/h2&gt;

&lt;p&gt;The final case is that of both operands being of integral types. Here, there are
a few more things to consider, since for the same type size, there are signed
and unsigned types (for instance, &lt;code&gt;int&lt;/code&gt; and &lt;code&gt;unsigned int&lt;/code&gt; must be the same size,
e.g. 4&amp;nbsp;bytes).  This complicates matters a little and before we continue, we need
to first define the concept of integer conversion rank
(section&amp;nbsp;&lt;strong&gt;7.15&amp;nbsp;Integer conversion rank&lt;/strong&gt; of the
standard document) which will be used in deciding the conversions to apply for
mixed integer types arithmetic.  Once these ranks are defined, the first
situation that applies in the following four scenarios is the conversion
mandated by the standard:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;both have the same signedness, independent of ranks;&lt;/li&gt;
&lt;li&gt;rank( unsigned ) &amp;gt;= rank( signed );&lt;/li&gt;
&lt;li&gt;rank( signed ) &amp;gt; rank( unsigned ), unsigned in signed range;&lt;/li&gt;
&lt;li&gt;rank( signed ) &amp;gt; rank( unsigned ), unsigned not in signed range;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Note that the order of the rank that I have written in situations 3 and 4 are not
mentioned in the standard, but the fact that situations 1 and 2 do not apply
implies that the rank of the signed integer is strictly greater than that of the
unsigned integer, so I wrote it explicitly.&lt;/p&gt;

&lt;h3 id=&#34;integer-conversion-rank&#34;&gt;Integer conversion rank&lt;/h3&gt;

&lt;p&gt;From what I understand from reading the standard, the integer types in C++ are
not given explicit values, but the relative ordering of the ranks is specified.
This can be &lt;strong&gt;&lt;em&gt;loosely&lt;/em&gt;&lt;/strong&gt; interpreted as: the integer ranks are in corresponding
order of size where the larger integral types have a higher rank.  In
particular, the standard says (section&amp;nbsp;7.15, par.&amp;nbsp;1.3):&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The rank of &lt;code&gt;long long int&lt;/code&gt; shall be greater than the rank of &lt;code&gt;long int&lt;/code&gt;, which
shall be greater than the rank of &lt;code&gt;int&lt;/code&gt;, which shall be greater than the rank
of &lt;code&gt;short int&lt;/code&gt;, which shall be greater than the rank of &lt;code&gt;signed char&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;In order to remove any ambiguity, the standard adds quite a few details (there
are&amp;nbsp;10&amp;nbsp;clauses to the section), but I believe that the following order of ranks,
from smallest rank to highest rank, is mandated by the standard:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;bool&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;char&lt;/code&gt;, &lt;code&gt;signed char&lt;/code&gt;, &lt;code&gt;unsigned char&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;short&lt;/code&gt;, &lt;code&gt;unsigned short&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;int&lt;/code&gt;, &lt;code&gt;unsigned int&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;long&lt;/code&gt;, &lt;code&gt;unsigned long&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;long long&lt;/code&gt;, &lt;code&gt;unsigned long long&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;where for a given type size, signed and unsigned types share their rank.  I said
the rule of thumb as presented above loosely interprets the standard because the
standard does not explicitly mandate the size of &lt;code&gt;short&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;long&lt;/code&gt;, and
others.  This freedom is to allow the implementers to represent the various
hardware architectures that exist.  I think this is mostly an artifact of history,
since a lot of modern hardware is 32&amp;nbsp;or 64&amp;nbsp;bits, but it is still how
the standard is written.  That said, it remains that on some machines, two types
could share the same size, e.g. on a particular architecture, &lt;code&gt;sizeof(long)&lt;/code&gt; could
be the same as &lt;code&gt;sizeof(int)&lt;/code&gt;.  In such a case, the standard would still stipulate
that those types&amp;rsquo; ranks are different.  Specifically, in the example give, &lt;code&gt;long&lt;/code&gt;
would still have a higher rank than &lt;code&gt;int&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;same-signedness&#34;&gt;Same signedness&lt;/h3&gt;

&lt;p&gt;So, getting back to the mixed operations and the usual conversion, in the case of
two integral types with the same signedness, i.e. both &lt;code&gt;T1&lt;/code&gt; and &lt;code&gt;T2&lt;/code&gt; are signed
or both of them are unsigned, the standard mandates that the integer with the
smaller rank be converted (after promotion), to the integer with the higher rank.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;long + int =&amp;gt; long + (long) int
unsigned short * unsigned int =&amp;gt; (unsigned int)unsigned short * unsigned int
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The higher ranked integer will accommodate the values of the smaller ranked one
without problem, and there are no considerations of sign, so no possible loss of
value or overflow in the conversion (there is possible overflow in the &lt;em&gt;operation&lt;/em&gt;,
but not in the &lt;em&gt;conversion&lt;/em&gt;).  This case is an easy one.&lt;/p&gt;

&lt;h3 id=&#34;differing-signedness-unsigned-with-larger-or-equal-rank&#34;&gt;Differing signedness, unsigned with larger or equal rank&lt;/h3&gt;

&lt;p&gt;In this case, the standard says that the signed integer will be converted to the
unsigned type.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int + unsigned int =&amp;gt; unsigned int(int) + unsigned int
short - unsigned int =&amp;gt; (unsigned int)short - unsigned int
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The fact that the operation then yields the correct answer is mandated by the
standard.  In section&amp;nbsp;&lt;strong&gt;7.8&amp;nbsp;Integral conversions&lt;/strong&gt;, the standard says:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;If the destination type is unsigned, the resulting value is the least unsigned
integer congruent to the source integer (modulo&amp;nbsp;2&lt;sup&gt;&lt;em&gt;n&lt;/em&gt;&lt;/sup&gt; where &lt;em&gt;n&lt;/em&gt;
is the number of bits used to represent the unsigned type). [ &lt;em&gt;Note&lt;/em&gt;: In a
twoâ€™s complement representation, this conversion is conceptual and there is no
change in the bit pattern (if there is no truncation). &amp;mdash; &lt;em&gt;end note&lt;/em&gt;]&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Because of the modulo&amp;nbsp;2&lt;sup&gt;&lt;em&gt;n&lt;/em&gt;&lt;/sup&gt; arithmetic, this will give the correct
unsigned answer&amp;hellip; most of the time.  See the discussion in the
&lt;a href=&#34;#keep-informed&#34; target=&#34;_blank&#34;&gt;last section&lt;/a&gt; for an example where this rule yields
a surprising result.&lt;/p&gt;

&lt;p&gt;This being the case, if you are putting the result of the operation in a variable,
at this point, it is worth thinking about that variable&amp;rsquo;s type, because if that
type is not the type of the unsigned operand (or larger unsigned integral type),
you will incur a conversion.  That is, while the operation is guaranteed to be
correct by the standard, putting it back into anything but a large enough unsigned
integral type might not yield the result you expect.  In a smaller unsigned
integral type, there is at least another modulo conversion happening.  If the type
is signed (whether it is large enough or not), then the result is implementation
defined as stipulated by the standard, again in section&amp;nbsp;7.8:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;If the destination type is signed, the value is unchanged if it can be
represented in the destination type; otherwise, the value is
implementation-defined.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The standard does not specify what happens in this case and instead gives latitude
to the compiler vendor saying the result is implementation defined.  This means
that if you rely on this conversion, the behavior might not be portable (&lt;strong&gt;&lt;em&gt;not&lt;/em&gt;&lt;/strong&gt;
undefined as in the case of overflow, just not portable and tied to the compiler
you use). On &lt;a href=&#34;http://www.cs.cornell.edu/~tomf/notes/cps104/twoscomp.html&#34; target=&#34;_blank&#34;&gt;two&amp;rsquo;s complement&lt;/a&gt; machines, this will
actually give you wrapping behavior, but relying on this is actually non portable
(even if, from what I understand, most hardware uses two&amp;rsquo;s complement these
days).  On other architectures, the behavior will be different and so portable
code should not rely on the conversions without some kind of checks.&lt;/p&gt;

&lt;h3 id=&#34;differing-signedness-signed-with-larger-rank-unsigned-in-range&#34;&gt;Differing signedness, signed with larger rank, unsigned in range&lt;/h3&gt;

&lt;p&gt;Here, the standard says that the unsigned integral type is converted to the
signed integral type.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;long long int + unsigned long( value &amp;lt; long_long_int_max )
                           =&amp;gt; long long int + (long long int)unsigned long
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Given that the unsigned integer is representable in the range of the signed
integer, the conversion will work as stipulated in section&amp;nbsp;7.8 of the
standard that I quoted in the previous part of this post (at least, that is my
understanding).  So that should always give the correct answer since the unsigned
&lt;em&gt;value&lt;/em&gt; is in range of the signed &lt;em&gt;type&lt;/em&gt;.&lt;/p&gt;

&lt;h3 id=&#34;differing-signedness-signed-with-larger-rank-unsigned-not-in-range&#34;&gt;Differing signedness, signed with larger rank, unsigned not in range&lt;/h3&gt;

&lt;p&gt;Here, the standard says that both operands are converted to the unsigned type of
same rank as that of the signed integer in the operation.  The unsigned should
be in range of the unsigned with the larger rank (i.e. the unsigned with same
rank as the signed in the operation, which is higher than that of the unsigned
in the operation).  The signed one will be modulo 2&lt;sup&gt;&lt;em&gt;n&lt;/em&gt;&lt;/sup&gt; converted.
Thus the result should be right given the modulo arithmetic, but with the usual
caveats of what you do with the result.&lt;/p&gt;

&lt;h2 id=&#34;back-to-the-first-example&#34;&gt;Back to the first example&lt;/h2&gt;

&lt;p&gt;So coming back to the first example, let&amp;rsquo;s see if I can apply the rules to it.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;float flt{15.f};
long lng_a{30L};
long lng_b = lng_a + flt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;According to the conversion rules, I would say that the &lt;code&gt;long&lt;/code&gt; value will first
be converted to &lt;code&gt;float&lt;/code&gt; to allow the addition, and that the resulting &lt;code&gt;float&lt;/code&gt;
will be truncated&lt;sup&gt;[1]&lt;/sup&gt;, which is what the standard mandates in
section&amp;nbsp;&lt;strong&gt;7.10&amp;nbsp;Floating-integral conversions&lt;/strong&gt;:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;A prvalue of a floating-point type can be converted to a prvalue of an integer
type. The conversion truncates; that is, the fractional part is discarded. The
behavior is undefined if the truncated value cannot be represented in the
destination type.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The numbers above are small enough that it just works as expected!  This is
probably true for a lot of use cases, which is why I think I can stand by my
initial affirmation that &amp;ldquo;applying binary operations to different types might
seem trivial in C++, because it mostly just works&amp;rdquo;.&lt;/p&gt;

&lt;h2 id=&#34;keep-informed&#34;&gt;Keep informed&lt;/h2&gt;

&lt;p&gt;As mentioned in the previous post, there is a (controversial?) &lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0907r0.html&#34; target=&#34;_blank&#34;&gt;proposal&lt;/a&gt; that has
been brought to the the C++ standards committee by JF Bastien which would make
two&amp;rsquo;s complement the only allowed representation for signed integers.  This could
change some of the details of this article, namely the parts where conversion
from unsigned to signed is implementation defined.  So in C++20 or C++23, the
information here could be out of date (already).&lt;/p&gt;

&lt;p&gt;Also, because of conversions, the following assert will actually fire as the
operation will yield false even if the mathematics would suggest otherwise:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;assert( -1 &amp;lt; 0u )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That is because this is a case where both integers have the same rank (the &lt;code&gt;-1&lt;/code&gt;
literal is &lt;code&gt;int&lt;/code&gt; and the &lt;code&gt;0u&lt;/code&gt; literal is &lt;code&gt;unsigned int&lt;/code&gt;), but differing
signedness.  Here, according to the rules above, the signed integer is converted
to the unsigned integer, which means &lt;code&gt;-1&lt;/code&gt; becomes the largest unsigned integer,
which will not be smaller than 0.  This kind of surprising behavior is currently
being discussed in the context of a &lt;a href=&#34;http://open-std.org/JTC1/SC22/WG21/docs/papers/2017/p0515r0.pdf&#34; target=&#34;_blank&#34;&gt;proposal by Herb Sutter&lt;/a&gt;.  Richard Smith
is &lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0946r0.html&#34; target=&#34;_blank&#34;&gt;proposing&lt;/a&gt; to bring
consistency between the new three-way comparison operator (a.k.a the &lt;em&gt;spaceship
operator&lt;/em&gt; &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt;) and the usual C comparison operators.  This might have no
impact on what I discussed here or might change it completely.  I will admit
that I am aware of the proposal, but I have not had time to read it through.&lt;/p&gt;

&lt;p&gt;In any case, the two proposals above, if they are adopted, will change some of
what I discussed here, so keep informed if this matters to you!&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;notes&#34;&gt;Notes&lt;/h2&gt;

&lt;p&gt;I would like to thank &lt;a href=&#34;https://twitter.com/PatriceRoy1&#34; target=&#34;_blank&#34;&gt;Patrice Roy&lt;/a&gt; for reading
my post and giving me some advice on it. His time is greatly appreciated.&lt;/p&gt;

&lt;p&gt;&lt;sup&gt;[1]&lt;/sup&gt; &lt;a href=&#34;https://tinyurl.com/ycdz8rky&#34; target=&#34;_blank&#34;&gt;Here is a link&lt;/a&gt; to the code of the
first example in compiler explorer (put in a main function so it compiles).  You
can see the &lt;code&gt;cvtsi2ss&lt;/code&gt;, &lt;code&gt;addss&lt;/code&gt; and &lt;code&gt;cvttss2si&lt;/code&gt; instructions which respectively
convert the &lt;code&gt;long&lt;/code&gt; to a &lt;code&gt;float&lt;/code&gt;, adds the resulting &lt;code&gt;float&lt;/code&gt;, and the &lt;code&gt;flt&lt;/code&gt;
variable and converts back the result to a &lt;code&gt;long&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;sup&gt;[2]&lt;/sup&gt; I believe assembly instructions, assembly code, machine code, and
opcodes are roughly the same (according to Wikipedia, some assembly instructions
do not map directly to opcodes, but most do).  In the context of this post, I
don&amp;rsquo;t think it makes much of a difference.  Thus, I use the terms interchangeably,
but I might be assuming a bit.  I am out of my depths in this domain.&lt;/p&gt;

&lt;p&gt;&lt;sup&gt;[3]&lt;/sup&gt; The official published document must be purchased from the ISO
organization, but the draft papers are freely available and can be found on the
web.  For instance, a C++17 draft paper (the latest draft before publication I
believe, but I might be wrong) can be found
&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/n4659.pdf&#34; target=&#34;_blank&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;
</description>
      </item>
      
    
      
      <item>
        <title>Integer binary representations</title>
        <link>https://ghlecl.github.io/posts/integer_representations/</link>
        <pubDate>Mon, 30 Apr 2018 00:00:00 +0000</pubDate>
        <author>codeattempts@gmail.com - Ghyslain Leclerc</author>
        <guid>https://ghlecl.github.io/posts/integer_representations/</guid>
        <description>

&lt;h1 id=&#34;integer-binary-representations&#34;&gt;Integer binary representations&lt;/h1&gt;

&lt;p&gt;I had never had to look closely at integer binary representations in computers.
The mental model I had for them was not wrong, but it turns out it was sub-optimal
and there are better ways to do things.  If you use high level abstractions and
do not mainly work with fundamental types, or if you do not convert between integer
types, you do not have to be mindful of the binary representation of integers
all the time as you program.  Thus, before the last few weeks, I never had to look
more closely at that, but I have started a project for which binary representation
had a direct effect and I finally looked into them.  I thought I would write down
some notes and observations.&lt;/p&gt;

&lt;p&gt;I am pretty sure that this is probably covered in all computer science degrees
and so might seem trivial and basic knowledge to many programmers, but since I
don&amp;rsquo;t have a CS degree and never had to think much about binary representation,
this was informative to me!  I should also point out that although I have used
the C and C++ standards as references, the concepts here are not exclusive to
these languages.&lt;/p&gt;

&lt;h2 id=&#34;unsigned-integers&#34;&gt;Unsigned integers&lt;/h2&gt;

&lt;p&gt;The &lt;a href=&#34;http://www.open-std.org/jtc1/sc22/WG14/www/docs/n1570.pdf&#34; target=&#34;_blank&#34;&gt;C standard&lt;/a&gt; is
explicit in its definition of unsigned integers (at least up to C11, the latest
standard at the time of writing).  It can be found in
section&amp;nbsp;&lt;strong&gt;6.2.6.2&amp;nbsp;Integer types&lt;/strong&gt;, paragraph&amp;nbsp;1:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;For unsigned integer types other than unsigned char, the bits of the object
representation shall be divided into two groups: value bits and padding bits
(there need not be any of the latter). If there are &lt;code&gt;N&lt;/code&gt; value bits, each bit
shall represent a different power of 2 between 1 and 2&lt;sup&gt;&lt;code&gt;N&lt;/code&gt;âˆ’1&lt;/sup&gt;, so that
objects of that type shall be capable of representing values from 0 to
2&lt;sup&gt;&lt;code&gt;N&lt;/code&gt;&lt;/sup&gt;&amp;nbsp;âˆ’&amp;nbsp;1 using a pure binary representation; this shall
be known as the value representation. The values of any padding bits are
unspecified.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;which is sometimes referred to as the pure binary representation.  Other than the
fact that the wording confused me at first&lt;sup&gt;[1]&lt;/sup&gt;, this basically describes
a usual &lt;a href=&#34;https://en.wikipedia.org/wiki/Binary_number&#34; target=&#34;_blank&#34;&gt;binary&lt;/a&gt;
&lt;a href=&#34;https://en.wikipedia.org/wiki/Positional_notation&#34; target=&#34;_blank&#34;&gt;positional number notation&lt;/a&gt;,
which is much like the decimal positional number notation we commonly use but
forget about. This is rather intuitive if you are familiar with positional number
systems.  The most significant bit position (&lt;em&gt;i.e.&lt;/em&gt; the largest exponent bit) is
not specified in the standard as it varies with hardware (and is more complicated
then it seems if you get into byte ordering on top of that). The range of the pure
binary unsigned representation is the following:
&lt;p style=&#34;text-align: center;&#34;&gt;
0 &amp;ensp; to &amp;ensp; 2&lt;sup&gt;&lt;code&gt;n&lt;/code&gt;&lt;/sup&gt; &amp;ndash; 1
&lt;/p&gt;&lt;/p&gt;

&lt;p&gt;where &lt;code&gt;n&lt;/code&gt; is the number of bits used in the representation.  That is how you get
to the range&amp;nbsp;0 to&amp;nbsp;255 (= 2&lt;sup&gt;8&lt;/sup&gt; &amp;ndash; 1) for an&amp;nbsp;8&amp;nbsp;bit
number.&lt;/p&gt;

&lt;p&gt;On the other hand, the
&lt;a href=&#34;http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2017/n4659.pdf&#34; target=&#34;_blank&#34;&gt;C++ standard&lt;/a&gt;
is more vague on the subject (at least up to C++17, the latest standard at the
time of writing).  As far as I can tell, it does not impose an explicit
representation for its unsigned type.  Section &lt;strong&gt;6.9 Types&lt;/strong&gt; of the standard deals
with type representations and the closest I have found to having an explicit
representation specified for unsigned types is footnote 45 which says:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The intent is that the memory model of C++ is compatible with that of ISO/IEC
9899 Programming Language C.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;which would suggest, I think, that the type representations have to be compatible.
But that is not exactly explicit.  Then, in paragraph 3, section
&lt;strong&gt;6.9.1&amp;nbsp;Fundamental types&lt;/strong&gt;, the standard says:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The range of non-negative values of a signed integer type is a subrange of the
corresponding unsigned integer type, the representation of the same value in
each of the two types is the same, and the value representation of each
corresponding signed/unsigned type shall be the same. [&amp;hellip;]  The signed and
unsigned integer types shall satisfy the constraints given in the C standard,
section 5.2.4.2.1.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;This does not imply a pure binary representation.  That said, most if not all C++
implementations in the field will actually have a pure binary representation for
unsigned integers.&lt;/p&gt;

&lt;h2 id=&#34;signed-integers&#34;&gt;Signed integers&lt;/h2&gt;

&lt;p&gt;There are a few &lt;a href=&#34;https://en.wikipedia.org/wiki/Signed_number_representations&#34; target=&#34;_blank&#34;&gt;signed integer representations&lt;/a&gt; and, for now at
least&lt;sup&gt;[2]&lt;/sup&gt;, none of them is explicitly specified (or forbidden) by the
C or C++ standards.  I have looked at three different representations, the last
one being the most common if I understand correctly.&lt;/p&gt;

&lt;h3 id=&#34;signed-magnitude&#34;&gt;Signed magnitude&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;(https://en.wikipedia.org/wiki/Signed_number_representations#
Signed_magnitude_representation)&#34; target=&#34;_blank&#34;&gt;Signed magnitude&lt;/a&gt; is the obvious solution to the problem: take
the first bit and make it a sign bit, &lt;em&gt;i.e.&lt;/em&gt; model the + or &amp;ndash; sign as a 0
or a 1.  This is actually the mental model I had for signed integers.  The range
of this solution is:
&lt;p style=&#34;text-align: center;&#34;&gt;
&amp;ndash;(2&lt;sup&gt;(&lt;code&gt;n&lt;/code&gt; &amp;ndash; 1)&lt;/sup&gt; &amp;ndash; 1)  &amp;ensp;
                        to &amp;ensp; 2&lt;sup&gt;(&lt;code&gt;n&lt;/code&gt; &amp;ndash; 1)&lt;/sup&gt; &amp;ndash; 1
&lt;/p&gt;&lt;/p&gt;

&lt;p&gt;where &lt;code&gt;n&lt;/code&gt; is the number of bits in the representation.  This gives only one less
number then the unsigned solution, because there are now two bit patterns that
represent 0.  For instance, for 8 bits, both:
&lt;p style=&#34;text-align: center;&#34;&gt;
&lt;code&gt;00000000&lt;/code&gt; &amp;emsp; and &amp;emsp; &lt;code&gt;10000000&lt;/code&gt;
&lt;/p&gt;&lt;/p&gt;

&lt;p&gt;represent the number zero (albeit, positive 0 and negative 0).  This is not
really a problem although comparison with zero now has to check for two cases.&lt;/p&gt;

&lt;p&gt;Although the signed magnitude approach seems very natural, it makes the hardware
to do simple arithmetic operations&amp;nbsp;(+, &amp;ndash;) more complex to write.
&lt;a href=&#34;https://www2.cs.duke.edu/courses/cps104/fall98/lectures/week1-l2/tsld021.htm&#34; target=&#34;_blank&#34;&gt;From what&lt;/a&gt;
&lt;a href=&#34;http://scientific-solutions.com/products/faq/ssi_faq_bin_sm_2comp.shtml&#34; target=&#34;_blank&#34;&gt;I read&lt;/a&gt;
(I am no expert), this is mostly because the sign bit has to be dealt with before
the operation and the circuitry becomes more complex.  It is mainly for this
reason that other approaches have been developed.&lt;/p&gt;

&lt;h3 id=&#34;one-s-complement&#34;&gt;One&amp;rsquo;s complement&lt;/h3&gt;

&lt;p&gt;In the &lt;a href=&#34;(https://en.wikipedia.org/wiki/Ones%27_complement)&#34; target=&#34;_blank&#34;&gt;one&amp;rsquo;s complement&lt;/a&gt;
signed number representation, a negative number is obtained by taking the
complement of its unsigned representation, &lt;em&gt;i.e.&lt;/em&gt; inverting every bit.  The range
of this binary representation is the same as that of the signed magnitude
representation, for the exact same reason: there are two ways of representing the
number 0.  So, again, the range is:
&lt;p style=&#34;text-align: center;&#34;&gt;
&amp;ndash;(2&lt;sup&gt;(&lt;code&gt;n&lt;/code&gt; &amp;ndash; 1)&lt;/sup&gt; &amp;ndash; 1) &amp;ensp;
                  to &amp;ensp; 2&lt;sup&gt;(&lt;code&gt;n&lt;/code&gt; &amp;ndash; 1)&lt;/sup&gt; &amp;ndash; 1
&lt;/p&gt;&lt;/p&gt;

&lt;p&gt;where &lt;code&gt;n&lt;/code&gt; is the number of bits in the representation and again, there are two
representations of zero, albeit not the same as for signed magnitude (e.g.
for&amp;nbsp;8 bits):
&lt;p style=&#34;text-align: center;&#34;&gt;
&lt;code&gt;00000000&lt;/code&gt; &amp;emsp; and &amp;emsp; &lt;code&gt;11111111&lt;/code&gt;
&lt;/p&gt;&lt;/p&gt;

&lt;p&gt;This binary representation makes algorithms for the addition and subtraction of
integers much simpler than the signed magnitude representation.  With one&amp;rsquo;s
complement encoding, the usual algorithm that we do by hand for addition works and
yields the correct value so long as the leftmost carry bit is added back to the
result (if it is 0, that&amp;rsquo;s fairly easy ;-) ).  There is a way to remove the need
to add back the carry bit and that is one characteristic of the next
representation discussed.&lt;/p&gt;

&lt;h3 id=&#34;two-s-complement&#34;&gt;Two&amp;rsquo;s complement&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Two%27s_complement&#34; target=&#34;_blank&#34;&gt;Two&amp;rsquo;s complement&lt;/a&gt; is the last
method discussed (although not the last one there is, see
&lt;a href=&#34;https://en.wikipedia.org/wiki/Signed_number_representations&#34; target=&#34;_blank&#34;&gt;Wikipedia&amp;rsquo;s article&lt;/a&gt;
for at least two more).  This binary representation scheme is, today at least,
the most prevalent signed integer representation in hardware. This encoding is
almost the same as one&amp;rsquo;s complement, except that once you have calculated the
inverted bits of the number, you add one to it.  Two&amp;rsquo;s complement range is:
&lt;p style=&#34;text-align: center;&#34;&gt;
&amp;ndash;(2&lt;sup&gt;(&lt;code&gt;n&lt;/code&gt;â€‰&amp;ndash;â€‰1)&lt;/sup&gt;) &amp;ensp;
                     to &amp;ensp; 2&lt;sup&gt;(&lt;code&gt;n&lt;/code&gt;â€‰&amp;ndash;â€‰1)&lt;/sup&gt; &amp;ndash; 1
&lt;/p&gt;&lt;/p&gt;

&lt;p&gt;where &lt;code&gt;n&lt;/code&gt; is the number of bits in the representation.  It should be noted that
the range is not exactly the same as the one&amp;rsquo;s complement: it is larger by one.
This is explained by the fact that in this encoding scheme, there is only one
representation of&amp;nbsp;0, and it is the same as the unsigned&amp;nbsp;0, &lt;em&gt;i.e.&lt;/em&gt; all
bits set to&amp;nbsp;0.  Opposed to the one&amp;rsquo;s complement representation, in this
scheme, when all the bits are set to&amp;nbsp;1, the value encoded is not&amp;nbsp;0, but
rather the smallest negative number (&lt;em&gt;i.e.&lt;/em&gt;&amp;nbsp;-1).  For&amp;nbsp;8&amp;nbsp;bits, the
first row of the following table illustrates this:
&lt;table style=&#34;margin-left:auto; margin-right:auto;&#34;&gt;
   &lt;tr&gt;
      &lt;th style=&#34;padding:0px 15px;text-align:center;&#34;&gt;bits&lt;br&gt;&lt;/th&gt;
      &lt;th style=&#34;padding:0px 15px;text-align:center;&#34;&gt;two&amp;rsquo;s&lt;br/&gt;complement&lt;/td&gt;
      &lt;th style=&#34;padding:0px 15px;text-align:center;&#34;&gt;unsigned&lt;/td&gt;
   &lt;/tr&gt;
   &lt;tr&gt;
      &lt;td style=&#34;padding:0px 15px;text-align:center;&#34;&gt;11111111&lt;br&gt;&lt;/td&gt;
      &lt;td style=&#34;padding:0px 15px;text-align:center;&#34;&gt;-1&lt;/td&gt;
      &lt;td style=&#34;padding:0px 15px;text-align:center;&#34;&gt;255&lt;/td&gt;
   &lt;/tr&gt;
   &lt;tr&gt;
      &lt;td style=&#34;padding:0px 15px;text-align:center;&#34;&gt;01111111&lt;br&gt;&lt;/td&gt;
      &lt;td style=&#34;padding:0px 15px;text-align:center;&#34;&gt;127&lt;/td&gt;
      &lt;td style=&#34;padding:0px 15px;text-align:center;&#34;&gt;127&lt;/td&gt;
   &lt;/tr&gt;
   &lt;tr&gt;
      &lt;td style=&#34;padding:0px 15px;text-align:center;&#34;&gt;10000000&lt;br&gt;&lt;/td&gt;
      &lt;td style=&#34;padding:0px 15px;text-align:center;&#34;&gt;-128&lt;/td&gt;
      &lt;td style=&#34;padding:0px 15px;text-align:center;&#34;&gt;128&lt;/td&gt;
   &lt;/tr&gt;
   &lt;tr&gt;
      &lt;td style=&#34;padding:0px 15px;text-align:center;&#34;&gt;10000001&lt;br&gt;&lt;/td&gt;
      &lt;td style=&#34;padding:0px 15px;text-align:center;&#34;&gt;-127&lt;/td&gt;
      &lt;td style=&#34;padding:0px 15px;text-align:center;&#34;&gt;129&lt;/td&gt;
   &lt;/tr&gt;
   &lt;tr&gt;
      &lt;td style=&#34;padding:0px 15px;text-align:center;&#34;&gt;11010111&lt;br&gt;&lt;/td&gt;
      &lt;td style=&#34;padding:0px 15px;text-align:center;&#34;&gt;-41&lt;/td&gt;
      &lt;td style=&#34;padding:0px 15px;text-align:center;&#34;&gt;215&lt;/td&gt;
   &lt;/tr&gt;
   &lt;tr&gt;
      &lt;td style=&#34;padding:0px 15px;text-align:center;&#34;&gt;11111110&lt;br&gt;&lt;/td&gt;
      &lt;td style=&#34;padding:0px 15px;text-align:center;&#34;&gt;-2&lt;/td&gt;
      &lt;td style=&#34;padding:0px 15px;text-align:center;&#34;&gt;254&lt;/td&gt;
   &lt;/tr&gt;
&lt;/table&gt;&lt;/p&gt;

&lt;p&gt;Practically, when you get to the largest signed (positive) integer you can
represent with the number of bits available, if you increment by one, the bit
pattern becomes that of the lowest signed (negative) integer you can represent
(which is illustrated in the second and third rows of the table above).  After
that, increasing the bit pattern by&amp;nbsp;1 will increase the value by one (fourth
row of the table).  Citing &lt;a href=&#34;https://en.wikipedia.org/wiki/Two%27s_complement#Why_it_works&#34; target=&#34;_blank&#34;&gt;Wikipedia&amp;rsquo;s entry on two&amp;rsquo;s complement&lt;/a&gt;&lt;sup&gt;[3]&lt;/sup&gt;:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Fundamentally, the system represents negative integers by counting backward and
wrapping around.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;This representation then has the interesting property that when going from unsigned
to signed or vice-versa by only reinterpreting the bit pattern as if it were the
destination type, the behavior is that of modulo 2&lt;sup&gt;&lt;code&gt;n&lt;/code&gt;-1&lt;/sup&gt; wrapping (which
is the same as the wrapping behavior mandated by the C standard for unsigned
integers: wrapping to the value of the highest value plus one).&lt;/p&gt;

&lt;p&gt;Another property of this encoding scheme, and probably a more significant
advantage compared to the single representation of zero, is that the carry bit
for the usual algorithm of arithmetic operations (additions, subtractions) must
simply be ignored to give the correct result.  This differs from the one&amp;rsquo;s
complement encoding scheme, where it has to be added back.  Thus, arithmetic
operations are even simpler to implement.  This is probably a big reason why two&amp;rsquo;s
complement is the dominating binary representation right now.&lt;/p&gt;

&lt;h2 id=&#34;final-thoughts&#34;&gt;Final thoughts&lt;/h2&gt;

&lt;p&gt;I never had to think much about the binary representation of the integers I used.
I guess that can be attributed to me never working on the kind of applications
where it matters or always working with a single architecture.  Given that I do
not, for instance, often do binary file manipulation or networking, I am not sure
I will personally use this knowledge very often, but in any case, it is good to
know.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;notes&#34;&gt;Notes&lt;/h2&gt;

&lt;p&gt;&lt;sup&gt;[1]&lt;/sup&gt;The standard talks about the values represented and not the
exponent, so that it talks about the series:&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp; 1, 2, 4, 8, 16&amp;hellip;&lt;/p&gt;

&lt;p&gt;of successive evaluations of the exponents of 2 rather than the successive
exponents themselves, which actually start at zero.  This had confused me at
first, but &lt;a href=&#34;http://h-deb.clg.qc.ca/&#34; target=&#34;_blank&#34;&gt;Patrice Roy&lt;/a&gt; and
&lt;a href=&#34;http://www.aaronballman.com/&#34; target=&#34;_blank&#34;&gt;Aaron Ballman&lt;/a&gt; helped me see that I had
misinterpreted the standard.  Thanks to both of them.&lt;/p&gt;

&lt;p&gt;&lt;sup&gt;[2]&lt;/sup&gt;In the 2018 Jacksonville meeting of the ISO C++ Committee, a paper
has been presented to officially &lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0907r0.html&#34; target=&#34;_blank&#34;&gt;make signed integers two&amp;rsquo;s complement&lt;/a&gt;.  There
is no certainty on the future of this paper, but the idea was also presented to
the C standard committee and the discussions in both committee will take place to
see if this is something they will pursue.&lt;/p&gt;

&lt;p&gt;&lt;sup&gt;[3]&lt;/sup&gt;The sentence was taken from the linked page on April 28 2018.&lt;/p&gt;
</description>
      </item>
      
    
      
      <item>
        <title>Friends only class</title>
        <link>https://ghlecl.github.io/microposts/friends_only_class/</link>
        <pubDate>Tue, 28 Nov 2017 13:30:00 +0000</pubDate>
        <author>codeattempts@gmail.com - Ghyslain Leclerc</author>
        <guid>https://ghlecl.github.io/microposts/friends_only_class/</guid>
        <description>

&lt;h1 id=&#34;friends-only-class&#34;&gt;Friends only class&lt;/h1&gt;

&lt;p&gt;Having read &lt;a href=&#34;https://arne-mertz.de/2016/11/stronger-types/&#34; target=&#34;_blank&#34;&gt;a few&lt;/a&gt; &lt;a href=&#34;http://www.fluentcpp.com/2016/12/05/named-constructors/&#34; target=&#34;_blank&#34;&gt;blog posts&lt;/a&gt; and watched a short &lt;a href=&#34;https://youtube.com/watch?v=jLdSjh8oqmE&#34; target=&#34;_blank&#34;&gt;presentation&lt;/a&gt; on the subject of &lt;a href=&#34;http://foonathan.net/blog/2016/10/19/strong-typedefs.html&#34; target=&#34;_blank&#34;&gt;strong typedefs&lt;/a&gt;, I decided to look into their use and implementation.  In at least two implementations I have looked at (namely &lt;a href=&#34;https://github.com/foonathan/type_safe&#34; target=&#34;_blank&#34;&gt;type_safe&lt;/a&gt; and &lt;a href=&#34;https://sourceforge.net/projects/opaque-typedef/&#34; target=&#34;_blank&#34;&gt;opaque&lt;/a&gt;), I have found that mixin classes are used to add functionality to the new type.  For instance:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;class my_strong_typedef : public addable, public divisible
{};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Those mixin were implemented as empty classes that only have friend functions in them.  I was wondering what was the use of such constructs.  Turns out, it is an application of the &lt;a href=&#34;https://en.wikipedia.org/wiki/Barton%E2%80%93Nackman_trick&#34; target=&#34;_blank&#34;&gt;Bartonâ€“Nackman trick&lt;/a&gt; to allow &lt;a href=&#34;https://en.wikipedia.org/wiki/Argument-dependent_name_lookup&#34; target=&#34;_blank&#34;&gt;argument dependent name lookup&lt;/a&gt; (ADL) to find the function.&lt;/p&gt;

&lt;p&gt;When the compiler sees the following expression:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;lt + rt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;it must lookup the &lt;code&gt;operator+&lt;/code&gt; function to use with the types of &lt;code&gt;lt&lt;/code&gt; and &lt;code&gt;rt&lt;/code&gt;.  From my understanding, it is equivalent to an unqualified call to the operator, as in:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;operator+( lt, rt )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The various &lt;a href=&#34;http://en.cppreference.com/w/cpp/language/lookup&#34; target=&#34;_blank&#34;&gt;name lookup&lt;/a&gt; rules of C++, which are not so simple, are then used to find which function to call and an important aspect in this case is that during ADL:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;namespace-scoped friend functions (and function templates) that are declared in an associated class are visible through ADL even if they are not visible through ordinary lookup&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;which is a quote from the cppreference website.  Because of that part of the standard, an operator defined as a friend in a class of which your class inherits is found.  With this trick, you can, as other libraries have done, create multiple mixin classes from which your primary class inherits and ADL will find the functions.  The empty classes should mostly (if not completely) be optimized away by the compiler.&lt;/p&gt;
</description>
      </item>
      
    
      
      <item>
        <title>Count chars in lines</title>
        <link>https://ghlecl.github.io/microposts/count_chars_in_n_first_lines/</link>
        <pubDate>Wed, 22 Nov 2017 12:30:00 +0000</pubDate>
        <author>codeattempts@gmail.com - Ghyslain Leclerc</author>
        <guid>https://ghlecl.github.io/microposts/count_chars_in_n_first_lines/</guid>
        <description>

&lt;h1 id=&#34;counting-chars-in-first-n-lines&#34;&gt;Counting chars in first n lines&lt;/h1&gt;

&lt;p&gt;I was coding in one of my projects and wanted to make sure that the position I was finding in a file was correct.  In a first attempt, I tried copy-pasting the content of the file up to the position I was searching for into Microsoft Excel&amp;trade; to find the length of the resulting string.  Turns out a naive copy-paste does not preserve whitespace.&lt;/p&gt;

&lt;p&gt;I then thought of writing a small application to do what I wanted : open a file, read the &lt;code&gt;n&lt;/code&gt; first lines and find the total number of characters (bad reflex, I know).  In trying to figure out the command line interface for this, I realized first that it would be a lot of work for something that I might not use often and second, that there might be an easier way on a *Nix system.&lt;/p&gt;

&lt;p&gt;This lead me to simply using the applications &lt;a href=&#34;http://man7.org/linux/man-pages/man1/head.1.html&#34; target=&#34;_blank&#34;&gt;head&lt;/a&gt; and &lt;a href=&#34;http://man7.org/linux/man-pages/man1/wc.1.html&#34; target=&#34;_blank&#34;&gt;wc&lt;/a&gt; as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;head -n &amp;lt;line_count&amp;gt; | wc -m
&lt;/code&gt;&lt;/pre&gt;
</description>
      </item>
      
    
      
      <item>
        <title>Return type overloading</title>
        <link>https://ghlecl.github.io/posts/return_type_overload/</link>
        <pubDate>Thu, 12 Oct 2017 00:00:00 +0000</pubDate>
        <author>codeattempts@gmail.com - Ghyslain Leclerc</author>
        <guid>https://ghlecl.github.io/posts/return_type_overload/</guid>
        <description>

&lt;h1 id=&#34;no-return-type-overloading&#34;&gt;No return type overloading&lt;/h1&gt;

&lt;p&gt;In C++, return type does not participate in function overload resolution, i.e. it
is not possible to overload a function on the return type.  Thus, this is not
legal C++:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;void to_lower( std::string&amp;amp; strg );
std::string to_lower( std::string&amp;amp; strg );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The compiler will issue an error when it sees the second declaration.&lt;sup&gt;[1]&lt;/sup&gt;
For instance, the error Clang emits is the following: &amp;ldquo;error: functions that differ
only in their return type cannot be overloaded&amp;rdquo;.  The detailed reasons for this
rule are irrelevant in the current discussion: it is just a fact.  I believe it is
partially due to C++ allowing you to ignore the return value of a function if you
so choose.  Thus, even for a function returning an int, you can call it without
using or even capturing the return value:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;int fn( int );

auto ret_val = fn( 5 );
fn( 12 ); // legal call, simply drops the return value
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the example, if &lt;code&gt;fn&lt;/code&gt; were overloaded on return type only, how would the second
call be disambiguated?  I am far from certain this is the only reason why, but it
is convincing enough for me.&lt;/p&gt;

&lt;p&gt;Still, I really wanted to be able to have an &amp;ldquo;in place&amp;rdquo; and &amp;ldquo;not in place&amp;rdquo; version
of the &lt;code&gt;to_lower&lt;/code&gt; function I wrote.  And,
&lt;a href=&#34;https://twitter.com/secretGeek/status/7269997868&#34; target=&#34;_blank&#34;&gt;naming things is hard&lt;/a&gt;, so I did
not want to have to change the name of the function.  Cheating a little bit, I have
found a way to &lt;em&gt;simulate&lt;/em&gt; function overloading on return type or at least make it
possible to have the same name for the two functions and (almost) only a differing
return type.&lt;/p&gt;

&lt;p&gt;With what I came up with, one of the two overloads becomes a template and must be
called explicitly, so no ADL or overload resolution alone can help me and template
argument deduction cannot be used either because the function parameter(s) do not
depend on the template parameter.  After all, it is illegal to overload on return
type in C++ and my technique does not imply changing the ISO C++ standard!&lt;/p&gt;

&lt;h3 id=&#34;how-i-cheated&#34;&gt;How I &lt;em&gt;cheated&lt;/em&gt;&lt;/h3&gt;

&lt;p&gt;All I did is use a template parameter as a tag for one version of the function.
I created an empty struct as a tag and templated one of the versions (the one the
tag corresponds to).  Then, when I want that version to be called, I explicitly
select the templated version passing the tag as an explicitly specified template
argument.  Here is a code sample to illustrate/explain better:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;#include &amp;lt;type_traits&amp;gt;
#include &amp;lt;string&amp;gt;
#include &amp;lt;cstdio&amp;gt;
namespace ns
{
struct in_place {};

template&amp;lt; typename Tag &amp;gt;
void to_lower( std::string&amp;amp; strg )
{
   static_assert( std::is_same&amp;lt; Tag, in_place &amp;gt;::value,
                     &amp;quot;only in_place is allowed as the template parameter&amp;quot; );
   //... implementation here ...
}

std::string to_lower( std::string&amp;amp; strg )
{
   //... implementation here ...
   return strg;
}

} // namespace ns

int main( int argc, char* argv[] )
{
   using ns::in_place;
   using ns::to_lower;

   std::string to_change( &amp;quot;This STring is Mixed CASe.&amp;quot; );

   auto new_strg = to_lower( to_change );
   to_lower&amp;lt; in_place &amp;gt;( to_change );

   printf( &amp;quot;%s\n&amp;quot;, ( to_change == new_strg ? &amp;quot;true&amp;quot; : &amp;quot;false&amp;quot; ) );
   return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Users of the function are provided with the tag and can use it to call the
&amp;ldquo;overload&amp;rdquo; (so to speak, not an actual overload, I know).  Compilers are actually
pretty good at eliminating empty classes from the code, even at not too high
optimization levels.  So I am confident that the tag should disappear completely
from the resulting binary and there should be no runtime downside to this
technique.&lt;sup&gt;[2]&lt;/sup&gt;  Also, if appropriate, one function can be implemented
using the other.  To ensure that types other than the provided tag can&amp;rsquo;t be used
for the function call, I put a &lt;code&gt;static_assert&lt;/code&gt; in the implementation.  Otherwise,
any type could be put in there (as in &lt;code&gt;to_lower&amp;lt;int&amp;gt;&lt;/code&gt;), which although it would
   work, would not be as explicit and as clear.  I don&amp;rsquo;t know why anyone would
   want do that, but I forbid it explicitly in my implementation.&lt;/p&gt;

&lt;p&gt;What I did is no revolution and nothing fancy, but it does allow me to get the
interface I need from my function, namely two functions with the same name
differing only in return types&amp;hellip; or almost.  I also find it to be expressive: it
is clear at the call site that I will be modifying the string that is passed in.
Some might like it, others won&amp;rsquo;t!  If you find it useful, good.&lt;/p&gt;

&lt;h3 id=&#34;alternative&#34;&gt;Alternative&lt;/h3&gt;

&lt;p&gt;A friend suggested that another possible implementation would be to use variadic
templates and call the function with an empty diamond.  I tried that version and
it is possible.  I even put in a &lt;code&gt;static_assert&lt;/code&gt; to check that the function can&amp;rsquo;t
be called with a non empty parameter pack.  That being said, I find that it is
better to have the empty struct as a tag because it is a bit more explicit which
overload actually acts in place (whereas in the empty parameter pack alternative,
it is clear which overload is called (the template), but not whether this is the
one working in place).  I suspect either implementation would result in the same
binary code.  To me, another argument in favor of keeping the tag is that
&lt;a href=&#34;https://arne-mertz.de/2016/tag-dispatch/&#34; target=&#34;_blank&#34;&gt;tag dispatching&lt;/a&gt; (which my technique
is similar to) is familiar to many C++ programmers while seeing a call with the
empty diamond is not so common (I think, I might be completely wrong).&lt;/p&gt;

&lt;h3 id=&#34;notes&#34;&gt;Notes&lt;/h3&gt;

&lt;p&gt;&lt;sup&gt;[1]&lt;/sup&gt; I know that the second overload, the one returning a new string,
could take it&amp;rsquo;s parameter by reference or by value (since I&amp;rsquo;m probably doing a
copy in the implementation anyhow).  That would have complicated the explanation
of the overloads (as in that case, both functions would not technically be
exactly differing only in return type), so I chose to write my examples that way
in the post.&lt;/p&gt;

&lt;p&gt;&lt;sup&gt;[2]&lt;/sup&gt; I would have &amp;ldquo;Godbolted&amp;rdquo; my code, but I am not that good at reading
assembler and when I tried with the std::string, the resulting assembler contains
much more than my function and is not that simple to analyse.  I did it with ints,
but then, starting at -O2, main becomes almost empty as the compiler can see all
the constants and simplify all the way.&lt;/p&gt;
</description>
      </item>
      
    
      
      <item>
        <title>rvalue references in C&#43;&#43;</title>
        <link>https://ghlecl.github.io/posts/learning_rvalues/</link>
        <pubDate>Tue, 10 Jan 2017 00:00:00 +0000</pubDate>
        <author>codeattempts@gmail.com - Ghyslain Leclerc</author>
        <guid>https://ghlecl.github.io/posts/learning_rvalues/</guid>
        <description>

&lt;h1 id=&#34;move-rvalues-forward-and-c&#34;&gt;move, rvalues, forward and C++&lt;/h1&gt;

&lt;p&gt;Ever since I heard about it, the concept of move semantics has been intriguing
and appealing to me.  I confess to liking new C++ things and micro-optimizations
way too much&amp;hellip; but still, the concept of &amp;ldquo;moving&amp;rdquo; memory instead of copying it
in order to gain efficiency is at least worth exploring, right?  Anyhow, I chose
a function of mine and decided to try and make it handle move semantics properly.
The function I chose is one that I use often enough that I thought it would make
a difference.  It is the following template&lt;sup&gt;[1]&lt;/sup&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;template&amp;lt; typename T &amp;gt;
std::string to_string( T const&amp;amp; to_convert )
{
   std::stringstream strm( &amp;quot;&amp;quot; );
   strm &amp;lt;&amp;lt; to_convert;
   return strm.str();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, it turns out that because it is a templated function, move semantics will
have to be mixed with forwarding references and that, if you ask me, those things
are gibberish if you don&amp;rsquo;t understand lvalues and rvalues.  This is what started
my adventures into rvalue land.  After going through the process, I now realize
that for this particular case, it is not really useful because
&lt;a href=&#34;http://en.cppreference.com/w/cpp/io/basic_ostream/operator_ltlt&#34; target=&#34;_blank&#34;&gt;as far as I can tell&lt;/a&gt;,
std::strinstream::operator&amp;lt;&amp;lt;` is not overloaded on rvalue references.  Still, the
exercise was enlightening and I now know (or at least think I know) a lot more
about rvalues.  The information here is nothing new, probably incomplete and also
probably full of inaccuracies when compared to the strict standard C++ language
definitions (after all, this is in my own words), but I have found the information
useful.  I guess this is a snapshot of my current understanding.  All the better
if it helps anybody else.  Now, on to my journey.&lt;/p&gt;

&lt;h3 id=&#34;a-new-kind-of-references&#34;&gt;A new kind of references: &amp;amp;&amp;amp;&lt;/h3&gt;

&lt;p&gt;The idea behind move semantics is that when you need the value a variable contains
and it is a temporary (or simply about to get out of scope), you could make the
memory it owns yours instead of copying the value in your own memory.  This should
execute faster then the copying as it is doing less work.  Of course, saving
copies will not make much difference is you are copying a single &lt;code&gt;int&lt;/code&gt;, but if you
are, for instance, copying a &lt;code&gt;std::vector&lt;/code&gt; of an image class, stealing the pointer
to the images instead of copying the memory should have a large impact on runtime
efficiency.  For this to be possible, there has to be a mechanism to detect the
temporary nature of a variable and select what to do when a variable is temporary
and when a variable is not.  Starting with the 2011 standard, C++ now defines
rvalue references, identified by a double ampersand symbol (&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;), which will only
bind to temporary values.&lt;/p&gt;

&lt;p&gt;This gives us a way to determine if a parameter is a temporary value: create an
overload (or a single function) which takes an rvalue reference as its input.
Since this reference parameter will only bind to a temporary value, one can assume
that the parameter cannot normally be used elsewhere in the program once the
function returns.  When this guarantee holds, one can safely steal (or move) the
internals of the parameter(s) instead of making a copy(ies), potentially making
the function more efficient.  This is the crux of move semantics.  Of course, the
devil is in the details, as I have found out.&lt;/p&gt;

&lt;h4 id=&#34;quick-digression-value-categories&#34;&gt;Quick digression: value categories&lt;/h4&gt;

&lt;p&gt;Lvalues and rvalues are
&lt;a href=&#34;http://en.cppreference.com/w/cpp/language/value_category&#34; target=&#34;_blank&#34;&gt;value categories&lt;/a&gt;.
Those two categories have been part of C++ since its first standardization in 1998
and were carried over from C (although in C, no rvalues were directly defined and
&amp;ldquo;not lvalue&amp;rdquo; was deemed sufficient&lt;sup&gt;[2]&lt;/sup&gt;).  Those two categories take
their name from their original, although now erroneous, definition, which was to
think of them as the &amp;ldquo;left&amp;rdquo; and &amp;ldquo;right&amp;rdquo; operands of an assignment:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int a = 7; // a is an lvalue and 7 is an rvalue
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With that definition, &amp;ldquo;assignability&amp;rdquo; appears as the main difference between
lvalues and rvalues: if something cannot be assigned to, it is an rvalue.  I
honestly do not know if it is the case in C, but I know that is not the case in
C++.  Here is an example of an lvalue that is not assignable in C++.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;const int b{ 8 }; // b is an lvalue
b = 9; // error, can&#39;t assign to const even though it is an lvalue
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The const variable is still an lvalue, but one cannot assign a new value to it
after construction.  So although it is not assignable, it is an lvalue.  It is my
understanding that the more interesting property is not &amp;ldquo;assignability&amp;rdquo;, but
rather &amp;ldquo;addressability&amp;rdquo;, i.e. the capacity to refer to a value.  I can take the
address of both variables defined in the previous examples and refer to it, but
I cannot take the address of the literals and refer to them later in the program.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int a;
int&amp;amp; c = &amp;amp;a; // valid
int&amp;amp; d = &amp;amp;8; // invalid, can&#39;t refer to (or take address of) the literal 8
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So a better rule for rvalues is the following: if I can take the address of a
value or expression and reference it later in the program, the value is an lvalue;
otherwise, it is an rvalue.&lt;/p&gt;

&lt;p&gt;This is not the complete picture of value categories, since five value categories
are now defined in C++ (lvalues, glvalues, rvalues, prvalues and xvalues), but it
turns out to be an adequate rule of thumb for lvalue/rvalue discrimination and
that is what matters most for move semantics.  In
&lt;a href=&#34;https://isocpp.org/blog/2012/11/universal-references-in-c11-scott-meyers&#34; target=&#34;_blank&#34;&gt;this&lt;/a&gt;
blog post on &lt;a href=&#34;http://isocpp.org&#34; target=&#34;_blank&#34;&gt;isocpp.org&lt;/a&gt;,
&lt;a href=&#34;http://scottmeyers.blogspot.ca/&#34; target=&#34;_blank&#34;&gt;Scott Meyers&lt;/a&gt; gives this heuristics to determine
the general type (lvalue vs rvalue) of an expression or variable:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;If you can take the address of an expression, the expression is an lvalue.&lt;/li&gt;
&lt;li&gt;If the type of an expression is an lvalue reference (e.g., &lt;code&gt;T&amp;amp;&lt;/code&gt; or `const T&amp;amp;,
etc.), that expression is an lvalue.&lt;/li&gt;
&lt;li&gt;Otherwise, the expression is an rvalue.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;which is a quote from the linked blog post.  Again, in Scott&amp;rsquo;s words:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Conceptually (and typically also in fact), rvalues correspond to temporary
objects, such as those returned from functions or created through implicit type
conversions.  Most literal values (e.g., 10 and 5.3) are also rvalues.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;I think a nice feature of this heuristic is that it helps you remember that the
type of an expression is independent of whether the expression is an lvalue or an
rvalue. That is, given a type &lt;code&gt;T&lt;/code&gt;, you can have lvalues of type &lt;code&gt;T&lt;/code&gt; as well as
rvalues of type &lt;code&gt;T&lt;/code&gt;. Itâ€™s especially important to remember this when dealing with
a [function] parameter of rvalue reference type, because the parameter itself is
an lvalue.&lt;/p&gt;

&lt;p&gt;That last sentence took me a while to fully understand.  It is illustrated by the
following example (where the new double ampersand symbol (&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;) for rvalue
references is used):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;void foo( MyType&amp;amp;&amp;amp; param )
{
   auto&amp;amp; alias = &amp;amp;param;  // Completely legal: param has a memory location
                          // inside the function body.  Thus, by the heuristic
                          // above, param is an lvalue.
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This fact that the parameter is an lvalue inside the function might seem like a
simple detail, but it will turn out to be necessary to explain why &lt;code&gt;std::move&lt;/code&gt; and
&lt;code&gt;std::forward&lt;/code&gt; are necessary later on.&lt;/p&gt;

&lt;h4 id=&#34;overloading-on-rvalue-reference&#34;&gt;Overloading on rvalue reference&lt;/h4&gt;

&lt;p&gt;So the idea, as mentioned, is to create an overload on rvalue references.  There
is no way of representing rvalues (almost by definition from a certain point of
view), so rvalue references are the only option.  The following is a simple example.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;

int bar()
{ return 9; }

// const lvalue reference overload
void foo( int const&amp;amp; param )
{ std::cout &amp;lt;&amp;lt; &amp;quot;foo( int const&amp;amp; param )&amp;quot; &amp;lt;&amp;lt; std::endl; }

// rvalue reference overload
void foo( int&amp;amp;&amp;amp; param )
{ std::cout &amp;lt;&amp;lt; &amp;quot;foo( int&amp;amp;&amp;amp; param )&amp;quot; &amp;lt;&amp;lt; std::endl; }

// by copy overload, do not define as it will yield
//       error: call to &#39;foo&#39; is ambiguous
// void foo( int param )
// { std::cout &amp;lt;&amp;lt; &amp;quot;foo( int param )&amp;quot; &amp;lt;&amp;lt; std::endl; }

int main( int argc, char* argv[] )
{
   int a{ 6 };
   int&amp;amp; b{ a };
   const int&amp;amp; c{ b };
   foo( a );     // calls first foo
   foo( b );     // calls first foo
   foo( c );     // calls first foo
   foo( 7 );     // calls second foo
   foo( bar() ); // calls second foo
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this case, this does not buy you much, but the snippet above is compilable by
any C++11 conformant compiler.  This little code should output
&lt;code&gt;foo( int const&amp;amp; param )&lt;/code&gt; three times and &lt;code&gt;foo( int&amp;amp;&amp;amp; param )&lt;/code&gt; twice.  A non
compilable but more realistic/useful example would be:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;std::vector&amp;lt;int&amp;gt; foo();

// two functions constructing a MyCoolClass object from a vector&amp;lt;int&amp;gt;
MyCoolClass make_from_std_vec( std::vector&amp;lt;int&amp;gt; const&amp;amp; vec ); /* overload 1 */
MyCoolClass make_from_std_vec( std::vector&amp;lt;int&amp;gt;&amp;amp;&amp;amp; vec );      /* overload 2 */

std::vector&amp;lt;int&amp;gt; the_vec;
/* fill the_vec */

auto obj_1 = make_from_std_vec( the_vec );  // binds to overload 1
auto obj_2 = make_from_std_vec( foo() );    // binds to overload 2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here, because &lt;code&gt;std::vector&lt;/code&gt; has been updated to allow move semantics, the second
overload will be able to move the memory instead of copying it into the
&lt;code&gt;MyCoolClass&lt;/code&gt; object which should save a copy.&lt;/p&gt;

&lt;h4 id=&#34;implementing-enters-std-move&#34;&gt;Implementing : enters std::move&lt;/h4&gt;

&lt;p&gt;Once you have an overload which selects the rvalues, you have to implement it.
Most (if not all) POD types and STL types have been updated for move semantics,
although I am not sure that moving is faster than copying in the case of &lt;code&gt;int&lt;/code&gt;,
for instance.  That being said, this means that move constructors and move
assignment operators are available for &lt;code&gt;std::vector&lt;/code&gt;.  If you pass an rvalue to
those, they will move.  But that brings us back to the discussion on function
parameters inside of the function being lvalues.  That means that the following
will not actually move anything and will instead make a copy:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;std::vector&amp;lt;int&amp;gt; steal_guts_and_do_stuff( std::vector&amp;lt;int&amp;gt;&amp;amp;&amp;amp; vec )
{
   std::vector&amp;lt;int&amp;gt; result( vec );   // INCORRECT, will not move
   /* do stuff */
   return result;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That is because even though
&lt;a href=&#34;http://en.cppreference.com/w/cpp/container/vector/vector&#34; target=&#34;_blank&#34;&gt;there is&lt;/a&gt; an overload
of the &lt;code&gt;std::vector&lt;/code&gt; constructor for rvalues, what you actually passed as a
parameter (&lt;code&gt;vec&lt;/code&gt;) is &lt;em&gt;&lt;strong&gt;not&lt;/strong&gt;&lt;/em&gt; an rvalue (that was explained in previous sections).
Thus, the compiler will select the copy constructor instead of the move
constructor.  That being said, because you are implementing the rvalue reference
overload of your function (in this case, the &lt;code&gt;steal_guts_and_do_stuff&lt;/code&gt; function),
you know that in the &lt;em&gt;&lt;strong&gt;caller&lt;/strong&gt;&lt;/em&gt; scope, the parameter is actually an rvalue.
This means if you had a way to cast the parameter to an rvalue inside the function
implementation to tell the compiler to select the move constructor for
&lt;code&gt;std::vector&lt;/code&gt;, then that one would be selected.  This can be done with the new
function &lt;code&gt;std::move&lt;/code&gt;.  All this function does is &lt;em&gt;&lt;strong&gt;unconditionally&lt;/strong&gt;&lt;/em&gt; cast its
input to an rvalue reference.  The casting is done via the
&lt;a href=&#34;http://en.cppreference.com/w/cpp/language/reference&#34; target=&#34;_blank&#34;&gt;reference&lt;/a&gt;
&lt;a href=&#34;http://thbecker.net/articles/rvalue_references/section_08.html&#34; target=&#34;_blank&#34;&gt;collapsing rules&lt;/a&gt;.
Thus, the implementation above should actually be written as:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;std::vector&amp;lt;int&amp;gt; steal_guts_and_do_stuff( std::vector&amp;lt;int&amp;gt;&amp;amp;&amp;amp; vec )
{
   std::vector&amp;lt;int&amp;gt; result( std::move( vec ) );
   /* do stuff */
   return result;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;where you can see that &lt;code&gt;std::move&lt;/code&gt; has been used on &lt;code&gt;vec&lt;/code&gt;.  That is pretty much
it.  Just insure that in your rvalue overload implementations, you use &lt;code&gt;std::move&lt;/code&gt;
on all the parameters that you want to move from and that you do not reuse those
parameters after they have been moved from.  If you want your user defined types
to be &amp;ldquo;movable from&amp;rdquo;, then define a move constructor and a move assignment
operator and then a user will be able to move from your types.  And notice that
you do not use &lt;code&gt;std::move&lt;/code&gt; on the return statement.  Moving is done when you &lt;em&gt;use&lt;/em&gt;
the input parameter to cast it to an rvalue forcing the compiler to take the
rvalue overload of the function you are calling (in my case, move constructor).
You do not want to move the return.&lt;/p&gt;

&lt;h3 id=&#34;and-then-they-were-three-t&#34;&gt;And then they were three: T&amp;amp;&amp;amp;&lt;/h3&gt;

&lt;p&gt;As I have previously mentioned, the function that I wanted to convert to move
semantics was a template.  There is a catch in this case.  Actually, this function
declaration:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;template&amp;lt; typename T &amp;gt;
void foo( T&amp;amp;&amp;amp; param );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;does &lt;strong&gt;&lt;em&gt;not&lt;/em&gt;&lt;/strong&gt; declare an rvalue reference overload.  The reference here is a
forwarding reference&lt;sup&gt;[3]&lt;/sup&gt;.  Referencing once again Scott Meyer&amp;rsquo;s
&lt;a href=&#34;https://isocpp.org/blog/2012/11/universal-references-in-c11-scott-meyers&#34; target=&#34;_blank&#34;&gt;blog post&lt;/a&gt;
on &lt;a href=&#34;http://isocpp.org&#34; target=&#34;_blank&#34;&gt;isocpp.org&lt;/a&gt;, one finds this rule of thumb to determine the
if an expression is a forwarding reference:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;If a variable or parameter is declared to have type T&amp;amp;&amp;amp; for some deduced type T,
that variable or parameter is a universal reference.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Deduced type mostly means templates and `auto (which I won&amp;rsquo;t talk about anymore).
What is particular about forwarding references is that they can bind to both
lvalues and rvalues, depending on what type (not value) it is initialized with.
In fact, they will bind to lvalues, rvalues, const, non-const, volatile,
non-volatile&amp;hellip;  This makes them really greedy and has some interesting
consequences on the overload set, but that&amp;rsquo;s not the subject here.&lt;/p&gt;

&lt;p&gt;So now, three types of references have been mentioned: lvalue references, rvalue
references and forwarding references.  When implementing a function overload for
one of the reference type, inside the function body, one must make sure to
understand what should happen.  For an lvalue reference overload, the parameter
is an lvalue and should never be moved from.  For an rvalue reference overload,
the parameter is always an rvalue, thus temporary, and can always be moved from.
For a forwarding reference, the parameter can be either an lvalue or an rvalue
and should be moved from in the latter case, but not the former.  The need to
cast in the function body has been previously explained.  I also mentioned that
the tool to cast unconditionally to an rvalue reference is &lt;code&gt;std::move&lt;/code&gt;.  For
forwarding references, the tool to &lt;strong&gt;&lt;em&gt;conditionally&lt;/em&gt;&lt;/strong&gt; cast to rvalue references
is &lt;code&gt;std::forward&lt;/code&gt;.  This standard library template will cast an lvalue reference
(or something that binds to an lvalue reference) to an lvalue reference and an
rvalue reference (or something that binds to an rvalue reference) to an rvalue
reference.  The mechanism used for this is reference collapsing and the result is
exactly what we need to implement the forwarding reference overload.  The
following code snippet illustrates what usually should be done:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;MyClass from_vec( std::vector const&amp;amp; vec )
{
   return MyClass{ vec };
}

MyClass from_vec( std::vector&amp;amp;&amp;amp; vec )
{
   return MyClass{ std::move( vec ) };
}

template&amp;lt; typename C &amp;gt;
MyClass from_container( C&amp;amp;&amp;amp; container )
{
   return MyClass{ std::forward&amp;lt; C &amp;gt;( vec ) };
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It should be noted that for &lt;code&gt;std::forward&lt;/code&gt;, template argument deduction
&lt;a href=&#34;http://stackoverflow.com/questions/7779900/why-is-template-
argument-deduction-disabled-with-stdforward&#34; target=&#34;_blank&#34;&gt;would not produce&lt;/a&gt;
&lt;a href=&#34;http://stackoverflow.com/questions/28828159/usage-of-stdforward-vs-stdmove&#34; target=&#34;_blank&#34;&gt;the desired results&lt;/a&gt;, so
the type has to be repeated in the call to the function.&lt;/p&gt;

&lt;h3 id=&#34;the-result&#34;&gt;The result&lt;/h3&gt;

&lt;p&gt;So, now, I have everything I need to write my function.  It is a template, so it
will use the forwarding references.  This is my new implementation:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;template&amp;lt; typename T &amp;gt;
std::string to_string( T&amp;amp;&amp;amp; to_convert )
{
   std::stringstream strm( &amp;quot;&amp;quot; );
   strm &amp;lt;&amp;lt; std::forward&amp;lt;T&amp;gt;( to_convert );
   return strm.str();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If (and as I pointed out in the intro, it is not the case) the &lt;code&gt;stringstream&lt;/code&gt;
redirect operator (&lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;) has an rvalue overload which steals the internals of
it&amp;rsquo;s argument, it will do so for the cases where &lt;code&gt;to_string&lt;/code&gt; is called with an
rvalue and it will use the regular lvalue reference overload when called with an
lvalue.  This is the &amp;ldquo;optimal&amp;rdquo; or near optimal behavior for my function.&lt;/p&gt;

&lt;p&gt;To get to my implementation, I had first simply stuck a &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; symbol to my reference
(removing the const, of course) and used &lt;code&gt;std::move&lt;/code&gt;.  It failed for reasons that
are now apparent from the discussion in the previous sections.  After that, I
started to read all of the references I link in these notes (and more) and realized
I needed to use &lt;code&gt;std::forward&lt;/code&gt;.  I finally realized that for my function, this is
useless, but the journey was worth it!&lt;/p&gt;

&lt;h3 id=&#34;notes&#34;&gt;Notes&lt;/h3&gt;

&lt;p&gt;&lt;sup&gt;[1]&lt;/sup&gt; Yes, I am sure someone else would do a better job at writing it
more &lt;a href=&#34;http://zverovich.net/2013/09/07/integer-to-string-
conversion-in-cplusplus.html&#34; target=&#34;_blank&#34;&gt;generic, faster, better&lt;/a&gt;, etc.; not the point!&lt;/p&gt;

&lt;p&gt;&lt;sup&gt;[2]&lt;/sup&gt; The C language itself borrowed the concepts from CPL (see
&lt;a href=&#34;http://blog.smartbear.com/development/c11-tutorial-explaining-the-ever-
elusive-lvalues-and-rvalues/&#34; target=&#34;_blank&#34;&gt;this&lt;/a&gt; blog post by Danny Kalev).&lt;/p&gt;

&lt;p&gt;&lt;sup&gt;[3]&lt;/sup&gt; Scott Meyers used the terminology Universal References both in
his articles and his book
&lt;a href=&#34;http://shop.oreilly.com/product/0636920033707.do&#34; target=&#34;_blank&#34;&gt;Effective Modern C++&lt;/a&gt;, but
after discussion with members of the ISO C++ committee and the C++ community, he
agreed to include a footnote (in Item 24) to say that since they should almost
always be used with &lt;code&gt;std::forward&lt;/code&gt;, the name forwarding references is gaining
traction.&lt;/p&gt;

&lt;p&gt;&lt;sup&gt;[4]&lt;/sup&gt; Unreferenced in the text:
&lt;a href=&#34;http://stackoverflow.com/questions/36696312/
why-is-pass-by-value-and-pass-by-rvalue-overload-c-function-call-ambiguous&#34; target=&#34;_blank&#34;&gt;ambiguous call&lt;/a&gt;&lt;/p&gt;
</description>
      </item>
      
    
      
      <item>
        <title>Using a theme with Hugo</title>
        <link>https://ghlecl.github.io/posts/hugo_theme/</link>
        <pubDate>Thu, 05 Jan 2017 00:00:00 +0000</pubDate>
        <author>codeattempts@gmail.com - Ghyslain Leclerc</author>
        <guid>https://ghlecl.github.io/posts/hugo_theme/</guid>
        <description>

&lt;h1 id=&#34;hugo-themes&#34;&gt;Hugo themes&lt;/h1&gt;

&lt;p&gt;Initially, I had two objectives for this blog.  One was to have a place where I
could write some notes on programming for myself so that I could find them when
I needed them.  The other was to learn a bit more about the web.&lt;/p&gt;

&lt;p&gt;I thought (naively, granted) I could write it all myself using a static site
generator.  I wanted to write the HTML, the CSS, the JavaScript, everything!  I
thought it would not be too difficult using the templating engine of the static
site generator and a front end development framework
(&lt;a href=&#34;http://foundation.zurb.com/&#34; target=&#34;_blank&#34;&gt;Zurb Foundation&lt;/a&gt; was my initial choice).  Turns
out I was both right and wrong.&lt;/p&gt;

&lt;p&gt;Using the static site generator and a CSS/front end framework, I was able to get
a basic site working with little previous knowledge of CSS and HTML.  My
background is actually physics and so web programming is something new to me.
Took me a few nights, but it was up and running in a reasonable amount of time
(for me).  Unfortunately, it turns out it was not as easy/quick as I had hoped to
set it up, let alone customize the site.  I quickly found myself spending more and
more time on the &amp;ldquo;mechanics&amp;rdquo; of the site and barely any time at all writing my
programming notes.&lt;/p&gt;

&lt;p&gt;As I said, I was both right and wrong: you can make a site form scratch without
too much difficulty using the static site generator and a web framework, but it
still takes a fair amount of time, time which I found out I was not willing to
spend.  So I set out to explore &lt;a href=&#34;https://gohugo.io/&#34; target=&#34;_blank&#34;&gt;Hugo&amp;rsquo;s&lt;/a&gt; theming mechanism
and the &lt;a href=&#34;http://themes.gohugo.io/&#34; target=&#34;_blank&#34;&gt;available themes&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;I considered quite a few of them.  I was looking for something simple and did not
have that many requirements (I think).  I really wanted to have pagination and,
if possible, search and &lt;a href=&#34;https://disqus.com/&#34; target=&#34;_blank&#34;&gt;Disqus&lt;/a&gt; integration (the latter
two I ended up dropping).  I also did not want too many fonts and too many
moving parts.  Ideally, it would not be too hard to customize the site/theme.
Analytics do not really interest me.  All and all, nothing too fancy.&lt;/p&gt;

&lt;p&gt;At some point, I was interested in Google&amp;rsquo;s
&lt;a href=&#34;https://material.io/&#34; target=&#34;_blank&#34;&gt;Material Design&lt;/a&gt; and so thought a theme using it might
be nice.  Unfortunately, I could not find a material design based theme that was
simple enough for me to customize (of course, others might disagree on that!).
Then I thought something using &lt;a href=&#34;http://webcomponents.org/&#34; target=&#34;_blank&#34;&gt;Web Components&lt;/a&gt; might
be interesting so I looked into a theme using
&lt;a href=&#34;https://www.polymer-project.org/1.0/&#34; target=&#34;_blank&#34;&gt;Polymer&lt;/a&gt;.  Again, nothing easy enough to
customize for my skill level.  I think that is the point: anything interesting or
new will take me too much time to work on and take me away from writing, which
for me is the point of all this.&lt;/p&gt;

&lt;p&gt;So in the end, I chose a theme that is out of the box really pleasing to me:
&lt;a href=&#34;http://themes.gohugo.io/internet-weblog/&#34; target=&#34;_blank&#34;&gt;Internet Weblog&lt;/a&gt; by
&lt;a href=&#34;http://jnjosh.com/&#34; target=&#34;_blank&#34;&gt;Josh Johnson&lt;/a&gt;.  Really nice theme which is, at least up till
now, easy enough to customize to my needs.  The only thing I have had trouble
with is the fact that the theme was written for an older Hugo version and some
template syntax (mainly capitalization of variable names) was not portable to the
current version (0.18 when writing this).  I was able to fairly quickly make the
necessary changes to the theme and allow it to run on the version of Hugo I am
using.&lt;/p&gt;

&lt;p&gt;In the future, I might look into creating a search box for the site.  Currently,
this blog does not hold that many posts, but the theme comes with the idea/concept
of microposts which I really like.  Microposts actually serve my purpose of
programming notes even better than full posts, I think.  Often, I solve a small
problem in a particular way and I would like to remember my solution without
writing a full blog post about it (usually because it does not warrant that).
Writing a small 1-2 paragraph micropost to remember the solution would be perfect.
The problem is if too many of those pile up, then you can&amp;rsquo;t find them easily
anymore.  So a search box for the site would be nice.  At least that&amp;rsquo;s what I
think right now.&lt;/p&gt;

&lt;p&gt;As for Disqus integration, I thought it might be interesting to discuss (no pun
intended) the more technical posts I write here with people, but it&amp;rsquo;s really a
low priority.  I usually take things to heart a little too much and the internet
is the best place to be told you are dumb in a very &amp;ldquo;nonconstructive&amp;rdquo; manner.
Those two probably don&amp;rsquo;t mix well and so not opening my posts for comments might
be a better idea for me.  Who knows what the future holds.&lt;/p&gt;

&lt;p&gt;This means that the information about my
&lt;a href=&#34;https://ghlecl.github.io/posts/hugo/&#34; target=&#34;_blank&#34;&gt;initial Hugo setup&lt;/a&gt; is already out of date and
invalid.  I might try and write a post (micropost?) about the new setup in the
near future, but basically, I mostly use default values and a theme.&lt;/p&gt;

&lt;p&gt;So now that I have a theme that I like for the site, I can start posting a bit
more often (hopefully).&lt;/p&gt;
</description>
      </item>
      
    
      
      <item>
        <title>Timing pieces of code</title>
        <link>https://ghlecl.github.io/posts/cxx_time_it/</link>
        <pubDate>Sun, 20 Mar 2016 00:00:00 +0000</pubDate>
        <author>codeattempts@gmail.com - Ghyslain Leclerc</author>
        <guid>https://ghlecl.github.io/posts/cxx_time_it/</guid>
        <description>

&lt;h1 id=&#34;execution-time-measurements&#34;&gt;Execution time measurements&lt;/h1&gt;

&lt;h3 id=&#34;python-s-timeit-and-repeat&#34;&gt;Python&amp;rsquo;s timeit and repeat&lt;/h3&gt;

&lt;p&gt;I sometimes want to time my code to see which version of a function I wrote runs
faster.  I know that you should &lt;em&gt;&lt;strong&gt;always&lt;/strong&gt;&lt;/em&gt; profile before you optimize and that
&lt;a href=&#34;https://en.wikipedia.org/wiki/Benchmark_%28computing%29#Types_of_benchmarks&#34; target=&#34;_blank&#34;&gt;micro-benchmarking&lt;/a&gt;
has &lt;a href=&#34;http://stackoverflow.com/a/2842707&#34; target=&#34;_blank&#34;&gt;lots of caveats&lt;/a&gt; (some of which I have
myself fallen victim to), but still, sometimes, curiosity gets the best of me and
I just have to know.  When I am writing in Python, I use the &lt;code&gt;timeit&lt;/code&gt;
&lt;a href=&#34;https://docs.python.org/3/library/timeit.html?highlight=timeit#module-timeit&#34; target=&#34;_blank&#34;&gt;module&lt;/a&gt;
to measure code execution.  This handy module has two main utility functions:
&lt;code&gt;timeit&lt;/code&gt; and &lt;code&gt;repeat&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;timeit&lt;/code&gt; will run a piece of code &lt;code&gt;n&lt;/code&gt; times while measuring the execution time of
each repetition.  It then gives back the lowest time, which is arguably the time
needed to run the code when nothing else on the system is interfering.  Of course,
when the code will be run, other things will want CPU time alongside your program
and the OS will have to balance it all, but &lt;em&gt;usually&lt;/em&gt;, that should not be taken
into account when doing micro-benchmarks.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;repeat&lt;/code&gt; will again run a piece of code &lt;code&gt;n&lt;/code&gt; times, but will repeat that experiment
&lt;code&gt;r&lt;/code&gt; times, returning a list with the lowest execution time of each repetition of
the experiment.  The following snippet shows how to use both of them in code.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from timeit import timeit, repeat

n = 1000
r = 2
times_repeat = repeat( &amp;quot;def Fn( x ): return x**2;myFn( 4 )&amp;quot;, repeat = r, number = n )
times_timeit = []
for idx in range( r ):
    times_timeit.append( timeit( &amp;quot;def Fn( x ): return x**2;myFn( 4 )&amp;quot;, number = n ) )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There are two other ways to use the &lt;code&gt;timeit&lt;/code&gt; module, namely via the command line
with the executable module syntax and using an interactive Python shell like
&lt;a href=&#34;https://ipython.org/&#34; target=&#34;_blank&#34;&gt;iPython&lt;/a&gt; which has the magic function &lt;code&gt;%timeit&lt;/code&gt;.  I won&amp;rsquo;t
cover those subjects here.&lt;/p&gt;

&lt;h3 id=&#34;trying-it-out-in-c-time-it&#34;&gt;Trying it out in C++ : time_it&lt;/h3&gt;

&lt;p&gt;The thing is, I don&amp;rsquo;t always do things in Python and I wanted to have a function
similar to &lt;code&gt;timeit&lt;/code&gt; which would allow me to measure the execution time of a
function or piece of code in C++.  It turns out that with C++14 (don&amp;rsquo;t know if
C++11 is sufficient, but C++17/C++1z will make it easier I think), it is possible
to get close to it.  When I got the idea, I started to think about the
&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4169.html&#34; target=&#34;_blank&#34;&gt;proposed&lt;/a&gt;
&lt;code&gt;std::invoke&lt;/code&gt; function that should (or has?) make it into the next standard.  This
function template takes a function, it&amp;rsquo;s arguments and invokes it.  This is pretty
close to what I need.  Coupling the facilities of &lt;code&gt;std::chrono&lt;/code&gt; with that function
could actually get me pretty close to what I want.  Because some compilers do not
yet have an implementation of &lt;code&gt;std::invoke&lt;/code&gt;, I had to first find one or write one.
I decided to use the implementation found on
&lt;a href=&#34;http://en.cppreference.com/w/cpp/utility/functional/invoke&#34; target=&#34;_blank&#34;&gt;cppreference.com&lt;/a&gt;.
But let&amp;rsquo;s pretend that std::invoke is available.  Then, one can write the function
template &lt;code&gt;time_it&lt;/code&gt;&lt;sup&gt;[1]&lt;/sup&gt; using &lt;code&gt;std::invoke&lt;/code&gt; and &lt;code&gt;std::chrono&lt;/code&gt;.  This is
the resulting function for those who do not want to read the steps I went through:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt;
   unsigned int repeat_invoke = 1000,
   unsigned int repeat_meas = 3,
   typename F, typename... ArgTypes
        &amp;gt;
std::array&amp;lt; double, repeat_meas &amp;gt;
time_it( F&amp;amp;&amp;amp; f, ArgTypes&amp;amp;&amp;amp;... args )
{
   using std::chrono::high_resolution_clock;
   using std::chrono::duration_cast;
   using std::numeric_limits;
   using std::chrono::nanoseconds;

   static_assert( repeat_invoke &amp;gt;= 1,
            &amp;quot;time_it: The number of times the code experiment is \
                                          repeated has to be at least 1.&amp;quot; );
   static_assert( repeat_meas &amp;gt;= 1,
            &amp;quot;time_it: The number of times the code is run has to \
                                                          be at least 1.&amp;quot; );

   double max_dbl = numeric_limits&amp;lt;double&amp;gt;::max();
   double cur_min = max_dbl;
   std::array&amp;lt; double, repeat_meas &amp;gt; shortest_times;
   for( unsigned int meas_idx( 0 ); meas_idx != repeat_meas; ++meas_idx )
   {
      for( unsigned int invoke_idx( 0 ); invoke_idx != repeat_invoke; ++invoke_idx )
      {
         auto start = high_resolution_clock::now();

         std::invoke( std::forward&amp;lt;F&amp;gt;(f), std::forward&amp;lt;ArgTypes&amp;gt;(args)... );

         auto elapsed = duration_cast&amp;lt; nanoseconds &amp;gt;(
                        high_resolution_clock::now() - start ).count();

         if( elapsed &amp;lt; cur_min ) { cur_min = elapsed; }
      }
      shortest_times[meas_idx] = cur_min;
      cur_min = max_dbl;
   }

   return shortest_times;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I skipped the includes in this code snippet.  I am not pretending this code is
exception safe, thread safe or any other kind of safe there is.  I am not
suggesting anybody else should use it.  It&amp;rsquo;s simply something I find useful.&lt;/p&gt;

&lt;h3 id=&#34;how-i-got-there&#34;&gt;How I got there&lt;/h3&gt;

&lt;p&gt;Basically, aside from the boiler plate stuff, the function is one that takes
another function and its parameters as input, and then outputs the minimum time
taken to execute the code.  The initial declaration could be written as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt; typename F, typename... ArgTypes &amp;gt;
double time_it( F&amp;amp;&amp;amp; f, ArgTypes&amp;amp;&amp;amp;... args );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This definition uses variadic templates.  You can find information on variadic
templates on &lt;a href=&#34;https://en.wikipedia.org/wiki/Variadic_template&#34; target=&#34;_blank&#34;&gt;various&lt;/a&gt;
&lt;a href=&#34;http://en.cppreference.com/w/cpp/language/parameter_pack&#34; target=&#34;_blank&#34;&gt;sites&lt;/a&gt;.  The problem
I had with that first iteration is that I could not specify the number of
repetitions or the number of times I wanted to run the timing experiment
(equivalent to the &lt;code&gt;n&lt;/code&gt; and &lt;code&gt;r&lt;/code&gt; parameters of Python&amp;rsquo;s &lt;code&gt;timeit&lt;/code&gt;).  I had to find
a way to do that which would allow for default values as well, since I did not
want to specify those arguments every time I call the function.  To be able to
use default values in C++, the defaulted parameters have to be last (no keyword
arguments in C++ land).  That presented a problem because I also have to have a
parameter pack.  So to work around that, I introduced two defaulted template
arguments like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt;
   unsigned int repeat_invoke = 1000,
   unsigned int repeat_meas = 3,
   typename F,
   typename... ArgTypes
        &amp;gt;
std::array&amp;lt; double, repeat_meas &amp;gt;
time_it( F&amp;amp;&amp;amp; f, ArgTypes&amp;amp;&amp;amp;... args );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Sorry for the reformatting of the template declaration.  I must admit I struggle
to have a consistent formatting for templates.  I find nothing is completely
satisfying.  I should probably just use
&lt;a href=&#34;http://clang.llvm.org/docs/ClangFormat.html&#34; target=&#34;_blank&#34;&gt;Clang Format&lt;/a&gt;.  Anyhow, back to my
function.  The addition of the two template arguments allowed me to change the
return type to an array and I now have the functionality I want: I can specify,
albeit as template parameters, the number of repetitions and the number of
invocations at the call site.  All that was left to do was write the timing code,
since the function invocation itself is simply:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;std::invoke( std::forward&amp;lt;F&amp;gt;(f), std::forward&amp;lt;ArgTypes&amp;gt;(args)... );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The use of &lt;code&gt;std::forward&lt;/code&gt; in the code here is for efficiency.  The timing code is
based on &lt;code&gt;std::chrono::high_resolution_clock&lt;/code&gt;.  I chose to simply record the time
before the invocation with &lt;code&gt;std::chrono::high_resolution_clock::now()&lt;/code&gt; and do the
same after.  The difference is the elapsed time.  The choice of the clock could
be discussed.  The most important thing is for the clock to be steady.&lt;/p&gt;

&lt;h3 id=&#34;example-test&#34;&gt;Example / test&lt;/h3&gt;

&lt;p&gt;I have written a function which will make the current thread sleep for ten
milliseconds.  Then, I have used my new &lt;code&gt;time_it&lt;/code&gt; function to time the execution
of the defined function.  The code is reproduced here and actually serves as a
usage example.  There are also two calls with a lambda function, one taking
arguments.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void my_fn()
{
   using namespace std::chrono_literals;
   std::this_thread::sleep_for( 10ms );
}

int main( int argc, char* argv[] )
{
   // get times
   auto test_val_0 = time_it( my_fn );
   auto test_val_1 = time_it&amp;lt; 100, 6 &amp;gt;( my_fn );
   auto test_val_2 = time_it&amp;lt; 500 &amp;gt;( my_fn );
   auto test_val_3 = time_it&amp;lt; 1000, 2 &amp;gt;( my_fn );
   auto test_val_4 = time_it&amp;lt; 1000, 8 &amp;gt;( [](){
            using namespace std::chrono_literals;
            std::this_thread::sleep_for( 5ms );
         } );
   auto test_val_5 = time_it&amp;lt; 1000, 3 &amp;gt;( []( int lt, int rt ){
            return lt - rt;
         }, 5, 7 );

   // output results
   std::cout &amp;lt;&amp;lt; &amp;quot;exp 0: [ &amp;quot; &amp;lt;&amp;lt; test_val_0[0] / 1000000.0
             &amp;lt;&amp;lt; &amp;quot;, &amp;quot; &amp;lt;&amp;lt;  test_val_0[1] / 1000000.0
             &amp;lt;&amp;lt; &amp;quot;, &amp;quot; &amp;lt;&amp;lt;  test_val_0[2] / 1000000.0 &amp;lt;&amp;lt; &amp;quot; ]\n&amp;quot;;
   std::cout &amp;lt;&amp;lt; &amp;quot;exp 1: [ &amp;quot; &amp;lt;&amp;lt; test_val_1[0] / 1000000.0
             &amp;lt;&amp;lt; &amp;quot;, &amp;quot; &amp;lt;&amp;lt;  test_val_1[1] / 1000000.0
             &amp;lt;&amp;lt; &amp;quot;, &amp;quot; &amp;lt;&amp;lt;  test_val_1[2] / 1000000.0
             &amp;lt;&amp;lt; &amp;quot;, &amp;quot; &amp;lt;&amp;lt;  test_val_1[3] / 1000000.0
             &amp;lt;&amp;lt; &amp;quot;, &amp;quot; &amp;lt;&amp;lt;  test_val_1[4] / 1000000.0
             &amp;lt;&amp;lt; &amp;quot;, &amp;quot; &amp;lt;&amp;lt;  test_val_1[5] / 1000000.0 &amp;lt;&amp;lt; &amp;quot; ]\n&amp;quot;;
   std::cout &amp;lt;&amp;lt; &amp;quot;exp 2: [ &amp;quot; &amp;lt;&amp;lt; test_val_2[0] / 1000000.0
             &amp;lt;&amp;lt; &amp;quot;, &amp;quot; &amp;lt;&amp;lt;  test_val_2[1] / 1000000.0
             &amp;lt;&amp;lt; &amp;quot;, &amp;quot; &amp;lt;&amp;lt;  test_val_2[2] / 1000000.0 &amp;lt;&amp;lt; &amp;quot; ]\n&amp;quot;;
   std::cout &amp;lt;&amp;lt; &amp;quot;exp 3: [ &amp;quot; &amp;lt;&amp;lt; test_val_3[0] / 1000000.0
             &amp;lt;&amp;lt; &amp;quot;, &amp;quot; &amp;lt;&amp;lt;  test_val_3[1] / 1000000.0 &amp;lt;&amp;lt; &amp;quot; ]\n&amp;quot;;
   std::cout &amp;lt;&amp;lt; &amp;quot;exp 4: [ &amp;quot; &amp;lt;&amp;lt; test_val_4[0] / 1000000.0
             &amp;lt;&amp;lt; &amp;quot;, &amp;quot; &amp;lt;&amp;lt;  test_val_4[1] / 1000000.0
             &amp;lt;&amp;lt; &amp;quot;, &amp;quot; &amp;lt;&amp;lt;  test_val_4[2] / 1000000.0
             &amp;lt;&amp;lt; &amp;quot;, &amp;quot; &amp;lt;&amp;lt;  test_val_4[3] / 1000000.0
             &amp;lt;&amp;lt; &amp;quot;, &amp;quot; &amp;lt;&amp;lt;  test_val_4[4] / 1000000.0
             &amp;lt;&amp;lt; &amp;quot;, &amp;quot; &amp;lt;&amp;lt;  test_val_4[5] / 1000000.0
             &amp;lt;&amp;lt; &amp;quot;, &amp;quot; &amp;lt;&amp;lt;  test_val_4[6] / 1000000.0
             &amp;lt;&amp;lt; &amp;quot;, &amp;quot; &amp;lt;&amp;lt;  test_val_4[7] / 1000000.0 &amp;lt;&amp;lt; &amp;quot; ]\n&amp;quot;;
   std::cout &amp;lt;&amp;lt; &amp;quot;exp 5: [ &amp;quot; &amp;lt;&amp;lt; test_val_5[0]
             &amp;lt;&amp;lt; &amp;quot;, &amp;quot; &amp;lt;&amp;lt;  test_val_5[1]
             &amp;lt;&amp;lt; &amp;quot;, &amp;quot; &amp;lt;&amp;lt;  test_val_5[2] &amp;lt;&amp;lt; &amp;quot; ]\n&amp;quot;;
   return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and the output on my machine is:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;exp 0: [ 10.0203, 10.0184, 10.0266 ]
exp 1: [ 10.0465, 10.0373, 10.0241, 10.0198, 10.0214, 10.0243 ]
exp 2: [ 10.0152, 10.0176, 10.0305 ]
exp 3: [ 10.02, 10.0174 ]
exp 4: [ 5.01679, 5.01788, 5.01327, 5.01883, 5.02777, 5.02198, 5.01831, 5.01463 ]
exp 5: [ 55, 55, 55 ]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;which, for the four first cases, is slightly more than 10ms and is what was
expected.  The expected value for the experiment labeled&amp;nbsp;4 is slightly higher
than&amp;nbsp;5&amp;nbsp;ms and for the last lambda, it should be in the nanoseconds range,
which it is.  Of course, the constant value is suspicious and probably means the
actual value is actually lower, but the &lt;code&gt;time_it&lt;/code&gt; overhead and the clock precision
is so that nothing below the 55ns value can be measured on my machine.  I have not
determined the error bar on the time measurement.  This is a complex subject and
much more work would be needed to test for that.  One other thing I have not tried
in this example is the timing of a member function, but it should work.&lt;/p&gt;

&lt;h3 id=&#34;what-is-impossible&#34;&gt;What is impossible&lt;/h3&gt;

&lt;p&gt;There are things I have found are not possible with the function as it stands.
One of them is the inability to pass &lt;code&gt;time_it&lt;/code&gt; a template function as an argument
without specifying the template arguments of the passed in (or timed) function.
I might be wrong, but I have not found a way to do that.  Explicit argument
passing is tedious and so &lt;code&gt;time_it&lt;/code&gt; might not be very useful in those cases.&lt;/p&gt;

&lt;p&gt;One other capability Python&amp;rsquo;s &lt;code&gt;timeit&lt;/code&gt; has that this one does not is the ability
to accept setup code which is executed before the experiment is run.  I am not
sure how useful that would be in the context of C++.  Of course, I can&amp;rsquo;t imagine
what others would use &lt;code&gt;time_it&lt;/code&gt; for, so it might be useful even though I can&amp;rsquo;t
see it, but I am not writing the STL!  It&amp;rsquo;s just that in my view, since C++ is
compiled and not interpreted, &lt;code&gt;time_it&lt;/code&gt; will still require a main function and an
executable to run, unlike Python&amp;rsquo;s &lt;code&gt;timeit&lt;/code&gt; which can be run on the fly from the
command line to test something out.  To my mind, the setup code can then be
written in the main function to no real cost compared to having it done in the
&lt;code&gt;time_it&lt;/code&gt; function.  That being said, I believe it would be possible to accept a
setup function by making the input of &lt;code&gt;time_it&lt;/code&gt; two tuples of function and
arguments, the first being the function to test and the second being the setup
function.  I am just not 100% certain that it would be useful and I cannot say
for sure that it can be done because I have not tried implementing it.  In my
opinion, it would make calling the function without setup code much uglier.
Maybe an overload taking two tuples and the current version could live together
and that would allow the functionality at &amp;ldquo;no cost&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Anyhow, those are my thoughts on the matter for now.&lt;/p&gt;

&lt;h3 id=&#34;notes&#34;&gt;Notes&lt;/h3&gt;

&lt;p&gt;&lt;sup&gt;[1]&lt;/sup&gt; I chose the name with an underscore to differentiate the function
from its Python counterpart since my version does not do &lt;em&gt;exactly&lt;/em&gt; all the stuff
the python version can!&lt;/p&gt;
</description>
      </item>
      
    
      
      <item>
        <title>My Hugo Setup</title>
        <link>https://ghlecl.github.io/posts/hugo/</link>
        <pubDate>Sun, 14 Feb 2016 00:00:00 +0000</pubDate>
        <author>codeattempts@gmail.com - Ghyslain Leclerc</author>
        <guid>https://ghlecl.github.io/posts/hugo/</guid>
        <description>

&lt;h1 id=&#34;hugo&#34;&gt;Hugo&lt;/h1&gt;

&lt;p&gt;I have decided to go with &lt;a href=&#34;https://gohugo.io/&#34; target=&#34;_blank&#34;&gt;Hugo&lt;/a&gt; and
&lt;a href=&#34;https://pages.github.com/&#34; target=&#34;_blank&#34;&gt;Github Pages&lt;/a&gt; for this note taking blog.  This is
simply me describing my setup with Hugo and explaining what I have been able to
accomplish to this point.  It is not much, but writing it down helps me clarify
my thoughts and insures I don&amp;rsquo;t have to figure it out again (which, ironically,
I had to do to write and post this entry!).&lt;/p&gt;

&lt;h3 id=&#34;static-site-generation-via-hugo&#34;&gt;Static site generation via Hugo&lt;/h3&gt;

&lt;p&gt;Basically, in Hugo (as in many &lt;a href=&#34;https://www.staticgen.com/&#34; target=&#34;_blank&#34;&gt;static site generators&lt;/a&gt;),
the idea is to write content in files with a given format (often
&lt;a href=&#34;https://daringfireball.net/projects/markdown/&#34; target=&#34;_blank&#34;&gt;markdown&lt;/a&gt;) and specify how to
build a website out of this content via template/layout files.  Once you run the
executable (literally &lt;code&gt;hugo&lt;/code&gt;) on the directory structure containing all those
content and layout files, a static website is generated.  To mark a file as a
content file, you put a YAML or TOML header at the beginning of the file.  Some
information in the header is required by Hugo, some is optional and some is custom.&lt;/p&gt;

&lt;h3 id=&#34;the-setup&#34;&gt;The setup&lt;/h3&gt;

&lt;p&gt;The executable must know where to look for content and layouts/templates.  It also
has to have access to styling elements (CSS and images for instance).  It has
default locations where it looks for all those files and pre-supposes a few names,
but most of it is configurable.  Here is what I used:&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Parameter&lt;/th&gt;
&lt;th&gt;Value&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Kept default ?&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;base URL&lt;/td&gt;
&lt;td&gt;&lt;code&gt;http://ghlecl.github.io/&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;n/a&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;contentdir&lt;/td&gt;
&lt;td&gt;&lt;code&gt;content&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;y&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;layoutdir&lt;/td&gt;
&lt;td&gt;&lt;code&gt;templates&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;n&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;publishDir&lt;/td&gt;
&lt;td&gt;&lt;code&gt;public&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;y&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;dataDir&lt;/td&gt;
&lt;td&gt;&lt;code&gt;data&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;y&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;publishdir&lt;/td&gt;
&lt;td&gt;&lt;code&gt;public&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;y&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;staticdir&lt;/td&gt;
&lt;td&gt;&lt;code&gt;static&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;y&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Unfortunately, capitalization matters and is not consistent.  All the variables
available can be &lt;a href=&#34;https://gohugo.io/overview/configuration/&#34; target=&#34;_blank&#34;&gt;found&lt;/a&gt; on the Hugo
site.&lt;/p&gt;

&lt;h3 id=&#34;versioning-and-publishing&#34;&gt;Versioning and publishing&lt;/h3&gt;

&lt;p&gt;To keep versions of all my posts and the site, I will be using
&lt;a href=&#34;https://git-scm.com/&#34; target=&#34;_blank&#34;&gt;Git&lt;/a&gt; as my version control software, unsurprisingly as I
am publishing on Github Pages.  I have made a setup inspired by the
&lt;a href=&#34;https://gohugo.io/tutorials/github-pages-blog/&#34; target=&#34;_blank&#34;&gt;tutorial&lt;/a&gt;, but not exactly as
they suggest.&lt;/p&gt;

&lt;p&gt;I actually want to keep my drafts private.  If I decide to commit drafts to the
version control in order to work on ideas, I do not want all those draft versions
with typos, bad sentences, bad ideas and brainstorming to be seen by everyone.
A private Git repository is needed for that and since I have not yet decided to
pay for a private Github account, I cannot have a private repository on that site.
To get a private repository, I have chosen to use
&lt;a href=&#34;https://bitbucket.org/&#34; target=&#34;_blank&#34;&gt;Bitbucket&lt;/a&gt;.  With that provider, I can get 5 private
repositories for free.  Thus, I have a private Git repository for my site.  This
is also where I keep my template code and everything that Hugo needs to create
the site.  I do not version the public directory in that repository.  To insure
that, it is added to the .gitignore file.&lt;/p&gt;

&lt;p&gt;Actually, were it not for the fact that the way Github Pages work is to publish
the master branch of a repository, I would not need another repository.  I would
simply version the raw materials Hugo needs and I would replace the public content
on the public server knowing that I can regenerate a version whenever I want for
the foreseeable future.  That being said, I cannot do that because Github pages
actually simply serves the last commit of master on your personal page
(username.github.io) or the latest commit of the gh-pages branch for a project
page.  In any case, I need a repository with at least one commit.  Whenever I
want to publish the site, I make a commit in the development git repository and
tag it as a site release with the date.  Then, I delete everything inside the
public directory except the .git folder and regenerate the site with Hugo.  Any
content that is not set to draft gets generated.  After that, I &lt;code&gt;cd&lt;/code&gt; into the
public folder (the public git repository), make a commit and push.  VoilÃ , the
site is updated.&lt;/p&gt;

&lt;p&gt;I cannot predict what problems I&amp;rsquo;ll have with this setup, but for now, it seems
fine and so I&amp;rsquo;ll run with it.  I&amp;rsquo;ll write another post later if I have to make
changes.&lt;/p&gt;
</description>
      </item>
      
    
      
      <item>
        <title>Static Site</title>
        <link>https://ghlecl.github.io/posts/static_site/</link>
        <pubDate>Tue, 29 Dec 2015 00:00:00 +0000</pubDate>
        <author>codeattempts@gmail.com - Ghyslain Leclerc</author>
        <guid>https://ghlecl.github.io/posts/static_site/</guid>
        <description>

&lt;h1 id=&#34;hugo&#34;&gt;Hugo&lt;/h1&gt;

&lt;p&gt;In a &lt;a href=&#34;https://ghlecl.github.io/posts/github_pages/&#34; target=&#34;_blank&#34;&gt;previous&lt;/a&gt; entry, I described how I got
to using &lt;a href=&#34;https://pages.github.com/&#34; target=&#34;_blank&#34;&gt;GitHub Pages&lt;/a&gt;.  That was one of the (if not
the) first question I had to figure out when I decided to write my notes in an
Internet format (ok, blog, but I don&amp;rsquo;t see myself as a blogger).  The second thing
I had to figure out was what to use as a writing tool.  I could simply write
static HTML by hand and leave it at that (actually, if you stumbled upon this
website before I posted my first few posts, I left a Hello World page up for a few
weeks/months while figuring all this out!).  I am trying to set the bar a little
higher than that for myself.&lt;/p&gt;

&lt;p&gt;For work, I have been playing with &lt;a href=&#34;https://www.djangoproject.com&#34; target=&#34;_blank&#34;&gt;Django&lt;/a&gt; and at
some point, I thought I could write something in Django or use a Django CMS, but
since GitHub Pages only serve static content, I had to abandon that plan.  I could
have done static HTML with some CSS framework like
&lt;a href=&#34;http://getbootstrap.com&#34; target=&#34;_blank&#34;&gt;Bootstrap&lt;/a&gt; or &lt;a href=&#34;http://foundation.zurb.com&#34; target=&#34;_blank&#34;&gt;Foundation&lt;/a&gt;.
Actually, that is how I started to write all of this, but then, the same friend
of mine that pointed me in the direction of GitHub Pages, also reminded me that
they suggest a workflow with &lt;a href=&#34;http://jekyllrb.com&#34; target=&#34;_blank&#34;&gt;Jekyll&lt;/a&gt;.  Trying to get
information about that, I learned that Jekyll is what is called a static site
generator and that there are quite a few
&lt;a href=&#34;https://www.staticgen.com/&#34; target=&#34;_blank&#34;&gt;alternatives&lt;/a&gt; out there.  Looking at a few of the
alternatives, I decided to go with &lt;a href=&#34;https://gohugo.io/&#34; target=&#34;_blank&#34;&gt;Hugo&lt;/a&gt; (no pun intended),
originally written by &lt;a href=&#34;https://github.com/spf13&#34; target=&#34;_blank&#34;&gt;Steve Francia&lt;/a&gt;.  I can&amp;rsquo;t claim
to have researched the subject extensively, but Hugo seemed like it was
configurable enough for my needs/tastes, fast enough and easy enough.&lt;/p&gt;

&lt;p&gt;Basically, the idea of a static site generator is to &amp;ldquo;build&amp;rdquo; a website telling a
build system (I like to think of it as a compiler) how to construct each individual
page using templates.  Then, all you do is generate new (mostly) unformatted
content and ask the generator to rebuild the site.  This will update everything
and include the new content.  As it constructs these pages, the build system will
make a list of the entries and collect bits and pieces of informations which it
will make available to you via a templating language (Hugo being written in
&lt;a href=&#34;https://golang.org/&#34; target=&#34;_blank&#34;&gt;Go&lt;/a&gt;, it uses Go&amp;rsquo;s templating language).  You will be able
to access that information more or less easily depending on the templating
language and insert it in your templates.  For instance, to create a page listing
all the posts of the site, you could, in the template, loop through the list of
posts and add each of them in a &lt;code&gt;&amp;lt;ul&amp;gt;&lt;/code&gt; element.  As another example, you can get
the title of the post in the template so that when designing the page, you can
style that title as you please.  For instance:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;h2 style=&amp;quot;bad idea, use CSS !&amp;quot;&amp;gt; $.Page.Title &amp;lt;/h2&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I am not suggesting it is a good practice to style that way (as mentioned in
the example), but it illustrates my point about the variables.  In the templates,
you can also include JavaScript or any other kind of valid HTML you want.  You can
therefore use a front-end CSS framework like &lt;a href=&#34;http://zurb.com/&#34; target=&#34;_blank&#34;&gt;Zurb&lt;/a&gt; Foundation
or &lt;a href=&#34;https://twitter.com/&#34; target=&#34;_blank&#34;&gt;Twitter&lt;/a&gt; Bootstrap.&lt;/p&gt;

&lt;p&gt;Alright, this is how I got to Hugo.  I will stop here and start a new post on my
setup.  The next post will mark my first post that will actually be what I want
for this little site: notes for me on how I did things.  It really is necessary.
Since writing the previous post, I have not done anything involving Hugo and
already, I can&amp;rsquo;t really remember the organization of all of this.  Hopefully,
taking notes will help.&lt;/p&gt;
</description>
      </item>
      
    
      
      <item>
        <title>GitHub Pages</title>
        <link>https://ghlecl.github.io/posts/github_pages/</link>
        <pubDate>Mon, 23 Nov 2015 00:00:00 +0000</pubDate>
        <author>codeattempts@gmail.com - Ghyslain Leclerc</author>
        <guid>https://ghlecl.github.io/posts/github_pages/</guid>
        <description>

&lt;h1 id=&#34;github-pages&#34;&gt;GitHub Pages&lt;/h1&gt;

&lt;p&gt;This is one of my first posts.  I have been toying with the idea of this blog for
quite some time now.  A flaw of mine: too much searching for the best solution,
not enough implementing.  I end up doing things too late.  Anyhow, I digress.&lt;/p&gt;

&lt;p&gt;One of the relevant questions when thinking of writing a blog is of course where
to publish and what tool(s) to use.  At some point, I was thinking of hosting on
an old computer of mine.  Played with the different servers (compiled
&lt;a href=&#34;https://httpd.apache.org&#34; target=&#34;_blank&#34;&gt;Apache&lt;/a&gt;, &lt;a href=&#34;https://www.lighttpd.net&#34; target=&#34;_blank&#34;&gt;lighttpd&lt;/a&gt; and
&lt;a href=&#34;https://www.nginx.com&#34; target=&#34;_blank&#34;&gt;Nginx&lt;/a&gt;).  Then, I realized all the time involved in
maintaining my own server and changed my mind.  I did not want to deal with the
security updates and the log checking (or the program checking the logs&amp;hellip;).  Not
that I am naÃ¯ve enough to think my content is worth hacking, but using my machine
on a bot net or whatnot might be.&lt;/p&gt;

&lt;p&gt;After that, I started looking into shared hosting.  That could have worked, I
even paid for a few months, but did nothing productive.  Was still learning
everything and for some reason (a friend of mine would say control issues, but who
knows really !), I did not want to go with &lt;a href=&#34;https://wordpress.com/&#34; target=&#34;_blank&#34;&gt;WordPress&lt;/a&gt;,
&lt;a href=&#34;https://www.joomla.org/&#34; target=&#34;_blank&#34;&gt;Joomla&lt;/a&gt; or another content management system.  That
seemed like overkill for my needs and yes, I like to control things on my computer
a little too much for my own good and I did not feel I could get control over
those behemoths in a reasonable timeframe.  Most of the shared hosting I looked
into (probably not exhaustive) seemed pre-configured for the CMS like systems, but
not for other things and I found myself again trying to configure Apache on the
shared host.&lt;/p&gt;

&lt;p&gt;I gave up for a while.  I was busy with other things; but lately, I have been
coming back to the idea of this blog.  Hence my looking into all those things
again.  That&amp;rsquo;s when a very good friend of mine suggested I look into
&lt;a href=&#34;https://pages.github.com/&#34; target=&#34;_blank&#34;&gt;GitHub Pages&lt;/a&gt;.  The idea is very interesting and if
someone else is reading this, it means I actually went through with this.  I
personally have two basic needs for a server: 1) writing a blog (and maybe a
private section as a journal) and 2) hosting private projects on Git.  With
GitHub Pages, I can actually easily create the blog and if I pay for a GitHub
account, I believe I should be able to do the private journal and the Git hosting
as well.  The monthly cost will be roughly the same as a hosted plan and I will
have almost zero if not zero administration to do.&lt;/p&gt;

&lt;p&gt;So that&amp;rsquo;s how I came to GitHub pages!  I am sure that since I am a novice at the
Internet (well creating content other then on my Facebook account), there are some
assumptions I have made that are wrong and my solution might be sub-optimal, but
it works for me.&lt;/p&gt;

&lt;p&gt;Now, let&amp;rsquo;s see if I can make a habit of writing.&lt;/p&gt;
</description>
      </item>
      
    
      
      <item>
        <title>About Me</title>
        <link>https://ghlecl.github.io/about/</link>
        <pubDate>Mon, 09 Nov 2015 00:00:00 +0000</pubDate>
        <author>codeattempts@gmail.com - Ghyslain Leclerc</author>
        <guid>https://ghlecl.github.io/about/</guid>
        <description>&lt;p&gt;Hi.  I&amp;rsquo;m Ghys, a French Canadian living in the province of QuÃ©bec, Canada.  I make a living as a medical physicist.  I like trying to get computers to do the actual data crunching for me.  I am a hobbyist programmer and this blog is mostly a way for me to write down notes and lessons about my code attempts.  I also write about random stuff.  Feel free to read or skip whatever you want!&lt;/p&gt;
</description>
      </item>
      
    
  </channel>
</rss>
